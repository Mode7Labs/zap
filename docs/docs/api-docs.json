{
  "version": "0.1.3",
  "generated": "2025-10-19T07:25:11.972Z",
  "repository": "https://github.com/Mode7Labs/zap",
  "description": "Complete Zap game engine documentation for AI assistants",
  "categories": {
    "advanced": [
      {
        "slug": "advanced/collision-detection",
        "title": "Collision Detection",
        "description": "Detect overlaps and handle collisions between entities",
        "path": "advanced/collision-detection.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/advanced/collision-detection.md",
        "content": "# Collision Detection\n\nZap provides built-in collision detection using Axis-Aligned Bounding Boxes (AABB) with event-based collision handling.\n\n## Important: How Collision Detection Works\n\nCollision detection in Zap is **automatic** and **event-driven**. Just enable it and listen for events:\n\n1. **Enable collision checking** on the entity: `entity.checkCollisions = true`\n2. **Listen for collision events**: `entity.on('collisionenter', ...)`\n\nThe Scene automatically checks collisions every frame for all entities with `checkCollisions = true`.\n\n## Basic Collision\n\nDetect when two entities overlap:\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst player = new Sprite({\n  x: 100,\n  y: 150,\n  width: 50,\n  height: 50,\n  color: '#4fc3f7',\n  radius: 25,\n  interactive: true\n});\n\nconst enemy = new Sprite({\n  x: 300,\n  y: 150,\n  width: 50,\n  height: 50,\n  color: '#e94560',\n  radius: 25\n});\n\nscene.add(player);\nscene.add(enemy);\n\n// Enable collision checking\nplayer.checkCollisions = true;\n\n// Listen for collisions\nplayer.on('collisionenter', (event) => {\n  console.log('Hit enemy!');\n  player.color = '#f39c12';\n});\n\nplayer.on('collisionexit', () => {\n  console.log('Separated from enemy');\n  player.color = '#4fc3f7';\n});\n\n// Make player draggable\nplayer.on('drag', (event) => {\n  player.x += event.delta.x;\n  player.y += event.delta.y;\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Collision Events\n\nThree collision events are available:\n\n### collisionenter\n\nFired once when collision starts:\n\n```javascript\nplayer.on('collisionenter', (event) => {\n  console.log('Collision started with:', event.other);\n  playSound('hit');\n});\n```\n\n### collide\n\nFired every frame while colliding:\n\n```javascript\nplayer.on('collide', (event) => {\n  // Continuous collision\n  player.health -= 0.1 * deltaTime;\n});\n```\n\n### collisionexit\n\nFired once when collision ends:\n\n```javascript\nplayer.on('collisionexit', (event) => {\n  console.log('Collision ended with:', event.other);\n});\n```\n\n## Manual Collision Check\n\nCheck collision without events:\n\n```javascript\nif (player.intersects(enemy)) {\n  console.log('Player touching enemy!');\n}\n```\n\n## Collision Tags\n\nFilter collisions by tags:\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst player = new Sprite({\n  x: 100,\n  y: 150,\n  width: 40,\n  height: 40,\n  color: '#4fc3f7',\n  radius: 20,\n  interactive: true,\n  checkCollisions: true\n});\n\n// Only collide with entities tagged 'coin'\nplayer.collisionTags = ['coin'];\n\n// Create coins\nfor (let i = 0; i < 3; i++) {\n  const coin = new Sprite({\n    x: 200 + i * 70,\n    y: 150,\n    width: 30,\n    height: 30,\n    color: '#f39c12',\n    radius: 15\n  });\n\n  coin.addTag('coin');\n  scene.add(coin);\n}\n\n// Create enemies (won't collide with player)\nconst enemy = new Sprite({\n  x: 300,\n  y: 200,\n  width: 40,\n  height: 40,\n  color: '#e94560',\n  radius: 20\n});\n\nenemy.addTag('enemy');\nscene.add(enemy);\nscene.add(player);\n\n// Collect coins\nplayer.on('collisionenter', (event) => {\n  if (event.other.hasTag('coin')) {\n    event.other.destroy();\n    console.log('Coin collected!');\n  }\n});\n\n// Drag player\nplayer.on('drag', (event) => {\n  player.x += event.delta.x;\n  player.y += event.delta.y;\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Distance Check\n\nCheck distance between entities:\n\n```javascript\nconst distance = player.distanceTo(enemy);\n\nif (distance < 100) {\n  console.log('Enemy nearby!');\n}\n```\n\n## Contains Point\n\nCheck if a point is inside an entity:\n\n```javascript\ngame.on('tap', (event) => {\n  if (player.containsPoint(event.position.x, event.position.y)) {\n    console.log('Clicked on player!');\n  }\n});\n```\n\n## Get Bounding Box\n\nAccess entity bounds:\n\n```javascript\nconst bounds = player.getBounds();\n\nconsole.log('Left:', bounds.left);\nconsole.log('Right:', bounds.right);\nconsole.log('Top:', bounds.top);\nconsole.log('Bottom:', bounds.bottom);\n```\n\n## Common Patterns\n\n### Player vs Enemies\n\nDetect when player hits enemies:\n\n```javascript\nconst player = new Sprite({ /* ... */ });\nplayer.checkCollisions = true;\nplayer.collisionTags = ['enemy'];\n\nconst enemies = [];\nfor (let i = 0; i < 5; i++) {\n  const enemy = new Sprite({ /* ... */ });\n  enemy.addTag('enemy');\n  enemies.push(enemy);\n  scene.add(enemy);\n}\n\nplayer.on('collisionenter', (event) => {\n  if (event.other.hasTag('enemy')) {\n    player.health -= 20;\n    event.other.destroy();\n  }\n});\n```\n\n### Collectibles\n\nPickup coins, powerups, etc:\n\n```javascript\nconst player = new Sprite({ /* ... */ });\nplayer.checkCollisions = true;\nplayer.collisionTags = ['collectible'];\n\nlet score = 0;\n\nplayer.on('collisionenter', (event) => {\n  const item = event.other;\n\n  if (item.hasTag('coin')) {\n    score += 10;\n    item.destroy();\n    playSound('coin');\n  } else if (item.hasTag('powerup')) {\n    player.invincible = true;\n    item.destroy();\n\n    delay(5000, () => {\n      player.invincible = false;\n    });\n  }\n});\n```\n\n### Trigger Zones\n\nAreas that activate when player enters:\n\n```javascript\nconst trigger = new Sprite({\n  x: 300,\n  y: 200,\n  width: 100,\n  height: 100,\n  color: '#51cf66',\n  alpha: 0.3  // Semi-transparent\n});\n\ntrigger.addTag('trigger');\nscene.add(trigger);\n\nplayer.checkCollisions = true;\nplayer.collisionTags = ['trigger'];\n\nplayer.on('collisionenter', (event) => {\n  if (event.other.hasTag('trigger')) {\n    console.log('Entered trigger zone!');\n    openDoor();\n  }\n});\n\nplayer.on('collisionexit', (event) => {\n  if (event.other.hasTag('trigger')) {\n    console.log('Left trigger zone!');\n    closeDoor();\n  }\n});\n```\n\n### Bullet Collision\n\nProjectiles hitting targets:\n\n```javascript\nfunction fireBullet() {\n  const bullet = new Sprite({\n    x: player.x,\n    y: player.y,\n    width: 10,\n    height: 10,\n    color: '#fff',\n    radius: 5,\n    checkCollisions: true,\n    collisionTags: ['enemy']\n  });\n\n  bullet.velocityX = 300;\n  scene.add(bullet);\n\n  bullet.on('collisionenter', (event) => {\n    if (event.other.hasTag('enemy')) {\n      event.other.health -= 10;\n      bullet.destroy();\n    }\n  });\n}\n```\n\n### Platform Collision\n\nSimple platform detection:\n\n```javascript\nplayer.checkCollisions = true;\nplayer.collisionTags = ['platform'];\n\nplayer.on('collisionenter', (event) => {\n  if (event.other.hasTag('platform')) {\n    // Stop falling\n    player.velocityY = 0;\n    player.onGround = true;\n\n    // Position on top of platform\n    const platformTop = event.other.getBounds().top;\n    player.y = platformTop - player.height / 2;\n  }\n});\n\nplayer.on('collisionexit', (event) => {\n  if (event.other.hasTag('platform')) {\n    player.onGround = false;\n  }\n});\n```\n\n### Proximity Detection\n\nActivate when player gets close:\n\n```javascript\nscene.on('update', () => {\n  const distance = player.distanceTo(npc);\n\n  if (distance < 50) {\n    // Show interaction prompt\n    promptText.visible = true;\n\n    // Press E to interact\n    if (keyboard.isPressed('e')) {\n      startDialogue();\n    }\n  } else {\n    promptText.visible = false;\n  }\n});\n```\n\n### Collision Groups\n\nMultiple collision layers:\n\n```javascript\n// Setup\nconst player = new Sprite({ /* ... */ });\nplayer.checkCollisions = true;\nplayer.collisionTags = ['enemy', 'collectible', 'wall'];\n\n// Enemies\nconst enemy = new Sprite({ /* ... */ });\nenemy.addTag('enemy');\n\n// Walls\nconst wall = new Sprite({ /* ... */ });\nwall.addTag('wall');\n\n// Collectibles\nconst coin = new Sprite({ /* ... */ });\ncoin.addTag('collectible');\n\n// Handle different collision types\nplayer.on('collisionenter', (event) => {\n  const other = event.other;\n\n  if (other.hasTag('enemy')) {\n    player.health -= 20;\n  } else if (other.hasTag('collectible')) {\n    player.score += 10;\n    other.destroy();\n  } else if (other.hasTag('wall')) {\n    // Stop movement (simple approach)\n    player.velocityX = 0;\n    player.velocityY = 0;\n  }\n});\n```\n\n### Knockback on Hit\n\nPush player away from enemy:\n\n```javascript\nplayer.on('collisionenter', (event) => {\n  if (event.other.hasTag('enemy')) {\n    player.health -= 10;\n\n    // Calculate knockback direction\n    const dx = player.x - event.other.x;\n    const dy = player.y - event.other.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // Normalize and apply knockback\n    player.velocityX = (dx / distance) * 200;\n    player.velocityY = (dy / distance) * 200;\n\n    // Flash red\n    player.color = '#e94560';\n    delay(200, () => {\n      player.color = '#4fc3f7';\n    });\n  }\n});\n```\n\n### Door Unlock\n\nCollision with key unlocks door:\n\n```javascript\nconst player = new Sprite({ /* ... */ });\nplayer.checkCollisions = true;\nplayer.collisionTags = ['key', 'door'];\nplayer.hasKey = false;\n\nplayer.on('collisionenter', (event) => {\n  if (event.other.hasTag('key')) {\n    player.hasKey = true;\n    event.other.destroy();\n    showMessage('Key obtained!');\n  } else if (event.other.hasTag('door')) {\n    if (player.hasKey) {\n      event.other.destroy();\n      showMessage('Door unlocked!');\n    } else {\n      showMessage('Door is locked. Find a key!');\n    }\n  }\n});\n```\n\n## Performance Tips\n\nThe Scene automatically optimizes collision detection by:\n\n- Only checking entities with `checkCollisions = true`\n- Skipping inactive entities\n- Using efficient AABB overlap tests\n\nFor large numbers of entities (100+), consider:\n\n- Using `collisionTags` to filter what each entity collides with\n- Only enabling `checkCollisions` on entities that need it\n- Using `distanceTo()` for proximity checks before expensive operations\n\n## API Reference\n\n### `entity.intersects(other)`\n\nCheck if two entities overlap.\n\n**Parameters**:\n- `other` (Entity) - Entity to check against\n\n**Returns**: boolean\n\n```javascript\nif (player.intersects(enemy)) {\n  console.log('Collision!');\n}\n```\n\n### `entity.checkCollision(other)`\n\nManually check collision with a specific entity and emit events.\n\n**Note**: The Scene automatically calls this for all entities with `checkCollisions = true`. Only use this method for advanced scenarios where you need manual control.\n\n**Parameters**:\n- `other` (Entity) - Entity to check against\n\n**Returns**: void\n\n```javascript\n// Advanced: Manual collision check\nplayer.checkCollision(enemy);\n```\n\n### `entity.distanceTo(other)`\n\nGet distance between entities.\n\n**Parameters**:\n- `other` (Entity) - Entity to measure to\n\n**Returns**: number\n\n```javascript\nconst distance = player.distanceTo(enemy);\n```\n\n### `entity.containsPoint(x, y)`\n\nCheck if point is inside entity.\n\n**Parameters**:\n- `x` (number) - X coordinate\n- `y` (number) - Y coordinate\n\n**Returns**: boolean\n\n```javascript\nif (entity.containsPoint(mouseX, mouseY)) {\n  console.log('Mouse over entity!');\n}\n```\n\n### `entity.getBounds()`\n\nGet entity bounding box.\n\n**Returns**: { left, right, top, bottom }\n\n```javascript\nconst bounds = entity.getBounds();\nconsole.log(bounds.left, bounds.right, bounds.top, bounds.bottom);\n```\n\n### `entity.getCollisions()`\n\nGet all currently colliding entities.\n\n**Returns**: Entity[]\n\n```javascript\nconst colliding = player.getCollisions();\nconsole.log(`Colliding with ${colliding.length} entities`);\n```\n\n## Properties\n\n### `checkCollisions`\n\nEnable/disable collision checking:\n\n```javascript\nentity.checkCollisions = true;  // Enable\nentity.checkCollisions = false; // Disable\n```\n\n### `collisionTags`\n\nFilter which entities to collide with:\n\n```javascript\nentity.collisionTags = ['enemy', 'wall'];\n```\n\n## Limitations\n\n- **AABB Only**: Uses axis-aligned bounding boxes (rectangles)\n- **No rotation**: Rotated entities still use upright bounding boxes\n- **No physics**: Collision detection only, no automatic physics response\n\n## Tips\n\n- **Use tags** - Organize entities with collision tags for filtering\n- **Enable selectively** - Only set `checkCollisions = true` on entities that need it\n- **Handle in events** - Use collision events for clean separation of concerns\n- **Filter with tags** - Use `collisionTags` to limit what each entity collides with\n- **Use intersects() for one-time checks** - For simple overlap tests without events\n\n## Common Mistakes\n\n### Forgetting to enable\n\n```javascript\n// ❌ Wrong - checkCollisions not enabled\nplayer.on('collisionenter', () => { /* never fires */ });\n\n// ✅ Right - enable collision checking\nplayer.checkCollisions = true;\nplayer.on('collisionenter', () => { /* fires correctly */ });\n```\n\n### Wrong event\n\n```javascript\n// ❌ Wrong - 'collision' event doesn't exist\nplayer.on('collision', () => { /* never fires */ });\n\n// ✅ Right - use correct event names\nplayer.on('collisionenter', () => { /* ... */ });\nplayer.on('collide', () => { /* ... */ });\nplayer.on('collisionexit', () => { /* ... */ });\n```\n\n## Next Steps\n\n- [Entities](/core/entities) - Understanding entity system\n- [Tags](/core/entities#tags) - Using tags for organization\n- [Events](/core/entities#events) - Entity event system"
      }
    ],
    "animation": [
      {
        "slug": "animation/particles",
        "title": "Particles",
        "description": "Particle systems for visual effects",
        "path": "animation/particles.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/animation/particles.md",
        "content": "# Particles\n\nParticle systems create visual effects like explosions, smoke, fire, sparkles, and trails. Zap provides both individual Particle entities and ParticleEmitter for continuous effects.\n\n## Basic Particle Emitter\n\n```codemirror\nimport { Game, Scene, ParticleEmitter } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst emitter = new ParticleEmitter({\n  x: 200,\n  y: 150,\n  rate: 20,  // Particles per second\n  colors: ['#4fc3f7', '#51cf66', '#f39c12'],\n  sizeRange: { min: 3, max: 8 },\n  lifetimeRange: { min: 0.5, max: 1.5 },\n  velocityRange: {\n    min: { x: -100, y: -100 },\n    max: { x: 100, y: -50 }\n  }\n});\n\nscene.add(emitter);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Particle Emitter Options\n\n```javascript\nconst emitter = new ParticleEmitter({\n  x: 200,\n  y: 150,\n\n  // Emission rate\n  rate: 10,  // Particles per second\n\n  // Velocity range (pixels/second)\n  velocityRange: {\n    min: { x: -50, y: -50 },\n    max: { x: 50, y: 50 }\n  },\n\n  // Size range\n  sizeRange: { min: 2, max: 6 },\n\n  // Lifetime range (seconds)\n  lifetimeRange: { min: 0.5, max: 1.5 },\n\n  // Colors (randomly chosen for each particle)\n  colors: ['#ff0000', '#00ff00', '#0000ff'],\n\n  // Additional particle options\n  particleOptions: {\n    gravity: 100,    // Downward acceleration\n    friction: 0.98   // Velocity dampening\n  }\n});\n```\n\n## Particle Burst\n\nEmit many particles at once:\n\n```codemirror\nimport { Game, Scene, ParticleEmitter, Sprite } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst emitter = new ParticleEmitter({\n  x: 200,\n  y: 150,\n  rate: 0,  // Don't emit continuously\n  colors: ['#e94560', '#f39c12', '#f1c40f'],\n  sizeRange: { min: 4, max: 10 },\n  lifetimeRange: { min: 0.8, max: 1.5 },\n  velocityRange: {\n    min: { x: -150, y: -150 },\n    max: { x: 150, y: -50 }\n  },\n  particleOptions: {\n    gravity: 200\n  }\n});\n\nconst button = new Sprite({\n  x: 200,\n  y: 150,\n  width: 100,\n  height: 100,\n  radius: 50,\n  color: '#e94560',\n  interactive: true\n});\n\nscene.add(emitter);\nscene.add(button);\n\nbutton.on('tap', () => {\n  emitter.burst(50);  // Emit 50 particles at once\n  button.tween({ scaleX: 0.8, scaleY: 0.8 }, { duration: 100 })\n    .then(() => button.tween({ scaleX: 1, scaleY: 1 }, { duration: 100 }));\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Individual Particles\n\nCreate single particles manually:\n\n```javascript\nimport { Particle } from '@mode-7/zap';\n\nconst particle = new Particle({\n  x: 200,\n  y: 150,\n  velocity: { x: 50, y: -100 },\n  color: '#4fc3f7',\n  size: 6,\n  lifetime: 2,      // Seconds before fading out\n  gravity: 100,     // Pixels/second²\n  friction: 0.99    // Velocity multiplier per frame\n});\n\nscene.add(particle);\n```\n\n## Common Effects\n\n### Explosion\n\n```javascript\nconst explosion = new ParticleEmitter({\n  x: targetX,\n  y: targetY,\n  rate: 0,\n  colors: ['#ff6b6b', '#f39c12', '#f1c40f', '#fff'],\n  sizeRange: { min: 6, max: 14 },\n  lifetimeRange: { min: 0.4, max: 1.2 },\n  velocityRange: {\n    min: { x: -200, y: -200 },\n    max: { x: 200, y: 200 }\n  },\n  particleOptions: {\n    gravity: 50,\n    friction: 0.95\n  }\n});\n\nexplosion.burst(80);\n```\n\n### Fire\n\n```javascript\nconst fire = new ParticleEmitter({\n  x: 200,\n  y: 250,\n  rate: 30,\n  colors: ['#ff6b6b', '#f39c12', '#f1c40f'],\n  sizeRange: { min: 4, max: 12 },\n  lifetimeRange: { min: 0.3, max: 0.8 },\n  velocityRange: {\n    min: { x: -20, y: -120 },\n    max: { x: 20, y: -80 }\n  },\n  particleOptions: {\n    gravity: -30,  // Negative = upward\n    friction: 0.98\n  }\n});\n```\n\n### Sparkles\n\n```javascript\nconst sparkles = new ParticleEmitter({\n  x: 200,\n  y: 150,\n  rate: 15,\n  colors: ['#fff', '#4fc3f7', '#51cf66', '#f39c12'],\n  sizeRange: { min: 2, max: 5 },\n  lifetimeRange: { min: 0.5, max: 1.2 },\n  velocityRange: {\n    min: { x: -30, y: -30 },\n    max: { x: 30, y: 30 }\n  },\n  particleOptions: {\n    friction: 0.96\n  }\n});\n```\n\n### Smoke\n\n```javascript\nconst smoke = new ParticleEmitter({\n  x: 200,\n  y: 280,\n  rate: 10,\n  colors: ['#555', '#666', '#777'],\n  sizeRange: { min: 8, max: 20 },\n  lifetimeRange: { min: 1.5, max: 3 },\n  velocityRange: {\n    min: { x: -15, y: -60 },\n    max: { x: 15, y: -40 }\n  },\n  particleOptions: {\n    gravity: -10,\n    friction: 0.99\n  }\n});\n```\n\n### Confetti\n\n```javascript\nconst confetti = new ParticleEmitter({\n  x: 200,\n  y: 50,\n  rate: 0,\n  colors: ['#e94560', '#51cf66', '#4fc3f7', '#f39c12', '#9b59b6'],\n  sizeRange: { min: 6, max: 12 },\n  lifetimeRange: { min: 2, max: 4 },\n  velocityRange: {\n    min: { x: -100, y: -50 },\n    max: { x: 100, y: 100 }\n  },\n  particleOptions: {\n    gravity: 150,\n    friction: 0.99\n  }\n});\n\nconfetti.burst(100);\n```\n\n### Trail Effect\n\n```javascript\nconst trail = new ParticleEmitter({\n  x: player.x,\n  y: player.y,\n  rate: 40,\n  colors: ['#4fc3f7'],\n  sizeRange: { min: 3, max: 6 },\n  lifetimeRange: { min: 0.2, max: 0.5 },\n  velocityRange: {\n    min: { x: -10, y: -10 },\n    max: { x: 10, y: 10 }\n  },\n  particleOptions: {\n    friction: 0.95\n  }\n});\n\n// Update emitter position to follow player\nscene.on('update', () => {\n  trail.x = player.x;\n  trail.y = player.y;\n});\n```\n\n## Physics Properties\n\n### Gravity\n\nAccelerates particles downward (or upward if negative):\n\n```javascript\ngravity: 100    // Falls down\ngravity: -50    // Floats up\ngravity: 0      // No gravity\n```\n\n### Friction\n\nReduces velocity over time (0 = stop immediately, 1 = no friction):\n\n```javascript\nfriction: 1.0   // No slowdown\nfriction: 0.98  // Slight slowdown\nfriction: 0.9   // Medium slowdown\nfriction: 0.5   // Heavy drag\n```\n\n## Dynamic Emitters\n\nAttach emitter to moving entities:\n\n```javascript\n// Rocket exhaust\nconst exhaust = new ParticleEmitter({\n  rate: 50,\n  colors: ['#ff6b6b', '#f39c12'],\n  velocityRange: {\n    min: { x: -20, y: 50 },\n    max: { x: 20, y: 100 }\n  }\n});\n\nrocket.addChild(exhaust);  // Follows rocket\n```\n\n## Stopping and Starting\n\n```javascript\n// Stop emitting\nemitter.rate = 0;\n\n// Resume emitting\nemitter.rate = 20;\n\n// Remove emitter entirely\nemitter.destroy();\n```\n\n## Performance Tips\n\n- Limit particle count (100-200 on screen max)\n- Use shorter lifetimes for performance\n- Lower emission rate for mobile\n- Remove emitters when off-screen\n- Use simple colors (avoid gradients)\n\n## Tips\n\n- **Match colors to theme** - Particle colors should fit your visual style\n- **Combine effects** - Layer multiple emitters for complex effects\n- **Tune velocity ranges** - Wider ranges = more chaotic\n- **Short lifetimes** - 0.5-2 seconds is usually enough\n- **Burst for impacts** - Continuous for ambient effects\n\n## Next Steps\n\n- [Touch Trail](/animation/touch-trail) - Visual touch trails\n- [Tweening](/animation/tweening) - Property animations"
      },
      {
        "slug": "animation/touch-trail",
        "title": "Touch Trail",
        "description": "Visual trail following touch and mouse input",
        "path": "animation/touch-trail.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/animation/touch-trail.md",
        "content": "# Touch Trail\n\nTouchTrail creates a visual trailing effect that follows touch and mouse movement, providing satisfying visual feedback for user interactions.\n\n## Enable Touch Trail\n\nTouch trail is enabled via game configuration:\n\n```javascript\nimport { Game } from '@mode-7/zap';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460',\n  enableTouchTrail: true  // Enable touch trail\n});\n```\n\n## Configure Touch Trail\n\nCustomize the trail appearance:\n\n```javascript\nconst game = new Game({\n  width: 400,\n  height: 300,\n  enableTouchTrail: true\n});\n\n// Access and configure the trail\ngame.touchTrail.setColor('#4fc3f7');\n```\n\n## Touch Trail Options\n\nThe TouchTrail can be configured after creation:\n\n```javascript\n// Change color\ngame.touchTrail.setColor('#e94560');\n\n// Enable/disable\ngame.touchTrail.enable();\ngame.touchTrail.disable();\n\n// Clear trail\ngame.touchTrail.clear();\n```\n\n## Creating Custom Touch Trails\n\nFor more control, create TouchTrail instances manually:\n\n```javascript\nimport { TouchTrail } from '@mode-7/zap';\n\nconst trail = new TouchTrail({\n  color: '#4fc3f7',    // Trail color\n  width: 5,            // Trail width in pixels\n  fadeTime: 800,       // Fade duration in ms\n  maxPoints: 100       // Maximum trail points\n});\n\n// Add points manually\ngame.on('drag', (event) => {\n  trail.addPoint(event.position.x, event.position.y);\n});\n\n// Update in game loop\ngame.on('update', (deltaTime) => {\n  trail.update(deltaTime);\n});\n\n// Render\ngame.on('render', (ctx) => {\n  trail.render(ctx);\n});\n```\n\n## Trail Colors\n\nDifferent colors for different interactions:\n\n```javascript\n// Blue trail for normal interaction\ngame.touchTrail.setColor('#4fc3f7');\n\n// Red trail for danger zones\ngame.touchTrail.setColor('#e94560');\n\n// Green trail for success\ngame.touchTrail.setColor('#51cf66');\n\n// Rainbow effect (change over time)\nconst colors = ['#e94560', '#f39c12', '#51cf66', '#4fc3f7', '#9b59b6'];\nlet colorIndex = 0;\n\nsetInterval(() => {\n  game.touchTrail.setColor(colors[colorIndex]);\n  colorIndex = (colorIndex + 1) % colors.length;\n}, 500);\n```\n\n## Common Patterns\n\n### Temporary Trail\n\nEnable trail only when needed:\n\n```javascript\n// Enable when dragging\ngame.on('dragstart', () => {\n  game.touchTrail.enable();\n});\n\ngame.on('dragend', () => {\n  game.touchTrail.disable();\n  game.touchTrail.clear();\n});\n```\n\n### Entity-Specific Trail\n\nDifferent trails for different entities:\n\n```javascript\nconst playerTrail = new TouchTrail({\n  color: '#4fc3f7',\n  width: 6,\n  fadeTime: 600\n});\n\nplayer.on('drag', (event) => {\n  playerTrail.addPoint(event.position.x, event.position.y);\n});\n```\n\n### Drawing Mode\n\nCreate a drawing application:\n\n```javascript\nlet isDrawing = false;\nconst drawTrail = new TouchTrail({\n  color: '#fff',\n  width: 8,\n  fadeTime: 10000,  // Long fade time = persistent\n  maxPoints: 1000\n});\n\ngame.on('dragstart', () => {\n  isDrawing = true;\n});\n\ngame.on('drag', (event) => {\n  if (isDrawing) {\n    drawTrail.addPoint(event.position.x, event.position.y);\n  }\n});\n\ngame.on('dragend', () => {\n  isDrawing = false;\n});\n```\n\n## Performance\n\n- Default maxPoints (50) works for most cases\n- Increase for longer trails (100-200)\n- Decrease for better performance (20-30)\n- Shorter fadeTime = better performance\n\n## Tips\n\n- **Use for feedback** - Helps users see their touch is registered\n- **Match your theme** - Choose trail colors that fit your design\n- **Don't overuse** - Can be distracting if always on\n- **Clear when appropriate** - Clear trail between screens/modes\n\n## Next Steps\n\n- [Particles](/animation/particles) - Particle effects\n- [Tweening](/animation/tweening) - Property animations"
      },
      {
        "slug": "animation/tweening",
        "title": "Tweening",
        "description": "Smooth property animations with easing functions",
        "path": "animation/tweening.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/animation/tweening.md",
        "content": "# Tweening\n\nTweening animates entity properties smoothly over time using easing functions. Perfect for movement, scaling, rotation, fading, and complex animation sequences.\n\n## Basic Tween\n\nAnimate any numeric property:\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst sprite = new Sprite({\n  x: 50,\n  y: 150,\n  width: 60,\n  height: 60,\n  radius: 30,\n  color: '#667eea'\n});\n\nscene.add(sprite);\n\n// Animate to new position\nsprite.tween(\n  { x: 350 },\n  { duration: 2000, easing: 'easeInOutCubic' }\n);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Multiple Properties\n\nAnimate several properties simultaneously:\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst sprite = new Sprite({\n  x: 200,\n  y: 150,\n  width: 60,\n  height: 60,\n  radius: 30,\n  color: '#e94560'\n});\n\nscene.add(sprite);\n\n// Rotate and scale together\nsprite.tween(\n  {\n    rotation: Math.PI * 2,\n    scaleX: 2,\n    scaleY: 2\n  },\n  {\n    duration: 1500,\n    easing: 'easeInOutBack'\n  }\n);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Chaining Tweens\n\nChain animations with `.then()` for sequences:\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst sprite = new Sprite({\n  x: 200,\n  y: 100,\n  width: 50,\n  height: 50,\n  radius: 25,\n  color: '#51cf66'\n});\n\nscene.add(sprite);\n\n// Bouncing animation loop\nfunction bounce() {\n  sprite.tween(\n    { y: 200 },\n    { duration: 600, easing: 'easeOutBounce' }\n  ).then(() => {\n    sprite.tween(\n      { y: 100 },\n      { duration: 600, easing: 'easeInQuad' }\n    ).then(bounce);\n  });\n}\n\nbounce();\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Tween Options\n\nAll available options:\n\n```javascript\nentity.tween(\n  { x: 100, y: 200 },  // Target values\n  {\n    duration: 1000,           // Duration in milliseconds (required)\n    easing: 'easeOutCubic',   // Easing function (default: 'linear')\n    delay: 500,               // Delay before starting in ms (default: 0)\n    onUpdate: (progress) => {}, // Called each frame with 0-1 progress\n    onComplete: () => {}      // Called when animation finishes\n  }\n);\n```\n\n## Progress Tracking\n\nMonitor animation progress:\n\n```codemirror\nimport { Game, Scene, Sprite, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst sprite = new Sprite({\n  x: 50,\n  y: 120,\n  width: 60,\n  height: 60,\n  radius: 30,\n  color: '#f39c12'\n});\n\nconst progressText = new Text({\n  text: '0%',\n  x: 200,\n  y: 220,\n  fontSize: 18,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nscene.add(sprite);\nscene.add(progressText);\n\nsprite.tween(\n  { x: 350 },\n  {\n    duration: 3000,\n    easing: 'linear',\n    onUpdate: (progress) => {\n      progressText.text = Math.round(progress * 100) + '%';\n    },\n    onComplete: () => {\n      progressText.text = 'Done!';\n      progressText.color = '#51cf66';\n    }\n  }\n);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Easing Functions\n\nChoose from 37 easing functions for different animation feels:\n\n**Linear**: `linear` - Constant speed\n\n**Quad**: `easeInQuad`, `easeOutQuad`, `easeInOutQuad`\n\n**Cubic**: `easeInCubic`, `easeOutCubic`, `easeInOutCubic`\n\n**Quart**: `easeInQuart`, `easeOutQuart`, `easeInOutQuart`\n\n**Quint**: `easeInQuint`, `easeOutQuint`, `easeInOutQuint`\n\n**Sine**: `easeInSine`, `easeOutSine`, `easeInOutSine`\n\n**Expo**: `easeInExpo`, `easeOutExpo`, `easeInOutExpo`\n\n**Circ**: `easeInCirc`, `easeOutCirc`, `easeInOutCirc`\n\n**Back**: `easeInBack`, `easeOutBack`, `easeInOutBack` - Overshoots then settles\n\n**Elastic**: `easeInElastic`, `easeOutElastic`, `easeInOutElastic` - Spring-like bounce\n\n**Bounce**: `easeInBounce`, `easeOutBounce`, `easeInOutBounce` - Bouncing effect\n\n### Easing Guide\n\n- **In**: Starts slow, accelerates\n- **Out**: Starts fast, decelerates (best for UI)\n- **InOut**: Slow start and end, fast middle\n\n## Stopping Tweens\n\nControl tweens programmatically:\n\n```javascript\n// Store reference\nconst tween = sprite.tween({ x: 500 }, { duration: 2000 });\n\n// Stop the tween at any time\ntween.stop();\n\n// Check if tween is active\nif (tween.isActive()) {\n  console.log('Still animating');\n}\n\n// Check if completed\nif (tween.isCompleted()) {\n  console.log('Animation finished');\n}\n```\n\n## Common Patterns\n\n### Fade In/Out\n\n```javascript\n// Fade in\nsprite.alpha = 0;\nsprite.tween({ alpha: 1 }, { duration: 500, easing: 'easeOutQuad' });\n\n// Fade out\nsprite.tween({ alpha: 0 }, { duration: 500, easing: 'easeInQuad' });\n```\n\n### Pulse Effect\n\n```javascript\nfunction pulse() {\n  sprite.tween(\n    { scaleX: 1.2, scaleY: 1.2 },\n    { duration: 400, easing: 'easeOutQuad' }\n  ).then(() => {\n    sprite.tween(\n      { scaleX: 1, scaleY: 1 },\n      { duration: 400, easing: 'easeInQuad' }\n    ).then(pulse);\n  });\n}\n\npulse();\n```\n\n### Shake Effect\n\n```javascript\nconst originalX = sprite.x;\n\nfunction shake(intensity = 10, duration = 50) {\n  sprite.tween(\n    { x: originalX + intensity },\n    { duration: duration, easing: 'linear' }\n  ).then(() => {\n    sprite.tween(\n      { x: originalX - intensity },\n      { duration: duration, easing: 'linear' }\n    ).then(() => {\n      sprite.tween(\n        { x: originalX },\n        { duration: duration, easing: 'linear' }\n      );\n    });\n  });\n}\n\nshake();\n```\n\n### Sequential Animation\n\n```javascript\n// Move right, then down, then left, then up\nsprite.tween({ x: 300 }, { duration: 500 })\n  .then(() => sprite.tween({ y: 200 }, { duration: 500 }))\n  .then(() => sprite.tween({ x: 100 }, { duration: 500 }))\n  .then(() => sprite.tween({ y: 100 }, { duration: 500 }));\n```\n\n### Delayed Start\n\n```javascript\n// Wait 1 second before starting\nsprite.tween(\n  { x: 300 },\n  {\n    duration: 1000,\n    delay: 1000,\n    easing: 'easeOutCubic'\n  }\n);\n```\n\n### Button Press\n\n```javascript\nbutton.on('tap', () => {\n  // Quick press down and release\n  button.tween(\n    { scaleX: 0.95, scaleY: 0.95 },\n    { duration: 100, easing: 'easeOutQuad' }\n  ).then(() => {\n    button.tween(\n      { scaleX: 1, scaleY: 1 },\n      { duration: 100, easing: 'easeOutBack' }\n    );\n  });\n});\n```\n\n## Performance Tips\n\n- **Minimize simultaneous tweens**: More than 100 active tweens may impact performance\n- **Reuse tween patterns**: Create functions for common animations\n- **Stop unused tweens**: Always stop tweens when entities are destroyed\n- **Choose appropriate durations**: 200-500ms feels snappy, 1000-2000ms feels smooth\n\n## Common Mistakes\n\n### Tweening non-numeric properties\n\n```javascript\n// ❌ Wrong - color is a string\nsprite.tween({ color: '#ff0000' }, { duration: 1000 });\n\n// ✅ Right - tween numeric properties\nsprite.tween({ alpha: 0 }, { duration: 1000 });\n```\n\n### Forgetting to return in chains\n\n```javascript\n// ❌ Wrong - breaks chain\nsprite.tween({ x: 100 }, { duration: 500 }).then(() => {\n  sprite.tween({ y: 100 }, { duration: 500 });\n});\n\n// ✅ Right - returns tween for proper chaining\nsprite.tween({ x: 100 }, { duration: 500 }).then(() => {\n  return sprite.tween({ y: 100 }, { duration: 500 });\n});\n```\n\n## Next Steps\n\n- [Particles](/animation/particles) - Particle effects\n- [Touch Trail](/animation/touch-trail) - Visual touch trails\n- [Easing Functions](/utilities/easing) - Complete easing reference"
      }
    ],
    "audio": [
      {
        "slug": "audio/music",
        "title": "Background Music",
        "description": "Playing and controlling background music",
        "path": "audio/music.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/audio/music.md",
        "content": "# Background Music\n\nAudioManager provides simple background music playback with loop control and volume management.\n\n## Playing Music\n\nPlay background music that loops automatically:\n\n```javascript\nimport { audioManager } from '@mode-7/zap';\n\n// Play looping background music\naudioManager.playMusic('/music/theme.mp3', {\n  loop: true,\n  volume: 0.7\n});\n```\n\n## Music Controls\n\nControl music playback:\n\n```javascript\n// Pause music (keeps position)\naudioManager.pauseMusic();\n\n// Resume from pause\naudioManager.resumeMusic();\n\n// Stop music (resets to beginning)\naudioManager.stopMusic();\n```\n\n## Music Player Demo\n\n```codemirror\nimport { Game, Scene, Sprite, Text, audioManager } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nlet musicPlaying = false;\nlet musicPaused = false;\n\n// Title\nconst title = new Text({\n  text: 'Background Music Demo',\n  x: 200,\n  y: 40,\n  fontSize: 18,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nconst subtitle = new Text({\n  text: 'Control background music playback',\n  x: 200,\n  y: 70,\n  fontSize: 12,\n  color: '#888',\n  align: 'center'\n});\n\n// Status\nconst status = new Text({\n  text: 'Status: Stopped',\n  x: 200,\n  y: 110,\n  fontSize: 14,\n  color: '#888',\n  align: 'center'\n});\n\n// Play button\nconst playBtn = new Sprite({\n  x: 110,\n  y: 160,\n  width: 85,\n  height: 45,\n  color: '#2ecc71',\n  radius: 8,\n  interactive: true\n});\n\nconst playLabel = new Text({\n  text: 'Play',\n  fontSize: 15,\n  color: '#fff',\n  align: 'center',\n  baseline: 'middle'\n});\n\nplayBtn.addChild(playLabel);\n\nplayBtn.on('tap', () => {\n  if (!musicPlaying) {\n    audioManager.playMusic('../assets/music.mp3', {\n      loop: true,\n      volume: 0.6\n    });\n    musicPlaying = true;\n    musicPaused = false;\n    status.text = 'Status: Playing';\n    status.color = '#2ecc71';\n    playBtn.alpha = 0.5;\n  }\n});\n\n// Pause button\nconst pauseBtn = new Sprite({\n  x: 200,\n  y: 160,\n  width: 85,\n  height: 45,\n  color: '#f4a261',\n  radius: 8,\n  interactive: true\n});\n\nconst pauseLabel = new Text({\n  text: 'Pause',\n  fontSize: 15,\n  color: '#fff',\n  align: 'center',\n  baseline: 'middle'\n});\n\npauseBtn.addChild(pauseLabel);\n\npauseBtn.on('tap', () => {\n  if (musicPlaying && !musicPaused) {\n    audioManager.pauseMusic();\n    musicPaused = true;\n    status.text = 'Status: Paused';\n    status.color = '#f4a261';\n    pauseLabel.text = 'Resume';\n  } else if (musicPlaying && musicPaused) {\n    audioManager.resumeMusic();\n    musicPaused = false;\n    status.text = 'Status: Playing';\n    status.color = '#2ecc71';\n    pauseLabel.text = 'Pause';\n  }\n});\n\n// Stop button\nconst stopBtn = new Sprite({\n  x: 290,\n  y: 160,\n  width: 85,\n  height: 45,\n  color: '#e94560',\n  radius: 8,\n  interactive: true\n});\n\nconst stopLabel = new Text({\n  text: 'Stop',\n  fontSize: 15,\n  color: '#fff',\n  align: 'center',\n  baseline: 'middle'\n});\n\nstopBtn.addChild(stopLabel);\n\nstopBtn.on('tap', () => {\n  if (musicPlaying) {\n    audioManager.stopMusic();\n    musicPlaying = false;\n    musicPaused = false;\n    status.text = 'Status: Stopped';\n    status.color = '#888';\n    pauseLabel.text = 'Pause';\n    playBtn.alpha = 1;\n  }\n});\n\nconst info = new Text({\n  text: 'Play, pause, and stop background music',\n  x: 200,\n  y: 230,\n  fontSize: 11,\n  color: '#666',\n  align: 'center'\n});\n\nscene.add(title);\nscene.add(subtitle);\nscene.add(status);\nscene.add(playBtn);\nscene.add(pauseBtn);\nscene.add(stopBtn);\nscene.add(info);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Music Options\n\nCustomize music playback:\n\n```javascript\naudioManager.playMusic('/music/battle.mp3', {\n  loop: true,      // Loop the music (default: true)\n  volume: 0.6,     // Music volume 0-1 (default: 1)\n  rate: 1.0        // Playback speed (default: 1)\n});\n```\n\n## Music Volume\n\nControl music volume independently from sound effects:\n\n```javascript\n// Set music volume to 50%\naudioManager.setMusicVolume(0.5);\n\n// Music volume is multiplied by master volume\naudioManager.setMasterVolume(0.8); // Both music and SFX at 80%\n```\n\n## Scene-Based Music\n\nPlay different music for each scene:\n\n```javascript\nimport { Scene, audioManager } from '@mode-7/zap';\n\nclass MenuScene extends Scene {\n  onEnter() {\n    audioManager.playMusic('/music/menu.mp3', {\n      loop: true,\n      volume: 0.6\n    });\n  }\n\n  onExit() {\n    audioManager.stopMusic();\n  }\n}\n\nclass GameScene extends Scene {\n  onEnter() {\n    audioManager.playMusic('/music/gameplay.mp3', {\n      loop: true,\n      volume: 0.7\n    });\n  }\n\n  onExit() {\n    audioManager.stopMusic();\n  }\n}\n```\n\n## Crossfading Music\n\nSmoothly transition between tracks:\n\n```javascript\n// Fade out current music\nconst fadeOut = () => {\n  return new Promise(resolve => {\n    const interval = setInterval(() => {\n      const currentVolume = audioManager.musicVolume;\n      if (currentVolume > 0.1) {\n        audioManager.setMusicVolume(currentVolume - 0.1);\n      } else {\n        clearInterval(interval);\n        audioManager.stopMusic();\n        resolve();\n      }\n    }, 100);\n  });\n};\n\n// Crossfade to new track\nawait fadeOut();\naudioManager.setMusicVolume(0);\naudioManager.playMusic('/music/new-track.mp3');\n\n// Fade in new track\nconst fadeIn = setInterval(() => {\n  const currentVolume = audioManager.musicVolume;\n  if (currentVolume < 0.7) {\n    audioManager.setMusicVolume(currentVolume + 0.1);\n  } else {\n    clearInterval(fadeIn);\n  }\n}, 100);\n```\n\n## Dynamic Music\n\nChange music based on game state:\n\n```javascript\nlet enemyCount = 0;\n\nfunction updateMusic() {\n  if (enemyCount > 10) {\n    // Intense music\n    audioManager.playMusic('/music/intense.mp3', {\n      loop: true,\n      volume: 0.8\n    });\n  } else if (enemyCount > 0) {\n    // Action music\n    audioManager.playMusic('/music/action.mp3', {\n      loop: true,\n      volume: 0.7\n    });\n  } else {\n    // Calm music\n    audioManager.playMusic('/music/calm.mp3', {\n      loop: true,\n      volume: 0.5\n    });\n  }\n}\n```\n\n## Common Patterns\n\n### Boss Battle Music\n\n```javascript\nboss.on('spawn', () => {\n  // Stop normal music\n  audioManager.stopMusic();\n\n  // Play boss music\n  audioManager.playMusic('/music/boss.mp3', {\n    loop: true,\n    volume: 0.8\n  });\n});\n\nboss.on('defeat', () => {\n  audioManager.stopMusic();\n  audioManager.playMusic('/music/victory.mp3', {\n    loop: false,\n    volume: 0.7\n  });\n});\n```\n\n### Menu Music\n\n```javascript\nconst menuScene = new Scene();\n\nmenuScene.onEnter = () => {\n  audioManager.playMusic('/music/menu.mp3', {\n    loop: true,\n    volume: 0.5\n  });\n};\n\nplayButton.on('tap', () => {\n  audioManager.pauseMusic(); // Keep music ready\n  game.setScene(gameScene);\n});\n```\n\n## Next Steps\n\n- [Sound Effects](/audio/sound-effects) - Play sound effects\n- [Volume & Mute](/audio/volume) - Global audio controls"
      },
      {
        "slug": "audio/sound-effects",
        "title": "Sound Effects",
        "description": "Playing sound effects and audio feedback",
        "path": "audio/sound-effects.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/audio/sound-effects.md",
        "content": "# Sound Effects\n\nThe AudioManager provides a simple system for loading and playing sound effects with volume control and playback options.\n\n## Basic Sound Effects\n\nLoad and play sound effects using the global `audioManager`:\n\n```javascript\nimport { audioManager } from '@mode-7/zap';\n\n// Load a sound effect\naudioManager.loadSound('jump', '/sounds/jump.mp3');\n\n// Play the sound\naudioManager.playSound('jump');\n```\n\n## Loading Multiple Sounds\n\nLoad all your sound effects at once:\n\n```javascript\nimport { audioManager } from '@mode-7/zap';\n\naudioManager.loadSounds({\n  jump: '/sounds/jump.mp3',\n  coin: '/sounds/coin.mp3',\n  explosion: '/sounds/explosion.mp3',\n  laser: '/sounds/laser.mp3'\n});\n```\n\n## Sound Effects Demo\n\n```codemirror\nimport { Game, Scene, Sprite, Text, audioManager } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\n// Load the sound effect\naudioManager.loadSound('sfx', '../assets/sfx.mp3');\n\n// Title\nconst title = new Text({\n  text: 'Sound Effects Demo',\n  x: 200,\n  y: 30,\n  fontSize: 18,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nconst info = new Text({\n  text: 'Tap buttons to play sound at different speeds',\n  x: 200,\n  y: 60,\n  fontSize: 12,\n  color: '#888',\n  align: 'center'\n});\n\n// Create sound button with playback rate\nconst createButton = (x, y, label, color, rate) => {\n  const btn = new Sprite({\n    x, y,\n    width: 80,\n    height: 40,\n    color,\n    radius: 8,\n    interactive: true\n  });\n\n  const text = new Text({\n    text: label,\n    fontSize: 13,\n    color: '#fff',\n    align: 'center',\n    baseline: 'middle'\n  });\n\n  btn.addChild(text);\n\n  btn.on('tap', () => {\n    audioManager.playSound('sfx', { rate });\n    btn.tween(\n      { scaleX: 1.1, scaleY: 1.1 },\n      { duration: 100 }\n    ).then(() => {\n      btn.tween(\n        { scaleX: 1, scaleY: 1 },\n        { duration: 100 }\n      );\n    });\n  });\n\n  return btn;\n};\n\n// Different playback rates\nconst normalBtn = createButton(100, 120, 'Normal', '#2a9d8f', 1.0);\nconst slowBtn = createButton(200, 120, 'Slow', '#4fc3f7', 0.7);\nconst fastBtn = createButton(300, 120, 'Fast', '#f4a261', 1.5);\n\nconst lowerBtn = createButton(100, 180, 'Lower', '#e76f51', 0.8);\nconst higherBtn = createButton(200, 180, 'Higher', '#9d4edd', 1.2);\nconst chipmunkBtn = createButton(300, 180, 'Chipmunk', '#e94560', 2.0);\n\n// Volume control\nconst volumeLabel = new Text({\n  text: 'Volume: 100%',\n  x: 200,\n  y: 230,\n  fontSize: 12,\n  color: '#888',\n  align: 'center'\n});\n\nlet currentVolume = 1.0;\n\nconst quietBtn = createButton(120, 255, 'Quiet', '#16213e', 1.0);\nquietBtn.on('tap', () => {\n  currentVolume = 0.3;\n  audioManager.playSound('sfx', { volume: currentVolume });\n  volumeLabel.text = 'Volume: 30%';\n  quietBtn.tween({ scaleX: 1.1, scaleY: 1.1 }, { duration: 100 }).then(() => {\n    quietBtn.tween({ scaleX: 1, scaleY: 1 }, { duration: 100 });\n  });\n});\n\nconst loudBtn = createButton(280, 255, 'Loud', '#16213e', 1.0);\nloudBtn.on('tap', () => {\n  currentVolume = 1.0;\n  audioManager.playSound('sfx', { volume: currentVolume });\n  volumeLabel.text = 'Volume: 100%';\n  loudBtn.tween({ scaleX: 1.1, scaleY: 1.1 }, { duration: 100 }).then(() => {\n    loudBtn.tween({ scaleX: 1, scaleY: 1 }, { duration: 100 });\n  });\n});\n\nscene.add(title);\nscene.add(info);\nscene.add(normalBtn);\nscene.add(slowBtn);\nscene.add(fastBtn);\nscene.add(lowerBtn);\nscene.add(higherBtn);\nscene.add(chipmunkBtn);\nscene.add(volumeLabel);\nscene.add(quietBtn);\nscene.add(loudBtn);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Playback Options\n\nControl how sounds are played:\n\n```javascript\n// Play with custom volume (0-1)\naudioManager.playSound('jump', { volume: 0.5 });\n\n// Play at different playback rate (speed)\naudioManager.playSound('laser', { rate: 1.5 }); // 1.5x speed\n\n// Loop a sound\naudioManager.playSound('engine', { loop: true });\n\n// Combine options\naudioManager.playSound('coin', {\n  volume: 0.8,\n  rate: 1.2,\n  loop: false\n});\n```\n\n## Random Sounds\n\nPlay a random sound from a group for variety:\n\n```javascript\n// Load impact variations\naudioManager.loadSounds({\n  'hit1': '/sounds/hit1.mp3',\n  'hit2': '/sounds/hit2.mp3',\n  'hit3': '/sounds/hit3.mp3'\n});\n\n// Play random hit sound on collision\nentity.on('collision', () => {\n  audioManager.playRandomSound(['hit1', 'hit2', 'hit3']);\n});\n```\n\n## Volume Control\n\nSet global sound effects volume:\n\n```javascript\n// Set SFX volume (0-1)\naudioManager.setSFXVolume(0.7);\n\n// Affects all playSound() calls\naudioManager.playSound('jump'); // Plays at 70% volume\n```\n\n## Common Patterns\n\n### UI Feedback\n\n```javascript\nbutton.on('tap', () => {\n  audioManager.playSound('click', { volume: 0.3 });\n  // ... button action\n});\n```\n\n### Collision Sounds\n\n```javascript\nplayer.on('collision', (other) => {\n  if (other.hasTag('enemy')) {\n    audioManager.playSound('hurt');\n  } else if (other.hasTag('coin')) {\n    audioManager.playSound('coin', { rate: 1 + Math.random() * 0.2 });\n  }\n});\n```\n\n### Combo System\n\n```javascript\nlet comboCount = 0;\n\nenemy.on('destroy', () => {\n  comboCount++;\n  const pitch = 1 + (comboCount * 0.1); // Higher pitch for each combo\n  audioManager.playSound('hit', { rate: pitch });\n});\n```\n\n## Next Steps\n\n- [Background Music](/audio/music) - Play and control background music\n- [Volume & Mute](/audio/volume) - Global audio controls"
      },
      {
        "slug": "audio/volume",
        "title": "Volume & Mute",
        "description": "Global audio controls and volume management",
        "path": "audio/volume.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/audio/volume.md",
        "content": "# Volume & Mute\n\nAudioManager provides comprehensive volume controls for master, music, and sound effects independently, plus mute functionality.\n\n## Volume Hierarchy\n\nAudio volume follows a hierarchy:\n\n```\nFinal Volume = Master Volume × (Music/SFX Volume) × Individual Sound Volume\n```\n\n```javascript\nimport { audioManager } from '@mode-7/zap';\n\n// Set master volume (affects everything)\naudioManager.setMasterVolume(0.8); // 80%\n\n// Set music volume (affects only music)\naudioManager.setMusicVolume(0.6); // 60%\n\n// Set SFX volume (affects only sound effects)\naudioManager.setSFXVolume(1.0); // 100%\n\n// Individual sound volume\naudioManager.playSound('jump', { volume: 0.5 }); // 50%\n\n// Final volume: 0.8 × 1.0 × 0.5 = 0.4 (40%)\n```\n\n## Volume Control Demo\n\n```codemirror\nimport { Game, Scene, Sprite, Text, audioManager } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\n// Load audio\naudioManager.loadSound('sfx', '../assets/sfx.mp3');\n\n// Title\nconst title = new Text({\n  text: 'Volume Controls',\n  x: 200,\n  y: 20,\n  fontSize: 18,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\n// Create a slider\nconst createSlider = (y, label, value, onChange) => {\n  const labelText = new Text({\n    text: label,\n    x: 200,\n    y: y - 15,\n    fontSize: 12,\n    color: '#888',\n    align: 'center'\n  });\n\n  const valueText = new Text({\n    text: `${Math.round(value * 100)}%`,\n    x: 320,\n    y: y,\n    fontSize: 11,\n    color: '#4fc3f7',\n    align: 'left',\n    baseline: 'middle'\n  });\n\n  const sliderBg = new Sprite({\n    x: 200,\n    y: y,\n    width: 200,\n    height: 5,\n    color: '#16213e',\n    radius: 2.5\n  });\n\n  const sliderFill = new Sprite({\n    x: 100,\n    y: y,\n    width: value * 200,\n    height: 5,\n    color: '#4fc3f7',\n    radius: 2.5,\n    anchorX: 0,\n    anchorY: 0.5\n  });\n\n  const sliderHandle = new Sprite({\n    x: 100 + value * 200,\n    y: y,\n    width: 16,\n    height: 16,\n    color: '#fff',\n    radius: 8,\n    interactive: true\n  });\n\n  sliderHandle.on('drag', (event) => {\n    const minX = 100;\n    const maxX = 300;\n    sliderHandle.x = Math.max(minX, Math.min(maxX, sliderHandle.x + event.delta.x));\n\n    const newValue = (sliderHandle.x - minX) / (maxX - minX);\n    sliderFill.width = newValue * 200;\n    valueText.text = `${Math.round(newValue * 100)}%`;\n\n    onChange(newValue);\n  });\n\n  scene.add(labelText);\n  scene.add(sliderBg);\n  scene.add(sliderFill);\n  scene.add(sliderHandle);\n  scene.add(valueText);\n\n  return { labelText, sliderBg, sliderFill, sliderHandle, valueText };\n};\n\n// Master volume slider\nconst masterSlider = createSlider(70, 'Master Volume', 1.0, (value) => {\n  audioManager.setMasterVolume(value);\n});\n\n// Music volume slider\nconst musicSlider = createSlider(110, 'Music Volume', 0.6, (value) => {\n  audioManager.setMusicVolume(value);\n});\n\n// SFX volume slider\nconst sfxSlider = createSlider(150, 'SFX Volume', 1.0, (value) => {\n  audioManager.setSFXVolume(value);\n});\n\n// Test buttons\nconst testSfxBtn = new Sprite({\n  x: 100,\n  y: 195,\n  width: 85,\n  height: 35,\n  color: '#2ecc71',\n  radius: 8,\n  interactive: true\n});\n\nconst testSfxLabel = new Text({\n  text: 'Test SFX',\n  fontSize: 12,\n  color: '#fff',\n  align: 'center',\n  baseline: 'middle'\n});\n\ntestSfxBtn.addChild(testSfxLabel);\n\ntestSfxBtn.on('tap', () => {\n  audioManager.playSound('sfx');\n  testSfxBtn.tween({ scaleX: 1.1, scaleY: 1.1 }, { duration: 100 }).then(() => {\n    testSfxBtn.tween({ scaleX: 1, scaleY: 1 }, { duration: 100 });\n  });\n});\n\nlet musicPlaying = false;\n\nconst testMusicBtn = new Sprite({\n  x: 200,\n  y: 195,\n  width: 85,\n  height: 35,\n  color: '#4fc3f7',\n  radius: 8,\n  interactive: true\n});\n\nconst testMusicLabel = new Text({\n  text: 'Play Music',\n  fontSize: 12,\n  color: '#fff',\n  align: 'center',\n  baseline: 'middle'\n});\n\ntestMusicBtn.addChild(testMusicLabel);\n\ntestMusicBtn.on('tap', () => {\n  if (!musicPlaying) {\n    audioManager.playMusic('../assets/music.mp3', { loop: true });\n    musicPlaying = true;\n    testMusicLabel.text = 'Stop Music';\n    testMusicBtn.color = '#e94560';\n  } else {\n    audioManager.stopMusic();\n    musicPlaying = false;\n    testMusicLabel.text = 'Play Music';\n    testMusicBtn.color = '#4fc3f7';\n  }\n});\n\n// Mute button\nconst muteBtn = new Sprite({\n  x: 300,\n  y: 195,\n  width: 85,\n  height: 35,\n  color: '#16213e',\n  radius: 8,\n  interactive: true\n});\n\nconst muteLabel = new Text({\n  text: 'Mute: OFF',\n  fontSize: 12,\n  color: '#fff',\n  align: 'center',\n  baseline: 'middle'\n});\n\nmuteBtn.addChild(muteLabel);\n\nmuteBtn.on('tap', () => {\n  audioManager.toggleMute();\n  const muted = audioManager.isMuted();\n  muteLabel.text = muted ? 'Mute: ON' : 'Mute: OFF';\n  muteBtn.color = muted ? '#e94560' : '#16213e';\n});\n\nconst info = new Text({\n  text: 'Adjust sliders and test with sound and music',\n  x: 200,\n  y: 250,\n  fontSize: 11,\n  color: '#666',\n  align: 'center'\n});\n\nscene.add(title);\nscene.add(testSfxBtn);\nscene.add(testMusicBtn);\nscene.add(muteBtn);\nscene.add(info);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Master Volume\n\nControls all audio (music and SFX):\n\n```javascript\n// Set master volume to 80%\naudioManager.setMasterVolume(0.8);\n\n// All sounds play at 80% of their set volume\naudioManager.playSound('jump'); // 80% volume\naudioManager.playMusic('/music/theme.mp3'); // 80% volume\n```\n\n## Music Volume\n\nControls only background music:\n\n```javascript\n// Set music to 60%\naudioManager.setMusicVolume(0.6);\n\n// Music plays at 60%, SFX unaffected\naudioManager.playMusic('/music/theme.mp3'); // 60% volume\naudioManager.playSound('jump'); // 100% volume (if master is 1.0)\n```\n\n## SFX Volume\n\nControls only sound effects:\n\n```javascript\n// Set SFX to 70%\naudioManager.setSFXVolume(0.7);\n\n// SFX plays at 70%, music unaffected\naudioManager.playSound('jump'); // 70% volume\naudioManager.playMusic('/music/theme.mp3'); // 100% volume (if master is 1.0)\n```\n\n## Mute Controls\n\nInstantly silence all audio:\n\n```javascript\n// Mute all audio\naudioManager.mute();\n\n// Unmute all audio\naudioManager.unmute();\n\n// Toggle mute state\nconst isMuted = audioManager.toggleMute();\n\n// Check if muted\nif (audioManager.isMuted()) {\n  console.log('Audio is muted');\n}\n```\n\n## Settings Menu\n\nCreate a settings menu with volume controls:\n\n```javascript\nimport { Scene, Sprite, Text, audioManager } from '@mode-7/zap';\n\nclass SettingsScene extends Scene {\n  constructor() {\n    super();\n\n    // Master volume slider\n    this.createSlider(100, 'Master', (value) => {\n      audioManager.setMasterVolume(value);\n      localStorage.setItem('masterVolume', value);\n    });\n\n    // Music volume slider\n    this.createSlider(150, 'Music', (value) => {\n      audioManager.setMusicVolume(value);\n      localStorage.setItem('musicVolume', value);\n    });\n\n    // SFX volume slider\n    this.createSlider(200, 'SFX', (value) => {\n      audioManager.setSFXVolume(value);\n      localStorage.setItem('sfxVolume', value);\n    });\n  }\n\n  createSlider(y, label, onChange) {\n    // Implementation from demo above\n  }\n}\n```\n\n## Save/Load Volume Settings\n\nPersist volume settings:\n\n```javascript\n// Save settings\nfunction saveAudioSettings() {\n  localStorage.setItem('masterVolume', audioManager.getMasterVolume());\n  localStorage.setItem('musicVolume', audioManager.getMusicVolume());\n  localStorage.setItem('sfxVolume', audioManager.getSFXVolume());\n  localStorage.setItem('muted', audioManager.isMuted());\n}\n\n// Load settings on startup\nfunction loadAudioSettings() {\n  const master = parseFloat(localStorage.getItem('masterVolume') ?? '1');\n  const music = parseFloat(localStorage.getItem('musicVolume') ?? '1');\n  const sfx = parseFloat(localStorage.getItem('sfxVolume') ?? '1');\n  const muted = localStorage.getItem('muted') === 'true';\n\n  audioManager.setMasterVolume(master);\n  audioManager.setMusicVolume(music);\n  audioManager.setSFXVolume(sfx);\n\n  if (muted) {\n    audioManager.mute();\n  }\n}\n\n// Load on game start\nloadAudioSettings();\n```\n\n## Accessibility\n\nAdd visual feedback for muted state:\n\n```javascript\n// Update UI when mute state changes\nfunction updateMuteUI() {\n  const muteIcon = document.getElementById('mute-icon');\n  if (audioManager.isMuted()) {\n    muteIcon.textContent = '🔇';\n    muteIcon.classList.add('muted');\n  } else {\n    muteIcon.textContent = '🔊';\n    muteIcon.classList.remove('muted');\n  }\n}\n\n// Mute button\nmuteButton.on('tap', () => {\n  audioManager.toggleMute();\n  updateMuteUI();\n});\n```\n\n## Volume Curves\n\nCreate smooth volume transitions:\n\n```javascript\n// Linear volume change\nfunction fadeVolume(target, duration) {\n  const start = audioManager.getMasterVolume();\n  const diff = target - start;\n  const startTime = Date.now();\n\n  const interval = setInterval(() => {\n    const elapsed = Date.now() - startTime;\n    const progress = Math.min(elapsed / duration, 1);\n\n    audioManager.setMasterVolume(start + diff * progress);\n\n    if (progress >= 1) {\n      clearInterval(interval);\n    }\n  }, 16); // ~60 FPS\n}\n\n// Usage\nfadeVolume(0, 1000); // Fade out over 1 second\n```\n\n## Common Patterns\n\n### Pause Menu Volume\n\n```javascript\ngame.on('pause', () => {\n  audioManager.setMasterVolume(0.3); // Duck volume\n  audioManager.pauseMusic();\n});\n\ngame.on('resume', () => {\n  audioManager.setMasterVolume(1.0); // Restore volume\n  audioManager.resumeMusic();\n});\n```\n\n### Options Menu\n\n```javascript\nconst optionsScene = new Scene();\n\n// Volume sliders with localStorage persistence\n['master', 'music', 'sfx'].forEach((type, i) => {\n  const slider = createSlider(100 + i * 50, type, (value) => {\n    switch(type) {\n      case 'master': audioManager.setMasterVolume(value); break;\n      case 'music': audioManager.setMusicVolume(value); break;\n      case 'sfx': audioManager.setSFXVolume(value); break;\n    }\n    localStorage.setItem(`${type}Volume`, value);\n  });\n});\n```\n\n### Dynamic Volume\n\n```javascript\n// Lower music during dialogue\ndialogueSystem.on('start', () => {\n  audioManager.setMusicVolume(0.3);\n});\n\ndialogueSystem.on('end', () => {\n  audioManager.setMusicVolume(0.7);\n});\n```\n\n## Next Steps\n\n- [Sound Effects](/audio/sound-effects) - Play sound effects\n- [Background Music](/audio/music) - Control background music"
      }
    ],
    "core": [
      {
        "slug": "core/architecture",
        "title": "Architecture",
        "description": "Understanding how Zap is structured",
        "path": "core/architecture.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/core/architecture.md",
        "content": "# Architecture\n\nZap follows a simple, hierarchical structure that makes it easy to build interactive experiences.\n\n## The Hierarchy\n\n```\nGame\n└── Scene(s)\n    ├── Entity (Sprite, Text, etc.)\n    ├── Entity\n    └── Entity\n```\n\nEvery Zap application follows this pattern:\n\n1. **Game** - The root container that manages the canvas, game loop, and systems\n2. **Scene** - A container for entities (like a level or screen)\n3. **Entities** - Visual elements (sprites, text, buttons, etc.)\n\n## Core Components\n\n### Game\n\nThe `Game` class is your application's entry point. It:\n\n- Creates and manages the HTML5 canvas\n- Runs the game loop (updates and renders)\n- Handles scene management and transitions\n- Provides gesture recognition\n- Manages the camera\n\nThere is typically one `Game` instance per application.\n\n### Scene\n\nA `Scene` is a container for entities. Use scenes to organize different screens or levels:\n\n- **Menu scene** - Start screen with buttons\n- **Game scene** - The actual gameplay\n- **Results scene** - End screen showing scores\n\nScenes can be switched with smooth transitions.\n\n### Entity\n\nEntities are the building blocks of your game. They represent visual elements like:\n\n- `Sprite` - Colored rectangles and image sprites\n- `Text` - Rendered text with custom fonts\n- `Button` - Interactive UI buttons\n- `AnimatedSprite` - Frame-by-frame animations\n- `NinePatch` - Scalable UI panels\n\nAll entities share common properties like position, rotation, scale, and opacity.\n\n## Systems\n\nZap includes several systems that work together:\n\n### Gesture Manager\n\nHandles touch and mouse input, recognizing:\n- Tap\n- Swipe (up, down, left, right)\n- Drag\n- Long press\n\n### Tween Manager\n\nManages all animations created with `.tween()`. Automatically updates and removes completed tweens.\n\n### Audio Manager\n\nHandles sound effects and music playback with volume control and sprite sheet support.\n\n### Asset Loader\n\nPre-loads images, sounds, and fonts before your game starts.\n\n### Camera\n\nControls the viewport, allowing you to pan, zoom, and follow entities.\n\n## Event System\n\nZap uses an event-driven architecture. Entities can emit and listen for events:\n\n```javascript\n// Listen for events\nsprite.on('tap', () => console.log('Tapped!'));\nsprite.on('drag', (e) => console.log(e.x, e.y));\n\n// Emit custom events\nsprite.emit('custom-event', { data: 'hello' });\n```\n\n## The Game Loop\n\nZap runs a standard game loop:\n\n1. **Update** - Update entity properties, animations, and physics\n2. **Render** - Draw all entities to the canvas\n3. **Repeat** - Continue at 60 FPS (or your target FPS)\n\nThe loop is managed automatically - you just add entities and they render.\n\n## Rendering Order\n\nEntities render in the order they were added to the scene (painter's algorithm):\n\n```javascript\nscene.add(background);  // Renders first (back)\nscene.add(player);      // Renders second (middle)\nscene.add(ui);          // Renders last (front)\n```\n\nChange render order with `z-index`:\n\n```javascript\nplayer.zIndex = 100;\nbackground.zIndex = 0;\n```\n\n## Memory Management\n\nZap automatically manages most resources, but you should:\n\n- Call `game.destroy()` when completely done\n- Remove event listeners when entities are removed\n- Clear references to large objects\n\n```javascript\nsprite.off('tap', handler);  // Remove specific listener\nsprite.offAll();             // Remove all listeners\nscene.remove(sprite);        // Remove from scene\n```\n\n## Best Practices\n\n1. **One game instance** - Create a single `Game` per application\n2. **Scene organization** - Use scenes for different screens/levels\n3. **Entity reuse** - Pool frequently created/destroyed entities\n4. **Event cleanup** - Remove listeners when not needed\n5. **Asset preloading** - Load images/sounds before displaying\n\n## Next Steps\n\n- [Game Configuration](/core/game) - All Game configuration options\n- [Scenes](/core/scenes) - Working with scenes and transitions\n- [Entities](/core/entities) - Understanding the entity lifecycle"
      },
      {
        "slug": "core/camera",
        "title": "Camera",
        "description": "Viewport control with follow, zoom, and screen shake",
        "path": "core/camera.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/core/camera.md",
        "content": "# Camera\n\nThe Camera controls the game viewport, providing follow, zoom, rotation, and screen shake effects. Perfect for creating dynamic game experiences and smooth character following.\n\n## Accessing the Camera\n\nEvery game has a camera accessible via `game.camera`:\n\n```javascript\nimport { Game } from '@mode-7/zap';\n\nconst game = new Game({ width: 400, height: 300 });\n\n// Access the camera\ngame.camera.setZoom(2);\ngame.camera.setPosition(100, 100);\n```\n\n## Follow Entity\n\nMake the camera smoothly follow an entity as it moves through a larger world:\n\n```codemirror\nimport { Game, Scene, Sprite, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\n// Create a larger world with reference points\nfor (let i = 0; i < 15; i++) {\n  for (let j = 0; j < 10; j++) {\n    const dot = new Sprite({\n      x: i * 100,\n      y: j * 100,\n      width: 6,\n      height: 6,\n      color: '#1a1a2e',\n      radius: 3\n    });\n    scene.add(dot);\n  }\n}\n\n// Add some landmarks\nconst landmarks = [\n  { x: 300, y: 200, color: '#4fc3f7', label: 'A' },\n  { x: 800, y: 300, color: '#51cf66', label: 'B' },\n  { x: 500, y: 600, color: '#f39c12', label: 'C' },\n  { x: 1200, y: 400, color: '#9b59b6', label: 'D' }\n];\n\nlandmarks.forEach(lm => {\n  const landmark = new Sprite({\n    x: lm.x,\n    y: lm.y,\n    width: 50,\n    height: 50,\n    color: lm.color,\n    radius: 25\n  });\n  const label = new Text({\n    text: lm.label,\n    fontSize: 20,\n    color: '#fff',\n    align: 'center',\n    baseline: 'middle'\n  });\n  landmark.addChild(label);\n  scene.add(landmark);\n});\n\n// Player\nconst player = new Sprite({\n  x: 300,\n  y: 200,\n  width: 40,\n  height: 40,\n  color: '#e94560',\n  radius: 20\n});\n\nconst instruction = new Text({\n  text: 'Tap anywhere to move',\n  x: 200,\n  y: 20,\n  fontSize: 14,\n  color: '#888',\n  align: 'center'\n});\n\nscene.add(player);\nscene.add(instruction);\n\n// Camera follows player smoothly\ngame.camera.follow(player, { x: 0, y: 0 }, 0.1);\n\n// Tap to move player\ngame.on('tap', (event) => {\n  player.tween(\n    { x: event.position.x, y: event.position.y },\n    { duration: 1000, easing: 'easeInOutQuad' }\n  );\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Follow with Offset\n\nOffset the camera from the target:\n\n```javascript\n// Follow with offset (useful for looking ahead)\ngame.camera.follow(player, { x: 50, y: 0 });  // 50px ahead horizontally\n```\n\n## Follow Speed\n\nControl how quickly the camera catches up:\n\n```javascript\n// Smooth following (0 = instant, 1 = normal, <1 = slower)\ngame.camera.follow(player, { x: 0, y: 0 }, 0.5);  // Slower, cinematic\n\n// Fast following\ngame.camera.follow(player, { x: 0, y: 0 }, 2.0);  // Quick response\n```\n\n## Stop Following\n\nStop camera follow:\n\n```javascript\ngame.camera.stopFollow();\n```\n\n## Zoom\n\nControl camera zoom level:\n\n```codemirror\nimport { Game, Scene, Sprite, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst player = new Sprite({\n  x: 200,\n  y: 150,\n  width: 40,\n  height: 40,\n  color: '#e94560',\n  radius: 20\n});\n\nconst zoomInBtn = new Sprite({\n  x: 80,\n  y: 40,\n  width: 70,\n  height: 35,\n  color: '#4fc3f7',\n  radius: 8,\n  interactive: true\n});\n\nconst zoomInLabel = new Text({\n  text: 'Zoom In',\n  fontSize: 12,\n  color: '#fff',\n  align: 'center',\n  baseline: 'middle'\n});\n\nzoomInBtn.addChild(zoomInLabel);\n\nconst zoomOutBtn = new Sprite({\n  x: 160,\n  y: 40,\n  width: 80,\n  height: 35,\n  color: '#51cf66',\n  radius: 8,\n  interactive: true\n});\n\nconst zoomOutLabel = new Text({\n  text: 'Zoom Out',\n  fontSize: 12,\n  color: '#fff',\n  align: 'center',\n  baseline: 'middle'\n});\n\nzoomOutBtn.addChild(zoomOutLabel);\n\nconst resetBtn = new Sprite({\n  x: 250,\n  y: 40,\n  width: 60,\n  height: 35,\n  color: '#888',\n  radius: 8,\n  interactive: true\n});\n\nconst resetLabel = new Text({\n  text: 'Reset',\n  fontSize: 12,\n  color: '#fff',\n  align: 'center',\n  baseline: 'middle'\n});\n\nresetBtn.addChild(resetLabel);\n\nscene.add(player);\nscene.add(zoomInBtn);\nscene.add(zoomOutBtn);\nscene.add(resetBtn);\n\nzoomInBtn.on('tap', () => {\n  game.camera.setZoom(game.camera.zoom * 1.2);\n});\n\nzoomOutBtn.on('tap', () => {\n  game.camera.setZoom(game.camera.zoom / 1.2);\n});\n\nresetBtn.on('tap', () => {\n  game.camera.setZoom(1);\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Manual Positioning\n\nSet camera position directly:\n\n```javascript\n// Center on specific coordinates\ngame.camera.setPosition(500, 300);\n\n// Pan to position with tweening\nconst currentX = game.camera.x;\nconst currentY = game.camera.y;\n\n// Manually tween camera (camera itself doesn't have .tween())\nfunction panTo(targetX, targetY, duration = 1000) {\n  const startX = game.camera.x;\n  const startY = game.camera.y;\n  const startTime = Date.now();\n\n  function update() {\n    const elapsed = Date.now() - startTime;\n    const progress = Math.min(elapsed / duration, 1);\n\n    game.camera.x = startX + (targetX - startX) * progress;\n    game.camera.y = startY + (targetY - startY) * progress;\n\n    if (progress < 1) {\n      requestAnimationFrame(update);\n    }\n  }\n\n  update();\n}\n\npanTo(500, 300);\n```\n\n## Screen Shake\n\nAdd screen shake for impacts and effects:\n\n```codemirror\nimport { Game, Scene, Sprite, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst shakeBtn = new Sprite({\n  x: 200,\n  y: 150,\n  width: 140,\n  height: 50,\n  color: '#e94560',\n  radius: 8,\n  interactive: true\n});\n\nconst label = new Text({\n  text: 'Shake!',\n  fontSize: 16,\n  color: '#fff',\n  align: 'center',\n  baseline: 'middle'\n});\n\nshakeBtn.addChild(label);\n\nconst instruction = new Text({\n  text: 'Tap to shake the screen',\n  x: 200,\n  y: 230,\n  fontSize: 12,\n  color: '#888',\n  align: 'center'\n});\n\nscene.add(shakeBtn);\nscene.add(instruction);\n\nshakeBtn.on('tap', () => {\n  // Shake(intensity, duration in ms)\n  game.camera.shake(10, 400);\n\n  shakeBtn.tween(\n    { scaleX: 0.9, scaleY: 0.9 },\n    { duration: 100 }\n  ).then(() => {\n    shakeBtn.tween(\n      { scaleX: 1, scaleY: 1 },\n      { duration: 100 }\n    );\n  });\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n### Shake Parameters\n\n```javascript\n// Subtle shake\ngame.camera.shake(5, 200);\n\n// Medium shake (default)\ngame.camera.shake(10, 300);\n\n// Intense shake\ngame.camera.shake(20, 500);\n```\n\n## Common Patterns\n\n### Player Follow with Boundaries\n\nConstrain camera to level boundaries:\n\n```javascript\ngame.camera.follow(player);\n\n// In update loop or after following\nscene.on('update', () => {\n  // Constrain camera to level boundaries\n  const levelWidth = 2000;\n  const levelHeight = 1500;\n  const halfWidth = game.canvas.width / 2;\n  const halfHeight = game.canvas.height / 2;\n\n  game.camera.x = Math.max(halfWidth, Math.min(levelWidth - halfWidth, game.camera.x));\n  game.camera.y = Math.max(halfHeight, Math.min(levelHeight - halfHeight, game.camera.y));\n});\n```\n\n### Zoom on Scroll\n\nZoom with mouse wheel:\n\n```javascript\ngame.canvas.addEventListener('wheel', (event) => {\n  event.preventDefault();\n\n  const zoomSpeed = 0.1;\n  const delta = -Math.sign(event.deltaY);\n\n  game.camera.setZoom(\n    Math.max(0.5, Math.min(3, game.camera.zoom + delta * zoomSpeed))\n  );\n});\n```\n\n### Look Ahead\n\nCamera leads in movement direction:\n\n```javascript\nlet playerVelocity = { x: 0, y: 0 };\n\nplayer.on('drag', (event) => {\n  playerVelocity = event.delta;\n  player.x += event.delta.x;\n  player.y += event.delta.y;\n});\n\n// Camera looks ahead in movement direction\ngame.camera.follow(player, {\n  x: playerVelocity.x * 20,\n  y: playerVelocity.y * 20\n}, 0.5);\n```\n\n### Cutscene Camera\n\nScripted camera movements:\n\n```javascript\nasync function cutscene() {\n  // Stop following player\n  game.camera.stopFollow();\n\n  // Pan to location 1\n  await panTo(500, 300, 2000);\n\n  // Zoom in\n  await new Promise(resolve => {\n    const startZoom = game.camera.zoom;\n    const targetZoom = 2;\n    const duration = 1000;\n    const startTime = Date.now();\n\n    function update() {\n      const progress = Math.min((Date.now() - startTime) / duration, 1);\n      game.camera.setZoom(startZoom + (targetZoom - startZoom) * progress);\n\n      if (progress < 1) {\n        requestAnimationFrame(update);\n      } else {\n        resolve();\n      }\n    }\n\n    update();\n  });\n\n  // Pan to location 2\n  await panTo(800, 600, 2000);\n\n  // Resume following player\n  game.camera.follow(player);\n}\n```\n\n### Impact Shake\n\nDifferent shake intensities for different events:\n\n```javascript\n// Small hit\nenemy.on('hit', () => {\n  game.camera.shake(3, 150);\n});\n\n// Explosion\nbomb.on('explode', () => {\n  game.camera.shake(15, 400);\n});\n\n// Boss stomp\nboss.on('stomp', () => {\n  game.camera.shake(25, 600);\n});\n```\n\n### Smooth Zoom Transition\n\nAnimate zoom changes:\n\n```javascript\nfunction smoothZoom(targetZoom, duration = 500) {\n  const startZoom = game.camera.zoom;\n  const startTime = Date.now();\n\n  function update() {\n    const elapsed = Date.now() - startTime;\n    const progress = Math.min(elapsed / duration, 1);\n\n    // Use easing for smooth feel\n    const eased = 1 - Math.pow(1 - progress, 3);  // easeOutCubic\n    game.camera.setZoom(startZoom + (targetZoom - startZoom) * eased);\n\n    if (progress < 1) {\n      requestAnimationFrame(update);\n    }\n  }\n\n  update();\n}\n\n// Usage\nsmoothZoom(2.0);  // Zoom to 2x smoothly\n```\n\n### Drag to Pan Camera\n\nPan camera by dragging canvas:\n\n```javascript\nlet isDragging = false;\nlet dragStart = { x: 0, y: 0 };\n\ngame.on('dragstart', (event) => {\n  isDragging = true;\n  dragStart = { x: event.position.x, y: event.position.y };\n});\n\ngame.on('drag', (event) => {\n  if (isDragging) {\n    game.camera.x -= event.delta.x;\n    game.camera.y -= event.delta.y;\n  }\n});\n\ngame.on('dragend', () => {\n  isDragging = false;\n});\n```\n\n### Split Screen Effect\n\nCreate split-screen by rendering twice with different camera positions:\n\n```javascript\n// This is advanced - requires custom rendering\n// Not directly supported but possible with manual rendering\n```\n\n## Camera Properties\n\nDirect property access:\n\n```javascript\n// Position\nconsole.log(game.camera.x, game.camera.y);\n\n// Zoom level (1 = normal, 2 = 2x zoom, 0.5 = zoomed out)\nconsole.log(game.camera.zoom);\n\n// Rotation (in radians)\ngame.camera.rotation = Math.PI / 4;  // 45 degrees\n\n// Size (read-only, matches canvas)\nconsole.log(game.camera.width, game.camera.height);\n```\n\n## Coordinate Conversion\n\nConvert between screen and world coordinates:\n\n```javascript\n// Screen to world (useful for mouse/touch input)\nconst worldPos = game.camera.screenToWorld(mouseX, mouseY);\n\n// World to screen (useful for UI overlays)\nconst screenPos = game.camera.worldToScreen(entity.x, entity.y);\n```\n\n## Tips\n\n- **Use follow for player cameras** - Smoother than manual updates\n- **Constrain zoom** - Prevent users from zooming too far in/out\n- **Shake sparingly** - Too much shake is disorienting\n- **Consider boundaries** - Prevent camera from showing empty space\n- **Follow speed matters** - 0.5-1.0 feels cinematic, 1.5-2.0 feels responsive\n\n## Common Mistakes\n\n### Forgetting to stop follow\n\n```javascript\n// ❌ Wrong - camera still follows old target\ngame.setScene(newScene);\ngame.camera.follow(newPlayer);  // Follows old player too!\n\n// ✅ Right - stop following first\ngame.camera.stopFollow();\ngame.setScene(newScene);\ngame.camera.follow(newPlayer);\n```\n\n### Zoom limits\n\n```javascript\n// ❌ Wrong - no limits\nzoomInButton.on('tap', () => {\n  game.camera.setZoom(game.camera.zoom * 2);  // Can zoom infinitely\n});\n\n// ✅ Right - clamp zoom\nzoomInButton.on('tap', () => {\n  const newZoom = Math.min(3, game.camera.zoom * 1.5);\n  game.camera.setZoom(newZoom);\n});\n```\n\n## Next Steps\n\n- [Scenes](/core/scenes) - Manage game scenes\n- [Entities](/core/entities) - Create game objects\n- [Tweening](/animation/tweening) - Animate camera movements"
      },
      {
        "slug": "core/entities",
        "title": "Entities",
        "description": "Understanding the entity system and lifecycle",
        "path": "core/entities.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/core/entities.md",
        "content": "# Entities\n\nEntities are the building blocks of your game. Everything you see on screen is an entity - sprites, text, buttons, and more.\n\n## Entity Types\n\nZap provides several built-in entity types:\n\n- **Sprite** - Colored rectangles and image sprites\n- **Text** - Rendered text with custom fonts\n- **Button** - Interactive UI buttons\n- **AnimatedSprite** - Frame-by-frame animations\n- **NinePatch** - Scalable UI panels\n\nAll entities extend the base `Entity` class and share common properties and methods.\n\n## Common Properties\n\n### Transform Properties\n\nEvery entity has transform properties:\n\n```javascript\nconst sprite = new Sprite({\n  x: 100,           // X position\n  y: 100,           // Y position\n  rotation: 0,      // Rotation in radians\n  scaleX: 1,        // Horizontal scale\n  scaleY: 1,        // Vertical scale\n  alpha: 1          // Opacity (0-1)\n});\n\n// Modify after creation\nsprite.x = 200;\nsprite.rotation = Math.PI / 4;\nsprite.alpha = 0.5;\n```\n\n### Size Properties\n\nControl entity dimensions:\n\n```javascript\nconst sprite = new Sprite({\n  width: 100,\n  height: 100\n});\n```\n\n### Anchor Point\n\nThe anchor determines the origin point for transformations:\n\n```javascript\nconst sprite = new Sprite({\n  anchorX: 0.5,  // Center horizontally (default)\n  anchorY: 0.5   // Center vertically (default)\n});\n\n// Top-left anchor\nsprite.anchorX = 0;\nsprite.anchorY = 0;\n\n// Bottom-right anchor\nsprite.anchorX = 1;\nsprite.anchorY = 1;\n```\n\nAnchor values range from 0 to 1:\n- `0` = left/top edge\n- `0.5` = center (default)\n- `1` = right/bottom edge\n\n### Visibility\n\nControl whether an entity renders:\n\n```javascript\nsprite.visible = true;   // Render (default)\nsprite.visible = false;  // Don't render\n```\n\nHidden entities still update but don't draw.\n\n### Z-Index\n\nControl render order:\n\n```javascript\nbackground.zIndex = 0;   // Render first (back)\nplayer.zIndex = 10;      // Render middle\nui.zIndex = 100;         // Render last (front)\n```\n\nHigher z-index renders on top.\n\n## Interactivity\n\nMake entities respond to gestures:\n\n```javascript\nconst sprite = new Sprite({\n  x: 100,\n  y: 100,\n  width: 50,\n  height: 50,\n  interactive: true  // Enable gestures\n});\n\nsprite.on('tap', () => {\n  console.log('Tapped!');\n});\n\nsprite.on('drag', (e) => {\n  sprite.x = e.x;\n  sprite.y = e.y;\n});\n```\n\nAvailable gesture events:\n- `tap` - Quick touch/click\n- `drag` - Move while holding\n- `swipe` - Quick swipe gesture\n- `longpress` - Hold for duration\n\n## Tags\n\nTag entities for easy grouping and retrieval:\n\n```javascript\nplayer.addTag('player');\nplayer.addTag('friendly');\n\nenemy.addTag('enemy');\nenemy.addTag('hostile');\n\n// Check tags\nif (entity.hasTag('enemy')) {\n  // Handle enemy\n}\n\n// Find by tag\nconst enemies = scene.getEntitiesByTag('enemy');\n```\n\n## Hierarchy\n\nCreate parent-child relationships:\n\n```javascript\nconst parent = new Sprite({\n  x: 100,\n  y: 100,\n  width: 100,   // Dimensions needed for interactive containers\n  height: 100\n});\n\nconst child = new Sprite({\n  x: 50,\n  y: 0,\n  width: 30,\n  height: 30,\n  color: '#4fc3f7'\n});\n\nparent.addChild(child);\n\n// Child transforms relative to parent\nparent.rotation = Math.PI / 4;  // Child rotates too\nparent.x = 200;                  // Child moves too\n```\n\n**IMPORTANT**: If the parent sprite is `interactive: true`, it **must have `width` and `height`** specified. Without dimensions, gesture detection won't work because there's no hit area to detect touches.\n\n```javascript\n// ❌ WRONG - Interactive container without dimensions\nconst cardGroup = new Sprite({\n  x: 200, y: 150,\n  interactive: true  // Won't work without width/height!\n});\n\n// ✅ CORRECT - Interactive container with dimensions\nconst cardGroup = new Sprite({\n  x: 200, y: 150,\n  width: 300,   // Must specify for gestures to work\n  height: 400,\n  interactive: true\n});\n```\n\nRemove children:\n\n```javascript\nparent.removeChild(child);\n```\n\n## Animation (Tweening)\n\nAnimate entity properties smoothly:\n\n```javascript\nsprite.tween(\n  { x: 400, rotation: Math.PI },\n  { duration: 1000, easing: 'easeInOutQuad' }\n);\n```\n\nChain animations:\n\n```javascript\nsprite.tween(\n  { x: 400 },\n  { duration: 500 }\n).then(() => {\n  return sprite.tween(\n    { y: 300 },\n    { duration: 500 }\n  );\n});\n```\n\nLoop forever:\n\n```javascript\nsprite.tween(\n  { rotation: Math.PI * 2 },\n  { duration: 2000, loop: true }\n);\n```\n\n## Complete Example\n\nHere's an entity using many features:\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\n// Create a player sprite\nconst player = new Sprite({\n  x: 200,\n  y: 150,\n  width: 40,\n  height: 40,\n  color: '#e94560',\n  anchorX: 0.5,\n  anchorY: 0.5,\n  interactive: true,\n  zIndex: 10\n});\n\n// Add tag\nplayer.addTag('player');\n\n// Make it draggable\nplayer.on('drag', (e) => {\n  player.x = e.x;\n  player.y = e.y;\n});\n\n// Rotate on tap\nplayer.on('tap', () => {\n  player.tween(\n    { rotation: player.rotation + Math.PI * 2 },\n    { duration: 500, easing: 'easeOutBack' }\n  );\n});\n\n// Create a child that orbits\nconst child = new Sprite({\n  x: 60,\n  y: 0,\n  width: 20,\n  height: 20,\n  color: '#4fc3f7',\n  anchorX: 0.5,\n  anchorY: 0.5\n});\n\nplayer.addChild(child);\n\n// Animate child orbit\nchild.tween(\n  { rotation: Math.PI * 2 },\n  { duration: 3000, loop: true }\n);\n\nscene.add(player);\ngame.setScene(scene);\ngame.start();\n```\n\n## Lifecycle\n\nEntities have a simple lifecycle:\n\n1. **Created** - `new Sprite()`\n2. **Added to Scene** - `scene.add(entity)`\n3. **Updated & Rendered** - Every frame while in scene\n4. **Removed from Scene** - `scene.remove(entity)`\n\nHandle lifecycle events:\n\n```javascript\n// When added to scene\nentity.on('added', () => {\n  console.log('Added to scene');\n});\n\n// When removed from scene\nentity.on('removed', () => {\n  console.log('Removed from scene');\n});\n```\n\n## Best Practices\n\n1. **Reuse entities** - Don't create/destroy frequently\n2. **Use tags** - Group related entities\n3. **Set z-index** - Control render order explicitly\n4. **Parent wisely** - Use hierarchy for related transforms\n5. **Clean up listeners** - Remove event listeners when done\n6. **Hide vs Remove** - Use `visible = false` for temporary hiding\n\n## Common Patterns\n\n### Object Pooling\n\nReuse entities instead of creating new ones:\n\n```javascript\nconst bulletPool = [];\n\nfunction getBullet() {\n  return bulletPool.pop() || new Sprite({ width: 5, height: 10 });\n}\n\nfunction releaseBullet(bullet) {\n  bullet.visible = false;\n  bulletPool.push(bullet);\n}\n```\n\n### Entity Groups\n\nUse tags to manage groups:\n\n```javascript\n// Create enemies\nfor (let i = 0; i < 10; i++) {\n  const enemy = new Sprite({ x: i * 50, y: 100 });\n  enemy.addTag('enemy');\n  scene.add(enemy);\n}\n\n// Update all enemies\nconst enemies = scene.getEntitiesByTag('enemy');\nenemies.forEach(enemy => {\n  enemy.y += 1;\n});\n```\n\n## Next Steps\n\n- [Sprites](/visual/sprite) - Learn about the Sprite entity\n- [Text](/visual/text) - Add text to your game\n- [Animations](/animation/animations) - Master tweening\n- [Gestures](/interactions/tap) - Handle user input"
      },
      {
        "slug": "core/game",
        "title": "Game Configuration",
        "description": "Configure your Game instance with all available options",
        "path": "core/game.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/core/game.md",
        "content": "# Game Configuration\n\nThe `Game` class is the root of your Zap application. It manages the canvas, game loop, and all core systems.\n\n## Basic Setup\n\nThe simplest game requires no configuration:\n\n```javascript\nimport { Game, Scene } from '@mode-7/zap';\n\nconst game = new Game();\nconst scene = new Scene();\ngame.setScene(scene);\ngame.start();\n```\n\nThis creates a 800x600 canvas appended to `document.body`.\n\n## Display Options\n\n### Canvas Size\n\nControl the dimensions of your game:\n\n```javascript\nconst game = new Game({\n  width: 1024,\n  height: 768\n});\n```\n\n### Custom Parent\n\nAppend the canvas to a specific element:\n\n```javascript\n// Using a selector\nconst game = new Game({\n  parent: '#game-container'\n});\n\n// Using an element reference\nconst container = document.getElementById('game-container');\nconst game = new Game({\n  parent: container\n});\n```\n\n### Existing Canvas\n\nUse an existing canvas element:\n\n```javascript\nconst canvas = document.querySelector('canvas');\nconst game = new Game({\n  canvas: canvas,\n  width: 800,\n  height: 600\n});\n```\n\n### Background Color\n\nSet the default background color:\n\n```javascript\nconst game = new Game({\n  backgroundColor: '#0f3460'\n});\n```\n\n### Responsive Mode\n\nMake the canvas automatically resize with its container:\n\n```javascript\nconst game = new Game({\n  responsive: true\n});\n```\n\n**With Aspect Ratio Control:**\n\nCombine `responsive: true` with `width` and `height` to maintain a specific aspect ratio:\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\n// Creates a responsive game that maintains 16:9 aspect ratio\nconst game = new Game({\n  parent: '#app',\n  width: 1920,\n  height: 1080,  // 16:9 aspect ratio\n  responsive: true,\n  backgroundColor: '#1a1a2e'\n});\n\nconst scene = new Scene();\n\n// Game will automatically add letterboxing/pillarboxing to maintain aspect ratio\n// Your game logic always works with the specified dimensions (1920x1080)\n\nconst player = new Sprite({\n  x: game.width / 2,  // Always 960 (half of 1920)\n  y: game.height / 2,  // Always 540 (half of 1080)\n  width: 50,\n  height: 50,\n  color: '#e94560'\n});\n\nscene.add(player);\ngame.setScene(scene);\ngame.start();\n```\n\n**Common Aspect Ratios:**\n- `width: 1920, height: 1080` - 16:9 landscape (HD/Full HD)\n- `width: 1280, height: 720` - 16:9 landscape (HD)\n- `width: 800, height: 600` - 4:3 landscape (classic)\n- `width: 1080, height: 1920` - 9:16 portrait (mobile)\n- `width: 720, height: 1280` - 9:16 portrait (mobile)\n\n**Benefits:**\n- Canvas automatically scales to fit container\n- Aspect ratio is always maintained with letterboxing/pillarboxing\n- Your code always uses the same coordinate system\n- No complex responsive calculations needed\n- `game.width` and `game.height` stay constant\n\n## Rendering Quality\n\n### Pixel Ratio\n\nControl pixel density for high-DPI displays:\n\n```javascript\n// Use device pixel ratio (default)\nconst game = new Game({\n  pixelRatio: window.devicePixelRatio\n});\n\n// Force 1x for pixel art\nconst game = new Game({\n  pixelRatio: 1,\n  antialias: false\n});\n```\n\n### Antialiasing\n\nControl image smoothing:\n\n```javascript\nconst game = new Game({\n  antialias: true,  // Smooth rendering (default)\n  imageSmoothingQuality: 'high'  // 'low', 'medium', or 'high'\n});\n```\n\nFor pixel-perfect rendering:\n\n```javascript\nconst game = new Game({\n  antialias: false,\n  pixelRatio: 1\n});\n```\n\n## Performance Options\n\n### Target FPS\n\nLimit the frame rate:\n\n```javascript\nconst game = new Game({\n  targetFPS: 30  // Run at 30 FPS instead of 60\n});\n```\n\n### Max Delta Time\n\nPrevent spiral of death during lag:\n\n```javascript\nconst game = new Game({\n  maxDeltaTime: 0.1  // Cap delta at 100ms (default)\n});\n```\n\n## Canvas Context Options\n\n### Transparent Canvas\n\nAllow transparency:\n\n```javascript\nconst game = new Game({\n  alpha: true,\n  backgroundColor: 'transparent'\n});\n```\n\n### Desynchronized Rendering\n\nHint for better performance (enabled by default):\n\n```javascript\nconst game = new Game({\n  desynchronized: true  // default\n});\n```\n\n## Features\n\n### Touch Trail\n\nEnable visual touch trails:\n\n```javascript\nconst game = new Game({\n  enableTouchTrail: true\n});\n\n// Access the touch trail\ngame.touchTrail.color = '#4fc3f7';\ngame.touchTrail.width = 20;\n```\n\n## Debug Options\n\n### FPS Counter\n\nShow frames per second:\n\n```javascript\nconst game = new Game({\n  showFPS: true\n});\n```\n\nThe FPS counter appears in the top-left corner.\n\n## Complete Example\n\nHere's a game with all common options:\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\nconst game = new Game({\n  // Display\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460',\n  parent: document.body,\n\n  // Quality\n  pixelRatio: window.devicePixelRatio,\n  antialias: true,\n  imageSmoothingQuality: 'high',\n\n  // Debug\n  showFPS: true\n});\n\nconst scene = new Scene();\n\nconst sprite = new Sprite({\n  x: 200,\n  y: 150,\n  width: 60,\n  height: 60,\n  color: '#e94560'\n});\n\nscene.add(sprite);\ngame.setScene(scene);\ngame.start();\n```\n\n## Game Methods\n\n### setScene()\n\nSwitch to a new scene:\n\n```javascript\ngame.setScene(newScene);\n```\n\nWith a transition:\n\n```javascript\ngame.setScene(newScene, {\n  transition: 'fade',\n  duration: 500\n});\n```\n\nAvailable transitions: `'fade'`, `'slide-left'`, `'slide-right'`, `'slide-up'`, `'slide-down'`\n\n### start()\n\nStart the game loop:\n\n```javascript\ngame.start();\n```\n\n### stop()\n\nPause the game loop:\n\n```javascript\ngame.stop();\n```\n\n### destroy()\n\nClean up and remove the game:\n\n```javascript\ngame.destroy();\n```\n\n## Game Properties\n\nAccess useful properties:\n\n```javascript\ngame.width          // Canvas width\ngame.height         // Canvas height\ngame.canvas         // HTMLCanvasElement\ngame.ctx            // CanvasRenderingContext2D\ngame.camera         // Camera instance\ngame.gestures       // GestureManager instance\ngame.currentScene   // Current Scene (read-only)\n```\n\n## Next Steps\n\n- [Scenes](/core/scenes) - Learn about scene management\n- [Camera](/camera/camera) - Control the viewport\n- [Gestures](/interactions/tap) - Handle user input"
      },
      {
        "slug": "core/scenes",
        "title": "Scenes",
        "description": "Organize your game with scenes and transitions",
        "path": "core/scenes.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/core/scenes.md",
        "content": "# Scenes\n\nScenes are containers for entities. Use them to organize different parts of your application like menus, gameplay, and results screens.\n\n## Creating a Scene\n\nCreate a scene and add entities to it:\n\n```javascript\nimport { Scene, Sprite } from '@mode-7/zap';\n\nconst scene = new Scene();\n\nconst sprite = new Sprite({\n  x: 100,\n  y: 100,\n  width: 50,\n  height: 50,\n  color: '#667eea'\n});\n\nscene.add(sprite);\n```\n\n## Adding Entities\n\nAdd entities with the `add()` method:\n\n```javascript\nscene.add(sprite);\nscene.add(text);\nscene.add(button);\n```\n\nChain additions:\n\n```javascript\nscene\n  .add(background)\n  .add(player)\n  .add(enemy)\n  .add(ui);\n```\n\n## Background Images and Colors\n\nThe Scene constructor accepts `backgroundColor` and `backgroundImage` options for easy background setup:\n\n### Solid Color Background\n\n```javascript\nconst scene = new Scene({\n  backgroundColor: '#1a1a2e'\n});\n```\n\n### Image Background\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\nconst game = new Game({\n  parent: '#app',\n  width: 1920,\n  height: 1080,\n  responsive: true\n});\n\n// Background image automatically fills the scene\nconst scene = new Scene({\n  backgroundImage: 'background.jpg'\n});\n\n// Add entities on top\nconst player = new Sprite({\n  x: game.width / 2,\n  y: game.height / 2,\n  width: 50,\n  height: 50,\n  color: '#e94560'\n});\n\nscene.add(player);\ngame.setScene(scene);\ngame.start();\n```\n\nThe background image will automatically:\n- Fill the entire game canvas (width × height)\n- Stretch/scale to fit the game dimensions\n- Render behind all entities (at `zIndex: -1000`)\n\n**Note**: The image will stretch to fit your game's aspect ratio. For best results, use images that match your game's aspect ratio (e.g., 16:9 images for a 1920×1080 game).\n\n## Removing Entities\n\nRemove entities when no longer needed:\n\n```javascript\nscene.remove(sprite);\n```\n\n## Finding Entities\n\n### Get All Entities\n\n```javascript\nconst allEntities = scene.getEntities();\n```\n\n### Get by Tag\n\nTag your entities for easy retrieval:\n\n```javascript\nconst player = new Sprite({ x: 100, y: 100 });\nplayer.addTag('player');\n\nconst enemy1 = new Sprite({ x: 200, y: 100 });\nenemy1.addTag('enemy');\n\nconst enemy2 = new Sprite({ x: 300, y: 100 });\nenemy2.addTag('enemy');\n\nscene.add(player).add(enemy1).add(enemy2);\n\n// Find all enemies\nconst enemies = scene.getEntitiesByTag('enemy');\nconsole.log(enemies.length); // 2\n```\n\n## Scene Lifecycle\n\nScenes have lifecycle methods you can override:\n\n```javascript\nclass MenuScene extends Scene {\n  onEnter() {\n    console.log('Menu scene entered');\n    // Setup menu, start animations\n  }\n\n  onExit() {\n    console.log('Menu scene exited');\n    // Cleanup, stop sounds\n  }\n}\n```\n\nOr use events:\n\n```javascript\nscene.on('enter', () => {\n  console.log('Scene entered!');\n});\n\nscene.on('exit', () => {\n  console.log('Scene exited!');\n});\n```\n\n## Scene Transitions\n\nSwitch between scenes with smooth transitions:\n\n```javascript\nconst menuScene = new Scene();\nconst gameScene = new Scene();\n\n// Simple switch\ngame.setScene(gameScene);\n\n// With fade transition\ngame.setScene(gameScene, {\n  transition: 'fade',\n  duration: 500\n});\n\n// With slide transition\ngame.setScene(gameScene, {\n  transition: 'slide-left',\n  duration: 300\n});\n```\n\nAvailable transitions:\n- `'fade'` - Fade to black then fade in\n- `'slide-left'` - Slide left\n- `'slide-right'` - Slide right\n- `'slide-up'` - Slide up\n- `'slide-down'` - Slide down\n\n## Complete Example\n\nHere's a simple multi-scene game:\n\n```codemirror\nimport { Game, Scene, Sprite, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\n// Menu Scene\nconst menuScene = new Scene();\n\nconst menuTitle = new Text({\n  x: 200,\n  y: 100,\n  text: 'TAP TO START',\n  fontSize: 24,\n  color: '#fff',\n  align: 'center',\n  anchorX: 0.5\n});\n\nmenuScene.add(menuTitle);\n\n// Game Scene\nconst gameScene = new Scene();\n\nconst player = new Sprite({\n  x: 200,\n  y: 150,\n  width: 40,\n  height: 40,\n  color: '#e94560',\n  interactive: true\n});\n\nplayer.on('tap', () => {\n  player.tween(\n    { rotation: player.rotation + Math.PI * 2 },\n    { duration: 500 }\n  );\n});\n\ngameScene.add(player);\n\n// Setup menu interaction\nmenuTitle.interactive = true;\nmenuTitle.on('tap', () => {\n  game.setScene(gameScene, {\n    transition: 'fade',\n    duration: 300\n  });\n});\n\n// Start with menu\ngame.setScene(menuScene);\ngame.start();\n```\n\n## Scene Timers\n\nScenes provide timer methods that auto-cleanup on scene exit:\n\n```javascript\n// Delay execution\nscene.delay(1000, () => {\n  console.log('After 1 second');\n});\n\n// Repeat every interval\nconst handle = scene.interval(100, () => {\n  console.log('Every 100ms');\n});\n\n// Clear interval\nscene.clearTimer(handle);\n```\n\nTimers are automatically cleared when the scene exits.\n\n## Best Practices\n\n1. **One purpose per scene** - Each scene should represent one screen or state\n2. **Clean up resources** - Use `onExit()` to stop sounds, clear timers\n3. **Reuse scenes** - Scenes can be switched back to\n4. **Entity pooling** - Reuse entities instead of creating/destroying constantly\n5. **Tag entities** - Use tags for easy entity lookup\n\n## Common Patterns\n\n### Multi-Level Game\n\n```javascript\nclass Level1 extends Scene {\n  onEnter() {\n    // Setup level 1\n  }\n}\n\nclass Level2 extends Scene {\n  onEnter() {\n    // Setup level 2\n  }\n}\n\nconst level1 = new Level1();\nconst level2 = new Level2();\n```\n\n### Menu System\n\n```javascript\nconst mainMenu = new Scene();\nconst settingsMenu = new Scene();\nconst creditsMenu = new Scene();\n```\n\n### Pause Screen\n\n```javascript\nconst gameScene = new Scene();\nconst pauseScene = new Scene();\n\n// Switch to pause\ngame.setScene(pauseScene);\n\n// Resume game\ngame.setScene(gameScene);\n```\n\n## Next Steps\n\n- [Entities](/core/entities) - Learn about the entity system\n- [Sprites](/visual/sprite) - Create visual elements\n- [Text](/visual/text) - Add text to your scenes"
      }
    ],
    "gestures": [
      {
        "slug": "gestures/drag",
        "title": "Drag Gesture",
        "description": "Dragging and moving interactive entities",
        "path": "gestures/drag.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/gestures/drag.md",
        "content": "# Drag Gesture\n\nThe drag gesture lets users move entities around the canvas with mouse or touch. Perfect for draggable UI, puzzle pieces, and interactive game objects.\n\n## Basic Drag\n\nMake an entity draggable:\n\n```codemirror\nimport { Game, Scene, Sprite, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst sprite = new Sprite({\n  x: 200,\n  y: 150,\n  width: 70,\n  height: 70,\n  color: '#9b59b6',\n  radius: 10,\n  interactive: true\n});\n\nconst status = new Text({\n  text: 'Drag the square',\n  x: 200,\n  y: 60,\n  fontSize: 15,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nscene.add(sprite);\nscene.add(status);\n\nsprite.on('drag', (event) => {\n  sprite.x += event.delta.x;\n  sprite.y += event.delta.y;\n  status.text = `Position: (${Math.round(sprite.x)}, ${Math.round(sprite.y)})`;\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Drag Events\n\nThree events track the drag lifecycle:\n\n### dragstart\n\nFired when dragging begins:\n\n```javascript\nsprite.on('dragstart', (event) => {\n  console.log('Drag started at:', event.position);\n  sprite.alpha = 0.7;  // Visual feedback\n});\n```\n\n### drag\n\nFired continuously while dragging:\n\n```javascript\nsprite.on('drag', (event) => {\n  // event.delta contains the movement since last frame\n  sprite.x += event.delta.x;\n  sprite.y += event.delta.y;\n});\n```\n\n### dragend\n\nFired when drag ends:\n\n```javascript\nsprite.on('dragend', (event) => {\n  console.log('Drag ended at:', event.position);\n  sprite.alpha = 1;  // Restore opacity\n});\n```\n\n## Drag Event Properties\n\nEach drag event provides:\n\n- **type**: `'drag'`, `'dragstart'`, or `'dragend'`\n- **position**: `{ x, y }` - Current world position\n- **delta**: `{ x, y }` - Movement since last frame (drag event only)\n- **target**: The entity being dragged\n\n**IMPORTANT**: The event does NOT have `event.x` or `event.y` properties directly. Always use `event.position.x` or `event.delta.x`:\n\n```javascript\n// ❌ WRONG - event.x and event.y don't exist\nsprite.on('drag', (event) => {\n  sprite.x = event.x;  // This will NOT work!\n  sprite.y = event.y;\n});\n\n// ✅ CORRECT - Use event.position or event.delta\nsprite.on('drag', (event) => {\n  sprite.x = event.position.x;  // Works!\n  sprite.y = event.position.y;\n  // OR\n  sprite.x += event.delta.x;  // Works!\n  sprite.y += event.delta.y;\n});\n```\n\n## Two Ways to Move Entities\n\n### Using Delta (Recommended)\n\nSmooth, relative movement:\n\n```javascript\nsprite.on('drag', (event) => {\n  sprite.x += event.delta.x;\n  sprite.y += event.delta.y;\n});\n```\n\n### Using Position (Direct)\n\nDirect positioning (can be jumpy on some devices):\n\n```javascript\nsprite.on('drag', (event) => {\n  sprite.x = event.position.x;\n  sprite.y = event.position.y;\n});\n```\n\n**Note**: Delta movement is smoother and handles anchor points better. Use position for simple cases where the entity follows the cursor exactly.\n\n## Complete Drag Example\n\n```codemirror\nimport { Game, Scene, Sprite, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst box = new Sprite({\n  x: 200,\n  y: 150,\n  width: 80,\n  height: 80,\n  color: '#e94560',\n  radius: 12,\n  interactive: true\n});\n\nconst label = new Text({\n  text: 'Drag me!',\n  x: 200,\n  y: 50,\n  fontSize: 14,\n  color: '#888',\n  align: 'center'\n});\n\nscene.add(box);\nscene.add(label);\n\nlet isDragging = false;\n\nbox.on('dragstart', () => {\n  isDragging = true;\n  box.alpha = 0.7;\n  box.tween({ scaleX: 1.1, scaleY: 1.1 }, { duration: 150, easing: 'easeOutQuad' });\n  label.text = 'Dragging...';\n  label.color = '#4fc3f7';\n});\n\nbox.on('drag', (event) => {\n  box.x += event.delta.x;\n  box.y += event.delta.y;\n});\n\nbox.on('dragend', () => {\n  isDragging = false;\n  box.alpha = 1;\n  box.tween({ scaleX: 1, scaleY: 1 }, { duration: 150, easing: 'easeOutQuad' });\n  label.text = 'Drag me!';\n  label.color = '#888';\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Constrained Dragging\n\nLimit dragging to specific areas:\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\n// Boundary box\nconst bounds = new Sprite({\n  x: 200,\n  y: 150,\n  width: 300,\n  height: 200,\n  color: '#16213e',\n  radius: 8\n});\n\nconst slider = new Sprite({\n  x: 200,\n  y: 150,\n  width: 50,\n  height: 50,\n  color: '#4fc3f7',\n  radius: 8,\n  interactive: true\n});\n\nscene.add(bounds);\nscene.add(slider);\n\nslider.on('drag', (event) => {\n  // Update position\n  slider.x += event.delta.x;\n  slider.y += event.delta.y;\n\n  // Constrain to bounds\n  const minX = 50 + slider.width / 2;\n  const maxX = 350 - slider.width / 2;\n  const minY = 50 + slider.height / 2;\n  const maxY = 250 - slider.height / 2;\n\n  slider.x = Math.max(minX, Math.min(maxX, slider.x));\n  slider.y = Math.max(minY, Math.min(maxY, slider.y));\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Common Patterns\n\n### Horizontal Slider\n\nDrag only on the X axis:\n\n```javascript\nconst slider = new Sprite({\n  x: 200, y: 150,\n  width: 60, height: 40,\n  color: '#4fc3f7',\n  radius: 8,\n  interactive: true\n});\n\nconst minX = 100;\nconst maxX = 300;\n\nslider.on('drag', (event) => {\n  slider.x += event.delta.x;\n  // Constrain to horizontal range\n  slider.x = Math.max(minX, Math.min(maxX, slider.x));\n});\n```\n\n### Vertical Slider\n\nDrag only on the Y axis:\n\n```javascript\nconst slider = new Sprite({\n  x: 200, y: 150,\n  width: 40, height: 60,\n  color: '#51cf66',\n  radius: 8,\n  interactive: true\n});\n\nconst minY = 100;\nconst maxY = 200;\n\nslider.on('drag', (event) => {\n  slider.y += event.delta.y;\n  // Constrain to vertical range\n  slider.y = Math.max(minY, Math.min(maxY, slider.y));\n});\n```\n\n### Snap to Grid\n\nSnap dragged position to grid:\n\n```javascript\nconst gridSize = 40;\n\nsprite.on('dragend', () => {\n  // Snap to nearest grid position\n  sprite.x = Math.round(sprite.x / gridSize) * gridSize;\n  sprite.y = Math.round(sprite.y / gridSize) * gridSize;\n\n  // Animate to snapped position\n  sprite.tween(\n    { x: sprite.x, y: sprite.y },\n    { duration: 200, easing: 'easeOutQuad' }\n  );\n});\n```\n\n### Drag with Rotation\n\nRotate sprite while dragging:\n\n```javascript\nlet lastPos = { x: sprite.x, y: sprite.y };\n\nsprite.on('drag', (event) => {\n  sprite.x += event.delta.x;\n  sprite.y += event.delta.y;\n\n  // Calculate rotation based on movement direction\n  const angle = Math.atan2(event.delta.y, event.delta.x);\n  sprite.rotation = angle;\n\n  lastPos = { x: sprite.x, y: sprite.y };\n});\n```\n\n### Drop Zones\n\nDetect when dragged entity enters a zone:\n\n```javascript\nconst dropZone = new Sprite({\n  x: 300, y: 150,\n  width: 100, height: 100,\n  color: '#16213e',\n  radius: 8\n});\n\nscene.add(dropZone);\n\nsprite.on('drag', () => {\n  sprite.x += event.delta.x;\n  sprite.y += event.delta.y;\n\n  // Check if inside drop zone\n  const inZone = sprite.x > 250 && sprite.x < 350 &&\n                 sprite.y > 100 && sprite.y < 200;\n\n  dropZone.color = inZone ? '#51cf66' : '#16213e';\n});\n\nsprite.on('dragend', () => {\n  const inZone = sprite.x > 250 && sprite.x < 350 &&\n                 sprite.y > 100 && sprite.y < 200;\n\n  if (inZone) {\n    console.log('Dropped in zone!');\n    // Snap to center of zone\n    sprite.tween(\n      { x: dropZone.x, y: dropZone.y },\n      { duration: 300, easing: 'easeOutBack' }\n    );\n  }\n});\n```\n\n### Drag Multiple Objects\n\nDrag multiple entities simultaneously:\n\n```javascript\nconst entities = [];\n\nfor (let i = 0; i < 3; i++) {\n  const entity = new Sprite({\n    x: 100 + i * 100,\n    y: 150,\n    width: 60,\n    height: 60,\n    color: ['#e94560', '#51cf66', '#4fc3f7'][i],\n    radius: 8,\n    interactive: true\n  });\n\n  entity.on('drag', (event) => {\n    // Move all entities together\n    entities.forEach(e => {\n      e.x += event.delta.x;\n      e.y += event.delta.y;\n    });\n  });\n\n  entities.push(entity);\n  scene.add(entity);\n}\n```\n\n### Momentum/Flick\n\nAdd momentum when drag ends:\n\n```javascript\nlet velocity = { x: 0, y: 0 };\nconst friction = 0.95;\n\nsprite.on('drag', (event) => {\n  sprite.x += event.delta.x;\n  sprite.y += event.delta.y;\n\n  // Track velocity\n  velocity.x = event.delta.x * 60;  // Convert to pixels/second\n  velocity.y = event.delta.y * 60;\n});\n\nsprite.on('dragend', () => {\n  // Apply momentum\n  function applyMomentum() {\n    if (Math.abs(velocity.x) < 0.1 && Math.abs(velocity.y) < 0.1) {\n      return;  // Stop when velocity is low\n    }\n\n    sprite.x += velocity.x / 60;\n    sprite.y += velocity.y / 60;\n\n    velocity.x *= friction;\n    velocity.y *= friction;\n\n    requestAnimationFrame(applyMomentum);\n  }\n\n  applyMomentum();\n});\n```\n\n## Canvas-Level Drag Events\n\nListen for drag events on the entire canvas:\n\n```javascript\n// Fired when any drag starts\ngame.on('dragstart', (event) => {\n  console.log('Drag started:', event.target);\n});\n\n// Fired during any drag\ngame.on('drag', (event) => {\n  console.log('Dragging:', event.position);\n});\n\n// Fired when any drag ends\ngame.on('dragend', (event) => {\n  console.log('Drag ended');\n});\n```\n\n## Tips\n\n- **Always set `interactive: true`** on draggable entities\n- **Must have dimensions** - `width` and `height` are REQUIRED for gesture detection. Without dimensions, there's no hit area and gestures won't work!\n- **Provide visual feedback** - Change alpha, scale, or color during drag\n- **Constrain movement** - Prevent dragging off-screen or into invalid areas\n- **Use dragend for snapping** - Snap to grid, drop zones, or final positions\n- **Test on mobile** - Drag works seamlessly on both mouse and touch\n\n## Common Mistakes\n\n### Missing width and height\n\n```javascript\n// ❌ CRITICAL ERROR - No hit area, drag won't work!\nconst sprite = new Sprite({\n  x: 200,\n  y: 150,\n  interactive: true  // Useless without dimensions\n});\n// Drag events will NEVER fire!\n\n// ✅ CORRECT - Must have dimensions for hit detection\nconst sprite = new Sprite({\n  x: 200,\n  y: 150,\n  width: 100,   // Required!\n  height: 100,  // Required!\n  interactive: true\n});\n```\n\n**This is the #1 mistake!** Interactive sprites MUST have `width` and `height`. Without dimensions, gesture detection has no bounding box to test against, so all touch/mouse events pass through.\n\n### Not applying delta correctly\n\n```javascript\n// ❌ Wrong - overwrites position\nsprite.on('drag', (event) => {\n  sprite.x = event.position.x;  // Jumpy movement\n  sprite.y = event.position.y;\n});\n\n// ✅ Right - adds delta for smooth movement\nsprite.on('drag', (event) => {\n  sprite.x += event.delta.x;\n  sprite.y += event.delta.y;\n});\n```\n\n### Forgetting to handle dragend\n\n```javascript\n// ❌ Wrong - visual feedback never restored\nsprite.on('dragstart', () => {\n  sprite.alpha = 0.5;\n});\nsprite.on('drag', (event) => {\n  sprite.x += event.delta.x;\n  sprite.y += event.delta.y;\n});\n// Missing dragend!\n\n// ✅ Right - restore on dragend\nsprite.on('dragend', () => {\n  sprite.alpha = 1;\n});\n```\n\n## Next Steps\n\n- [Tap Gesture](/gestures/tap) - Tap/click detection\n- [Swipe Gesture](/gestures/swipe) - Swipe gestures\n- [Camera](/core/camera) - Drag to pan the camera"
      },
      {
        "slug": "gestures/swipe",
        "title": "Swipe Gesture",
        "description": "Swipe detection for directional input",
        "path": "gestures/swipe.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/gestures/swipe.md",
        "content": "# Swipe Gesture\n\nThe swipe gesture detects quick directional swipes. Perfect for navigation, card dismissal, and directional game controls.\n\n## Basic Swipe\n\nDetect swipe direction:\n\n```codemirror\nimport { Game, Scene, Sprite, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst sprite = new Sprite({\n  x: 200,\n  y: 150,\n  width: 100,\n  height: 100,\n  color: '#51cf66',\n  radius: 12,\n  interactive: true\n});\n\nconst label = new Text({\n  text: 'Swipe fast on the square',\n  x: 200,\n  y: 50,\n  fontSize: 14,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nconst hint = new Text({\n  text: '(Drag quickly in any direction)',\n  x: 200,\n  y: 250,\n  fontSize: 12,\n  color: '#888',\n  align: 'center'\n});\n\nscene.add(sprite);\nscene.add(label);\nscene.add(hint);\n\nsprite.on('swipe', (event) => {\n  label.text = `Swiped ${event.direction.toUpperCase()}!`;\n  label.color = '#51cf66';\n\n  // Move sprite in swipe direction\n  const distance = 80;\n  let targetX = sprite.x;\n  let targetY = sprite.y;\n\n  if (event.direction === 'left') targetX -= distance;\n  if (event.direction === 'right') targetX += distance;\n  if (event.direction === 'up') targetY -= distance;\n  if (event.direction === 'down') targetY += distance;\n\n  sprite.tween(\n    { x: targetX, y: targetY },\n    { duration: 300, easing: 'easeOutQuad' }\n  );\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Swipe Detection\n\nA swipe is detected when:\n- Movement is greater than **30 pixels**\n- Direction is clearly horizontal or vertical\n- Works on both mouse and touch\n\n## Swipe Event\n\nThe swipe event provides detailed information:\n\n```javascript\nsprite.on('swipe', (event) => {\n  console.log(event);\n  // {\n  //   type: 'swipe',\n  //   position: { x: 250, y: 150 },\n  //   direction: 'right',  // 'up', 'down', 'left', or 'right'\n  //   distance: 85.4,\n  //   velocity: { x: 0.28, y: 0.0 },\n  //   delta: { x: 85, y: 0 },\n  //   target: sprite\n  // }\n});\n```\n\n### Event Properties\n\n- **type**: `'swipe'` - The gesture type\n- **position**: `{ x, y }` - End position of swipe\n- **direction**: `'up'` | `'down'` | `'left'` | `'right'` - Swipe direction\n- **distance**: `number` - Total distance swiped in pixels\n- **velocity**: `{ x, y }` - Swipe velocity in pixels/ms\n- **delta**: `{ x, y }` - Total movement from start to end\n- **target**: The entity that was swiped\n\n## Directional Actions\n\nHandle different swipe directions:\n\n```codemirror\nimport { Game, Scene, Sprite, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst card = new Sprite({\n  x: 200,\n  y: 150,\n  width: 120,\n  height: 160,\n  color: '#4fc3f7',\n  radius: 12,\n  interactive: true\n});\n\nconst instruction = new Text({\n  text: 'Swipe to navigate',\n  x: 200,\n  y: 30,\n  fontSize: 12,\n  color: '#888',\n  align: 'center'\n});\n\nconst status = new Text({\n  text: '',\n  x: 200,\n  y: 260,\n  fontSize: 14,\n  color: '#fff',\n  align: 'center'\n});\n\nscene.add(card);\nscene.add(instruction);\nscene.add(status);\n\ncard.on('swipe', (event) => {\n  const startX = card.x;\n  const startY = card.y;\n\n  switch (event.direction) {\n    case 'up':\n      status.text = 'Going up!';\n      card.tween({ y: startY - 100, alpha: 0 }, { duration: 300, easing: 'easeOutQuad' })\n        .then(() => {\n          card.y = startY;\n          card.tween({ alpha: 1 }, { duration: 200 });\n        });\n      break;\n\n    case 'down':\n      status.text = 'Going down!';\n      card.tween({ y: startY + 100, alpha: 0 }, { duration: 300, easing: 'easeOutQuad' })\n        .then(() => {\n          card.y = startY;\n          card.tween({ alpha: 1 }, { duration: 200 });\n        });\n      break;\n\n    case 'left':\n      status.text = 'Previous';\n      card.tween({ x: startX - 150, rotation: -0.3 }, { duration: 300, easing: 'easeOutQuad' })\n        .then(() => {\n          card.x = startX;\n          card.rotation = 0;\n        });\n      break;\n\n    case 'right':\n      status.text = 'Next';\n      card.tween({ x: startX + 150, rotation: 0.3 }, { duration: 300, easing: 'easeOutQuad' })\n        .then(() => {\n          card.x = startX;\n          card.rotation = 0;\n        });\n      break;\n  }\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Common Patterns\n\n### Card Swipe Dismiss\n\nSwipe to remove cards:\n\n```javascript\nconst card = new Sprite({\n  x: 200, y: 150,\n  width: 140, height: 180,\n  color: '#e94560',\n  radius: 12,\n  interactive: true\n});\n\ncard.on('swipe', (event) => {\n  if (event.direction === 'left' || event.direction === 'right') {\n    // Dismiss card with animation\n    const targetX = event.direction === 'left' ? -100 : 500;\n\n    card.tween(\n      { x: targetX, rotation: event.direction === 'left' ? -1 : 1, alpha: 0 },\n      {\n        duration: 400,\n        easing: 'easeOutQuad',\n        onComplete: () => {\n          card.destroy();\n        }\n      }\n    );\n  }\n});\n```\n\n### Swipe Navigation\n\nNavigate between screens:\n\n```javascript\nlet currentPage = 0;\nconst pages = ['Home', 'Profile', 'Settings'];\n\nsprite.on('swipe', (event) => {\n  if (event.direction === 'left' && currentPage < pages.length - 1) {\n    currentPage++;\n    console.log('Navigate to:', pages[currentPage]);\n  } else if (event.direction === 'right' && currentPage > 0) {\n    currentPage--;\n    console.log('Navigate to:', pages[currentPage]);\n  }\n});\n```\n\n### Swipe to Refresh\n\nPull down to refresh:\n\n```javascript\nlet isRefreshing = false;\n\ncanvas.on('swipe', (event) => {\n  if (event.direction === 'down' && !isRefreshing) {\n    isRefreshing = true;\n    console.log('Refreshing...');\n\n    // Animate refresh indicator\n    setTimeout(() => {\n      console.log('Refresh complete');\n      isRefreshing = false;\n    }, 2000);\n  }\n});\n```\n\n### Swipe Controls\n\nGame character movement:\n\n```javascript\nconst player = new Sprite({\n  x: 200, y: 200,\n  width: 50, height: 50,\n  color: '#51cf66',\n  radius: 8,\n  interactive: true\n});\n\nconst moveDistance = 60;\n\nplayer.on('swipe', (event) => {\n  let targetX = player.x;\n  let targetY = player.y;\n\n  switch (event.direction) {\n    case 'up': targetY -= moveDistance; break;\n    case 'down': targetY += moveDistance; break;\n    case 'left': targetX -= moveDistance; break;\n    case 'right': targetX += moveDistance; break;\n  }\n\n  player.tween(\n    { x: targetX, y: targetY },\n    { duration: 200, easing: 'easeOutQuad' }\n  );\n});\n```\n\n### Velocity-Based Animation\n\nUse swipe velocity for physics-based motion:\n\n```javascript\nsprite.on('swipe', (event) => {\n  // Faster swipes move further\n  const multiplier = 200;  // Adjust for desired sensitivity\n\n  const targetX = sprite.x + event.velocity.x * multiplier;\n  const targetY = sprite.y + event.velocity.y * multiplier;\n\n  sprite.tween(\n    { x: targetX, y: targetY },\n    { duration: 500, easing: 'easeOutQuad' }\n  );\n});\n```\n\n### Swipe Threshold\n\nOnly respond to fast swipes:\n\n```javascript\nsprite.on('swipe', (event) => {\n  const speed = Math.sqrt(\n    event.velocity.x ** 2 + event.velocity.y ** 2\n  );\n\n  if (speed > 0.5) {  // Minimum swipe speed\n    console.log('Fast swipe detected!');\n    // Perform action\n  } else {\n    console.log('Swipe too slow');\n  }\n});\n```\n\n### Horizontal Only\n\nOnly detect horizontal swipes:\n\n```javascript\nsprite.on('swipe', (event) => {\n  if (event.direction === 'left' || event.direction === 'right') {\n    console.log('Horizontal swipe:', event.direction);\n    // Handle horizontal swipe\n  }\n  // Ignore vertical swipes\n});\n```\n\n### Vertical Only\n\nOnly detect vertical swipes:\n\n```javascript\nsprite.on('swipe', (event) => {\n  if (event.direction === 'up' || event.direction === 'down') {\n    console.log('Vertical swipe:', event.direction);\n    // Handle vertical swipe\n  }\n  // Ignore horizontal swipes\n});\n```\n\n### Swipe Progress Indicator\n\nShow swipe progress:\n\n```javascript\nlet swipeStartX = 0;\n\nsprite.on('dragstart', (event) => {\n  swipeStartX = event.position.x;\n});\n\nsprite.on('drag', (event) => {\n  const distance = event.position.x - swipeStartX;\n\n  // Visual feedback during drag\n  sprite.x = sprite.x + distance * 0.3;  // Partial movement\n  sprite.rotation = distance * 0.001;    // Slight rotation\n});\n\nsprite.on('swipe', (event) => {\n  // Complete the swipe animation\n  if (event.direction === 'left' || event.direction === 'right') {\n    const targetX = event.direction === 'left' ? -100 : 500;\n\n    sprite.tween(\n      { x: targetX, alpha: 0 },\n      { duration: 300, easing: 'easeOutQuad' }\n    );\n  }\n});\n\nsprite.on('dragend', () => {\n  // Reset if not swiped\n  sprite.tween(\n    { x: 200, rotation: 0 },\n    { duration: 200, easing: 'easeOutQuad' }\n  );\n});\n```\n\n## Canvas-Level Swipes\n\nDetect swipes anywhere on the canvas:\n\n```javascript\ngame.on('swipe', (event) => {\n  console.log('Swiped', event.direction, 'on canvas');\n\n  // Navigate scenes, scroll content, etc.\n  if (event.direction === 'left') {\n    // Next scene\n  } else if (event.direction === 'right') {\n    // Previous scene\n  }\n});\n```\n\n## Tips\n\n- **Must have dimensions** - `width` and `height` are REQUIRED for gesture detection. Without dimensions, there's no hit area and swipes won't work!\n- **Swipes are quick** - They end immediately, unlike drag which is continuous\n- **Check direction** - Handle each direction separately for clarity\n- **Use velocity** - Faster swipes can trigger different actions\n- **Combine with drag** - Use drag for preview, swipe for commit\n- **Test swipe threshold** - The default 30px works well for most cases\n\n## Common Mistakes\n\n### Missing width and height\n\n```javascript\n// ❌ CRITICAL ERROR - No hit area, swipe won't work!\nconst card = new Sprite({\n  x: 200,\n  y: 150,\n  interactive: true  // Useless without dimensions\n});\n// Swipe events will NEVER fire!\n\n// ✅ CORRECT - Must have dimensions for hit detection\nconst card = new Sprite({\n  x: 200,\n  y: 150,\n  width: 300,   // Required!\n  height: 400,  // Required!\n  interactive: true\n});\n```\n\n**This is the #1 mistake!** Interactive sprites MUST have `width` and `height`. Without dimensions, gesture detection has no bounding box to test against.\n\n### Confusing swipe with drag\n\n```javascript\n// ❌ Wrong - drag fires continuously\nsprite.on('drag', (event) => {\n  console.log('Swiped!');  // This fires many times\n});\n\n// ✅ Right - swipe fires once at the end\nsprite.on('swipe', (event) => {\n  console.log('Swiped!', event.direction);\n});\n```\n\n### Not checking direction\n\n```javascript\n// ❌ Wrong - same action for all directions\nsprite.on('swipe', () => {\n  console.log('Swiped');  // No direction handling\n});\n\n// ✅ Right - handle each direction\nsprite.on('swipe', (event) => {\n  switch (event.direction) {\n    case 'up': /* up action */; break;\n    case 'down': /* down action */; break;\n    case 'left': /* left action */; break;\n    case 'right': /* right action */; break;\n  }\n});\n```\n\n## Next Steps\n\n- [Tap Gesture](/gestures/tap) - Tap/click detection\n- [Drag Gesture](/gestures/drag) - Dragging entities\n- [Tweening](/animation/tweening) - Animate swipe results"
      },
      {
        "slug": "gestures/tap",
        "title": "Tap Gesture",
        "description": "Tap/click detection for interactive elements",
        "path": "gestures/tap.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/gestures/tap.md",
        "content": "# Tap Gesture\n\nThe tap gesture detects quick taps/clicks on interactive entities. Perfect for buttons, game objects, and any clickable UI elements.\n\n## Basic Tap\n\nMake an entity tappable with `interactive: true`:\n\n```codemirror\nimport { Game, Scene, Sprite, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst sprite = new Sprite({\n  x: 200,\n  y: 150,\n  width: 80,\n  height: 80,\n  color: '#e94560',\n  radius: 14,\n  interactive: true  // Enable tap detection\n});\n\nlet taps = 0;\nconst label = new Text({\n  text: 'Tap the square',\n  x: 200,\n  y: 70,\n  fontSize: 16,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nscene.add(sprite);\nscene.add(label);\n\nsprite.on('tap', () => {\n  taps += 1;\n  label.text = `Taps: ${taps}`;\n\n  // Rotate on tap\n  sprite.tween(\n    { rotation: sprite.rotation + Math.PI },\n    { duration: 280, easing: 'easeOutBack' }\n  );\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Tap Detection\n\nA tap is detected when:\n- Touch/click starts and ends within **10 pixels**\n- Duration is less than **300 milliseconds**\n- Works on both mouse and touch devices\n\n## Tap Event\n\nThe tap event provides information about the tap:\n\n```javascript\nsprite.on('tap', (event) => {\n  console.log(event);\n  // {\n  //   type: 'tap',\n  //   position: { x: 200, y: 150 },\n  //   target: sprite\n  // }\n});\n```\n\n### Event Properties\n\n- **type**: `'tap'` - The gesture type\n- **position**: `{ x, y }` - World position where tap occurred\n- **target**: The entity that was tapped\n\n## Visual Feedback\n\nProvide instant feedback on tap:\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst button = new Sprite({\n  x: 200,\n  y: 150,\n  width: 120,\n  height: 50,\n  color: '#4fc3f7',\n  radius: 8,\n  interactive: true\n});\n\nscene.add(button);\n\nbutton.on('tap', () => {\n  // Scale down and back up\n  button.tween(\n    { scaleX: 0.9, scaleY: 0.9 },\n    { duration: 100, easing: 'easeOutQuad' }\n  ).then(() => {\n    button.tween(\n      { scaleX: 1, scaleY: 1 },\n      { duration: 100, easing: 'easeOutBack' }\n    );\n  });\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Multiple Tappable Elements\n\nHandle taps on multiple elements:\n\n```codemirror\nimport { Game, Scene, Sprite, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst colors = ['#e94560', '#51cf66', '#4fc3f7', '#f39c12'];\nconst label = new Text({\n  text: 'Tap any circle',\n  x: 200,\n  y: 30,\n  fontSize: 14,\n  color: '#888',\n  align: 'center'\n});\n\nscene.add(label);\n\ncolors.forEach((color, i) => {\n  const sprite = new Sprite({\n    x: 80 + i * 80,\n    y: 150,\n    width: 60,\n    height: 60,\n    radius: 30,\n    color: color,\n    interactive: true\n  });\n\n  sprite.on('tap', () => {\n    label.text = `Tapped ${color}`;\n    sprite.tween(\n      { scaleX: 1.3, scaleY: 1.3 },\n      { duration: 200, easing: 'easeOutQuad' }\n    ).then(() => {\n      sprite.tween(\n        { scaleX: 1, scaleY: 1 },\n        { duration: 200, easing: 'easeOutQuad' }\n      );\n    });\n  });\n\n  scene.add(sprite);\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Canvas-Level Taps\n\nListen for taps anywhere on the canvas:\n\n```javascript\nimport { Game } from '@mode-7/zap';\n\nconst game = new Game({\n  width: 400,\n  height: 300\n});\n\n// Detect taps on the canvas itself\ngame.on('tap', (event) => {\n  console.log('Canvas tapped at:', event.position);\n  // Create ripple effect, spawn particles, etc.\n});\n```\n\n## Common Patterns\n\n### Button Press Effect\n\n```javascript\nconst button = new Sprite({\n  x: 200,\n  y: 150,\n  width: 100,\n  height: 40,\n  color: '#4fc3f7',\n  radius: 8,\n  interactive: true\n});\n\nbutton.on('tap', () => {\n  // Quick press animation\n  button.tween({ scaleY: 0.85 }, { duration: 80 })\n    .then(() => button.tween({ scaleY: 1 }, { duration: 120, easing: 'easeOutBack' }));\n});\n```\n\n### Toggle State\n\n```javascript\nlet isOn = false;\n\ntoggleButton.on('tap', () => {\n  isOn = !isOn;\n  toggleButton.color = isOn ? '#51cf66' : '#888';\n  toggleButton.tween(\n    { scaleX: 1.1, scaleY: 1.1 },\n    { duration: 100 }\n  ).then(() => {\n    toggleButton.tween(\n      { scaleX: 1, scaleY: 1 },\n      { duration: 100 }\n    );\n  });\n});\n```\n\n### Counter/Clicker\n\n```javascript\nlet score = 0;\nconst scoreText = new Text({ text: '0', x: 200, y: 50, fontSize: 24 });\n\nclickableSprite.on('tap', () => {\n  score += 1;\n  scoreText.text = score.toString();\n\n  // Spawn floating \"+1\" text\n  const floatingText = new Text({\n    text: '+1',\n    x: clickableSprite.x,\n    y: clickableSprite.y,\n    fontSize: 20,\n    color: '#51cf66',\n    alpha: 1\n  });\n\n  scene.add(floatingText);\n\n  floatingText.tween(\n    { y: floatingText.y - 50, alpha: 0 },\n    { duration: 1000, easing: 'easeOutQuad', onComplete: () => {\n      floatingText.destroy();\n    }}\n  );\n});\n```\n\n### Color Picker\n\n```javascript\nconst colors = ['#e94560', '#51cf66', '#4fc3f7', '#f39c12', '#9b59b6'];\nlet selectedColor = colors[0];\n\ncolors.forEach((color, i) => {\n  const swatch = new Sprite({\n    x: 50 + i * 60,\n    y: 100,\n    width: 50,\n    height: 50,\n    color: color,\n    radius: 8,\n    interactive: true\n  });\n\n  swatch.on('tap', () => {\n    selectedColor = color;\n    // Highlight selected\n    swatch.tween({ scaleX: 1.2, scaleY: 1.2 }, { duration: 200 });\n  });\n\n  scene.add(swatch);\n});\n```\n\n## Entity Layering\n\nTaps detect the topmost interactive entity:\n\n```javascript\n// Create overlapping sprites\nconst bottom = new Sprite({\n  x: 180,\n  y: 140,\n  width: 100,\n  height: 100,\n  color: '#e94560',\n  interactive: true\n});\n\nconst top = new Sprite({\n  x: 220,\n  y: 160,\n  width: 100,\n  height: 100,\n  color: '#4fc3f7',\n  interactive: true\n});\n\nscene.add(bottom);  // Added first (bottom layer)\nscene.add(top);     // Added second (top layer)\n\n// Tapping overlapping area triggers 'top' only\ntop.on('tap', () => console.log('Top tapped'));\nbottom.on('tap', () => console.log('Bottom tapped'));\n```\n\n## Disabling Tap\n\nTemporarily disable tap detection:\n\n```javascript\nsprite.interactive = false;  // Disable taps\nsprite.interactive = true;   // Re-enable taps\n```\n\n## Tips\n\n- **Always set `interactive: true`** on entities you want to be tappable\n- **Must have dimensions** - `width` and `height` are REQUIRED for tap detection. Without dimensions, there's no hit area and taps won't work!\n- **Provide visual feedback** - Users expect immediate response\n- **Use easing functions** - `easeOutBack` and `easeOutQuad` feel great for buttons\n- **Keep tap areas large** - Minimum 44x44 pixels for touch-friendly targets\n- **Test on mobile** - Taps work on both mouse and touch devices\n\n## Common Mistakes\n\n### Missing width and height\n\n```javascript\n// ❌ CRITICAL ERROR - No hit area, tap won't work!\nconst sprite = new Sprite({\n  x: 100,\n  y: 100,\n  interactive: true  // Useless without dimensions\n});\n// Tap events will NEVER fire!\n\n// ✅ CORRECT - Must have dimensions for hit detection\nconst sprite = new Sprite({\n  x: 100,\n  y: 100,\n  width: 80,    // Required!\n  height: 80,   // Required!\n  interactive: true\n});\n```\n\n**This is the #1 mistake!** Interactive sprites MUST have `width` and `height`. Without dimensions, gesture detection has no bounding box to test against, so all touch/mouse events pass through.\n\n### Forgetting interactive flag\n\n```javascript\n// ❌ Wrong - won't receive taps\nconst sprite = new Sprite({ x: 100, y: 100, width: 50, height: 50, color: '#fff' });\nsprite.on('tap', () => console.log('tapped'));\n\n// ✅ Right - interactive enabled\nconst sprite = new Sprite({\n  x: 100, y: 100, width: 50, height: 50, color: '#fff',\n  interactive: true\n});\nsprite.on('tap', () => console.log('tapped'));\n```\n\n### Overlapping tap handlers\n\n```javascript\n// ⚠️  Both handlers will fire\nsprite.on('tap', () => console.log('First handler'));\nsprite.on('tap', () => console.log('Second handler'));\n\n// Use .off() to remove previous handlers if needed\nsprite.off('tap');\nsprite.on('tap', () => console.log('Only handler'));\n```\n\n## Next Steps\n\n- [Drag Gesture](/gestures/drag) - Dragging and moving entities\n- [Swipe Gesture](/gestures/swipe) - Swipe detection\n- [Button Component](/ui/button) - Pre-built button with tap handling"
      }
    ],
    "getting-started": [
      {
        "slug": "getting-started/installation",
        "title": "Installation",
        "description": "Get started with Zap in your project",
        "path": "getting-started/installation.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/getting-started/installation.md",
        "content": "# Installation\n\nZap is a lightweight, gesture-first 2D game engine perfect for creating interactive demos and playable ads. Get up and running in seconds.\n\n## NPM Installation\n\nThe recommended way to install Zap is via npm:\n\n```bash\nnpm install @mode-7/zap\n```\n\nOr using yarn:\n\n```bash\nyarn add @mode-7/zap\n```\n\n## CDN Usage\n\nFor quick prototyping or simple projects, you can use Zap directly from a CDN:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Zap Demo</title>\n</head>\n<body>\n  <script type=\"module\">\n    import { Game, Scene, Sprite } from 'https://esm.sh/@mode-7/zap@0.1.2';\n\n    const game = new Game({ width: 800, height: 600 });\n    const scene = new Scene();\n    game.setScene(scene);\n    game.start();\n  </script>\n</body>\n</html>\n```\n\n## TypeScript Support\n\nZap is written in TypeScript and includes type definitions out of the box. No additional setup required!\n\n```javascript\nimport { Game, Scene, Sprite } from '@mode-7/zap';\n\nconst game = new Game({\n  width: 800,\n  height: 600,\n  backgroundColor: '#0f3460'\n});\n```\n\n## What's Included\n\nWhen you install Zap, you get:\n\n- **Core** - Game instance, Scene management, Camera control\n- **Entities** - Sprite, Text, AnimatedSprite, NinePatch\n- **UI** - Button components\n- **Effects** - Tweening, Particles, Touch trails\n- **Gestures** - Tap, swipe, drag, and long-press recognition\n- **Audio** - Sound and music management\n- **Utils** - Layout helpers, easing functions, asset loading, storage\n\n## Browser Support\n\nZap works in all modern browsers that support:\n- HTML5 Canvas\n- ES6+ JavaScript\n- Modules (import/export)\n\nThis includes the latest versions of Chrome, Firefox, Safari, and Edge.\n\n## Next Steps\n\nNow that Zap is installed, head over to the [Quick Start](/getting-started/quickstart) guide to create your first interactive demo!"
      },
      {
        "slug": "getting-started/quickstart",
        "title": "Quick Start",
        "description": "Build your first interactive demo in 5 minutes",
        "path": "getting-started/quickstart.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/getting-started/quickstart.md",
        "content": "# Quick Start\n\nLet's create your first interactive demo with Zap! You'll learn the basic concepts and have something running in minutes.\n\n## Your First Demo\n\nEvery Zap application needs three things:\n\n1. A **Game** instance\n2. A **Scene** to hold your entities\n3. Some **Entities** (sprites, text, etc.)\n\nHere's the simplest possible example:\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\n// Create the game\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\n// Create a scene\nconst scene = new Scene();\n\n// Create a colored square\nconst square = new Sprite({\n  x: 200,\n  y: 150,\n  width: 60,\n  height: 60,\n  color: '#e94560'\n});\n\n// Add square to scene\nscene.add(square);\n\n// Set the scene and start\ngame.setScene(scene);\ngame.start();\n```\n\n## Making It Interactive\n\nNow let's make the square respond to taps with a smooth animation:\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\n// Create an interactive square\nconst square = new Sprite({\n  x: 200,\n  y: 150,\n  width: 60,\n  height: 60,\n  color: '#e94560',\n  interactive: true  // Enable gestures\n});\n\n// Respond to taps\nsquare.on('tap', () => {\n  // Animate rotation and scale\n  square.tween(\n    { rotation: square.rotation + Math.PI * 2, scaleX: 1.5, scaleY: 1.5 },\n    { duration: 400, easing: 'easeOutBack' }\n  ).then(() => {\n    // Return to normal size\n    square.tween(\n      { scaleX: 1, scaleY: 1 },\n      { duration: 300, easing: 'easeInOut' }\n    );\n  });\n});\n\nscene.add(square);\ngame.setScene(scene);\ngame.start();\n```\n\n## Key Concepts\n\n### Game Instance\n\nThe `Game` class manages your canvas, the game loop, and scene transitions. You create one at the start:\n\n```javascript\nconst game = new Game({\n  width: 800,\n  height: 600,\n  backgroundColor: '#0f3460'\n});\n```\n\n### Scene\n\nA `Scene` is a container for all your game entities. Think of it like a level or screen:\n\n```javascript\nconst scene = new Scene();\nscene.add(sprite);\ngame.setScene(scene);\n```\n\n### Entities\n\nEntities are the visual elements in your game. The most common is `Sprite`:\n\n```javascript\nconst sprite = new Sprite({\n  x: 100,\n  y: 100,\n  width: 50,\n  height: 50,\n  color: '#667eea'\n});\n```\n\n### Gestures\n\nMake entities interactive by setting `interactive: true` and listening for gesture events:\n\n```javascript\nsprite.interactive = true;\nsprite.on('tap', () => console.log('Tapped!'));\nsprite.on('drag', (e) => {\n  sprite.x = e.x;\n  sprite.y = e.y;\n});\n```\n\n### Tweening\n\nAnimate properties smoothly with the `tween` method:\n\n```javascript\nsprite.tween(\n  { x: 400, rotation: Math.PI },\n  { duration: 1000, easing: 'easeInOutQuad' }\n);\n```\n\n## Next Steps\n\nYou now know the basics! Explore these topics next:\n\n- [Architecture](/core/architecture) - Understand how Zap is structured\n- [Game Configuration](/core/game) - Learn all Game options\n- [Scenes](/core/scenes) - Manage multiple scenes and transitions\n- [Sprites](/visual/sprite) - Deep dive into visual entities"
      }
    ],
    "general": [
      {
        "slug": "index",
        "title": "index",
        "description": "",
        "path": "index.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/index.md",
        "content": "# Zap Game Engine Documentation Index\n\nThis index provides a complete overview of all Zap documentation. Each section includes a description and direct link to the documentation.\n\n## Getting Started\n\n- **[Installation](getting-started/installation.md)** - Install Zap via npm or CDN\n- **[Quickstart](getting-started/quickstart.md)** - Build your first Zap game in 5 minutes\n\n## Core Concepts\n\n- **[Architecture](core/architecture.md)** - Understanding Zap's architecture and structure\n- **[Game Configuration](core/game.md)** - Configure your Game instance with all available options (canvas size, responsive mode, background color, etc.)\n- **[Scenes](core/scenes.md)** - Scene management, transitions, backgrounds, and lifecycle\n- **[Entities](core/entities.md)** - Entity system, lifecycle, hierarchy, and properties\n- **[Camera](core/camera.md)** - Camera controls: follow entities, zoom, shake effects\n\n## Visual Elements\n\n- **[Shapes](visual/shapes.md)** - Draw rectangles, circles, and rounded shapes with Sprite\n- **[Sprites](visual/sprites.md)** - Image sprites, loading, and rendering\n- **[Sprite Animation](visual/animation.md)** - Frame-by-frame sprite sheet animations\n- **[Text](visual/text.md)** - Text rendering with custom fonts and alignment\n\n## Animation & Effects\n\n- **[Tweening](animation/tweening.md)** - Smooth property animations with easing functions\n- **[Particles](animation/particles.md)** - Particle effects and emitters for visual feedback\n- **[Touch Trail](animation/touch-trail.md)** - Visual touch/mouse trail effect\n\n## Gestures & Input\n\n- **[Tap/Click](gestures/tap.md)** - Tap and click gesture detection\n- **[Drag](gestures/drag.md)** - Drag gesture for moving entities\n- **[Swipe](gestures/swipe.md)** - Swipe gesture for directional input\n\n## UI Components\n\n- **[Button](ui/button.md)** - Interactive button component with states\n- **[NinePatch](ui/ninepatch.md)** - Scalable UI panels with 9-slice scaling\n\n## Audio\n\n- **[Sound Effects](audio/sound-effects.md)** - Playing sound effects\n- **[Music](audio/music.md)** - Background music playback and looping\n- **[Volume Control](audio/volume.md)** - Volume control and muting\n\n## Utilities\n\n- **[Easing Functions](utilities/easing.md)** - 31 easing functions for animations (easeInOut, bounce, elastic, etc.)\n- **[Asset Loader](utilities/asset-loader.md)** - Loading and caching images\n- **[Fonts](utilities/fonts.md)** - Loading Google Fonts and custom fonts\n- **[Layout Helpers](utilities/layout.md)** - Grid, circle, row, and column layout utilities\n- **[Math Utilities](utilities/math.md)** - clamp, lerp, random, distance, and angle calculations\n- **[Storage](utilities/storage.md)** - LocalStorage wrapper for saving game data\n- **[Timers](utilities/timers.md)** - Delay and interval utilities with auto-cleanup\n\n## Advanced Features\n\n- **[Collision Detection](advanced/collision-detection.md)** - Automatic AABB collision detection system with events\n\n---\n\n## Quick Navigation by Use Case\n\n### Building a Game\n1. Start with [Quickstart](getting-started/quickstart.md)\n2. Configure your [Game](core/game.md) and [Scenes](core/scenes.md)\n3. Add [Sprites](visual/sprites.md) or [Shapes](visual/shapes.md)\n4. Implement [Gestures](gestures/tap.md) for interaction\n5. Add [Collision Detection](advanced/collision-detection.md) for gameplay\n\n### Adding Visual Polish\n- [Tweening](animation/tweening.md) for smooth animations\n- [Particles](animation/particles.md) for effects\n- [Easing Functions](utilities/easing.md) for animation curves\n- [Camera](core/camera.md) for shake and zoom effects\n\n### Creating UI\n- [Text](visual/text.md) for labels and scores\n- [Button](ui/button.md) for interactive elements\n- [NinePatch](ui/ninepatch.md) for scalable panels\n- [Layout Helpers](utilities/layout.md) for positioning\n\n### Adding Interactivity\n- [Tap](gestures/tap.md) for buttons and selections\n- [Drag](gestures/drag.md) for moving objects\n- [Swipe](gestures/swipe.md) for directional controls\n- [Collision Detection](advanced/collision-detection.md) for gameplay mechanics\n\n### Managing Game State\n- [Scenes](core/scenes.md) for different game screens\n- [Storage](utilities/storage.md) for saving progress\n- [Timers](utilities/timers.md) for game logic timing\n\n---\n\n## API Quick Reference\n\n### Core Classes\n- `Game` - Main game instance and loop\n- `Scene` - Container for entities with lifecycle\n- `Entity` - Base class for all game objects\n- `Sprite` - Visual entities (images, shapes)\n- `Text` - Text rendering\n- `Camera` - Viewport control\n\n### Common Patterns\n\n**Create a game:**\n```javascript\nimport { Game, Scene } from '@mode-7/zap';\nconst game = new Game({ parent: '#app', responsive: true });\nconst scene = new Scene({ backgroundColor: '#1a1a2e' });\ngame.setScene(scene);\ngame.start();\n```\n\n**Add a sprite:**\n```javascript\nconst sprite = new Sprite({ x: 100, y: 100, width: 50, height: 50, color: '#ff0000' });\nscene.add(sprite);\n```\n\n**Handle tap:**\n```javascript\nsprite.interactive = true;\nsprite.on('tap', () => console.log('Tapped!'));\n```\n\n**Animate:**\n```javascript\nsprite.tween({ x: 200, rotation: Math.PI }, { duration: 1000, easing: 'easeInOutQuad' });\n```\n\n**Detect collisions:**\n```javascript\nsprite.checkCollisions = true;\nsprite.collisionTags = ['enemy'];\nsprite.on('collisionenter', (event) => console.log('Hit:', event.other));\n```\n\n---\n\n## Version\nThis documentation is for **Zap v0.1.3**\n\nLast updated: 2025-10-19"
      }
    ],
    "ui": [
      {
        "slug": "ui/button",
        "title": "Button",
        "description": "Interactive button component with states",
        "path": "ui/button.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/ui/button.md",
        "content": "# Button\n\nThe Button component provides an easy-to-use interactive button with automatic state management, visual feedback, and click handling.\n\n## Basic Button\n\nCreate a button with text and click handler:\n\n```codemirror\nimport { Game, Scene, Button, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst button = new Button({\n  x: 200,\n  y: 150,\n  text: 'Click Me!',\n  onClick: () => {\n    console.log('Button clicked!');\n    label.text = 'Clicked!';\n    label.color = '#51cf66';\n  }\n});\n\nconst label = new Text({\n  text: 'Click the button',\n  x: 200,\n  y: 220,\n  fontSize: 14,\n  color: '#888',\n  align: 'center'\n});\n\nscene.add(button);\nscene.add(label);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Button Options\n\nCustomize button appearance:\n\n```javascript\nconst button = new Button({\n  x: 200,\n  y: 150,\n  text: 'Submit',\n\n  // Size\n  width: 140,\n  height: 50,\n\n  // Colors\n  backgroundColor: '#4fc3f7',    // Default state\n  hoverColor: '#6dd5fa',         // Hover state (visual only)\n  pressColor: '#38a3d1',         // Pressed state\n  textColor: '#ffffff',          // Text color\n\n  // Text\n  fontSize: 16,\n\n  // Shape\n  radius: 8,                     // Corner radius\n\n  // Click handler\n  onClick: () => {\n    console.log('Submit clicked');\n  }\n});\n```\n\n## Button States\n\nButtons automatically handle three visual states:\n\n### Default State\n\nNormal appearance when not interacted with.\n\n### Hover State\n\nVisual indication when mouse is over button (currently uses press for visual feedback).\n\n### Pressed State\n\nDarker color while button is being pressed.\n\n## Multiple Buttons\n\n```codemirror\nimport { Game, Scene, Button, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst status = new Text({\n  text: 'Choose an option',\n  x: 200,\n  y: 50,\n  fontSize: 16,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nconst yesBtn = new Button({\n  x: 130,\n  y: 150,\n  width: 100,\n  height: 45,\n  text: 'Yes',\n  backgroundColor: '#51cf66',\n  hoverColor: '#69db7c',\n  pressColor: '#40c057',\n  onClick: () => {\n    status.text = 'You chose Yes';\n    status.color = '#51cf66';\n  }\n});\n\nconst noBtn = new Button({\n  x: 270,\n  y: 150,\n  width: 100,\n  height: 45,\n  text: 'No',\n  backgroundColor: '#e94560',\n  hoverColor: '#ff547c',\n  pressColor: '#d13650',\n  onClick: () => {\n    status.text = 'You chose No';\n    status.color = '#e94560';\n  }\n});\n\nscene.add(status);\nscene.add(yesBtn);\nscene.add(noBtn);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Change Button Text\n\nUpdate button text dynamically:\n\n```javascript\nconst counter = new Button({\n  x: 200,\n  y: 150,\n  text: 'Count: 0'\n});\n\nlet count = 0;\n\ncounter.onClick = () => {\n  count++;\n  counter.setText(`Count: ${count}`);\n};\n```\n\n## Enable/Disable\n\nControl button interactivity:\n\n```codemirror\nimport { Game, Scene, Button } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst actionBtn = new Button({\n  x: 200,\n  y: 120,\n  text: 'Action',\n  backgroundColor: '#4fc3f7',\n  onClick: () => {\n    console.log('Action performed!');\n    actionBtn.disable();\n\n    // Re-enable after 2 seconds\n    setTimeout(() => {\n      actionBtn.enable();\n    }, 2000);\n  }\n});\n\nconst toggleBtn = new Button({\n  x: 200,\n  y: 180,\n  width: 140,\n  height: 45,\n  text: 'Toggle Action',\n  backgroundColor: '#f39c12',\n  onClick: () => {\n    if (actionBtn.interactive) {\n      actionBtn.disable();\n      toggleBtn.setText('Enable Action');\n    } else {\n      actionBtn.enable();\n      toggleBtn.setText('Disable Action');\n    }\n  }\n});\n\nscene.add(actionBtn);\nscene.add(toggleBtn);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Common Patterns\n\n### Menu Buttons\n\nCreate a vertical menu:\n\n```javascript\nconst menuOptions = ['Play', 'Options', 'Quit'];\nlet selectedOption = null;\n\nmenuOptions.forEach((option, i) => {\n  const button = new Button({\n    x: 200,\n    y: 100 + i * 60,\n    width: 160,\n    height: 50,\n    text: option,\n    backgroundColor: '#16213e',\n    pressColor: '#0f1626',\n    onClick: () => {\n      selectedOption = option;\n      console.log('Selected:', option);\n\n      // Navigate to different scenes based on choice\n      switch(option) {\n        case 'Play': game.setScene(gameScene); break;\n        case 'Options': game.setScene(optionsScene); break;\n        case 'Quit': console.log('Quitting...'); break;\n      }\n    }\n  });\n\n  scene.add(button);\n});\n```\n\n### Icon Buttons\n\nUse single characters or symbols:\n\n```javascript\nconst soundBtn = new Button({\n  x: 50,\n  y: 50,\n  width: 45,\n  height: 45,\n  text: '🔊',\n  fontSize: 20,\n  backgroundColor: '#16213e',\n  onClick: () => {\n    // Toggle sound\n    soundBtn.setText(soundOn ? '🔇' : '🔊');\n    soundOn = !soundOn;\n  }\n});\n```\n\n### Confirmation Dialog\n\nTwo-button confirmation:\n\n```javascript\nconst confirmDialog = new Scene();\n\nconst message = new Text({\n  text: 'Delete this item?',\n  x: 200, y: 120,\n  fontSize: 16,\n  align: 'center'\n});\n\nconst confirmBtn = new Button({\n  x: 150, y: 180,\n  width: 80, height: 40,\n  text: 'Delete',\n  backgroundColor: '#e94560',\n  onClick: () => {\n    // Perform deletion\n    deleteItem();\n    game.setScene(mainScene);\n  }\n});\n\nconst cancelBtn = new Button({\n  x: 250, y: 180,\n  width: 80, height: 40,\n  text: 'Cancel',\n  backgroundColor: '#888',\n  onClick: () => {\n    game.setScene(mainScene);\n  }\n});\n\nconfirmDialog.add(message);\nconfirmDialog.add(confirmBtn);\nconfirmDialog.add(cancelBtn);\n```\n\n### Loading State\n\nDisable during async operations:\n\n```javascript\nconst submitBtn = new Button({\n  x: 200, y: 200,\n  text: 'Submit',\n  onClick: async () => {\n    // Disable during operation\n    submitBtn.disable();\n    submitBtn.setText('Loading...');\n\n    try {\n      await performAsyncOperation();\n      submitBtn.setText('Success!');\n      setTimeout(() => {\n        submitBtn.enable();\n        submitBtn.setText('Submit');\n      }, 2000);\n    } catch (error) {\n      submitBtn.setText('Error!');\n      submitBtn.enable();\n    }\n  }\n});\n```\n\n### Button with Counter\n\nShow a numeric value:\n\n```javascript\nlet lives = 3;\n\nconst livesBtn = new Button({\n  x: 350, y: 30,\n  width: 80, height: 35,\n  text: `Lives: ${lives}`,\n  backgroundColor: '#e94560',\n  onClick: () => {\n    // Buttons don't have to just be clicked\n    // This could update automatically from game logic\n  }\n});\n\n// Update from game events\nplayer.on('hit', () => {\n  lives--;\n  livesBtn.setText(`Lives: ${lives}`);\n\n  if (lives <= 0) {\n    livesBtn.setText('Game Over');\n    livesBtn.disable();\n  }\n});\n```\n\n### Styled Button Groups\n\nCreate consistent button groups:\n\n```javascript\nfunction createButton(text, x, y, color) {\n  return new Button({\n    x, y,\n    width: 90,\n    height: 40,\n    text,\n    backgroundColor: color,\n    pressColor: darken(color),  // Implement darken function\n    fontSize: 14,\n    radius: 6\n  });\n}\n\nconst redBtn = createButton('Red', 100, 150, '#e94560');\nconst greenBtn = createButton('Green', 200, 150, '#51cf66');\nconst blueBtn = createButton('Blue', 300, 150, '#4fc3f7');\n```\n\n## Button Events\n\nButtons emit standard tap events:\n\n```javascript\nconst button = new Button({\n  x: 200, y: 150,\n  text: 'Click'\n});\n\n// Use onClick option (recommended)\nbutton.onClick = () => {\n  console.log('Clicked via onClick');\n};\n\n// Or listen to tap event\nbutton.on('tap', () => {\n  console.log('Clicked via tap event');\n});\n\n// Drag events also work\nbutton.on('dragstart', () => {\n  console.log('Press started');\n});\n\nbutton.on('dragend', () => {\n  console.log('Press ended');\n});\n```\n\n## Styling Tips\n\n### Color Schemes\n\nGood color combinations:\n\n```javascript\n// Primary action (blue)\n{ backgroundColor: '#4fc3f7', pressColor: '#38a3d1' }\n\n// Success (green)\n{ backgroundColor: '#51cf66', pressColor: '#40c057' }\n\n// Danger (red)\n{ backgroundColor: '#e94560', pressColor: '#d13650' }\n\n// Warning (orange)\n{ backgroundColor: '#f39c12', pressColor: '#d68910' }\n\n// Secondary (gray)\n{ backgroundColor: '#888', pressColor: '#666' }\n```\n\n### Size Guidelines\n\nRecommended button sizes:\n\n```javascript\n// Small button\n{ width: 80, height: 35, fontSize: 12 }\n\n// Medium button (default)\n{ width: 120, height: 50, fontSize: 16 }\n\n// Large button\n{ width: 180, height: 60, fontSize: 18 }\n\n// Icon button (square)\n{ width: 45, height: 45, fontSize: 20 }\n```\n\n## Accessibility\n\nMake buttons touch-friendly:\n\n```javascript\n// Minimum 44x44px for touch targets\nconst button = new Button({\n  x: 200, y: 150,\n  width: 100,  // At least 44px\n  height: 44,   // At least 44px\n  text: 'Tap Me'\n});\n```\n\n## Tips\n\n- **Use onClick** - Simplest way to handle clicks\n- **Disable during operations** - Prevent double-clicks\n- **Provide feedback** - Users expect immediate visual response\n- **Clear labels** - Use action verbs: \"Save\", \"Delete\", \"Continue\"\n- **Consistent sizing** - Use same dimensions for related buttons\n\n## Common Mistakes\n\n### Forgetting to add to scene\n\n```javascript\n// ❌ Wrong - button created but not visible\nconst button = new Button({ x: 200, y: 150, text: 'Click' });\n\n// ✅ Right - add to scene\nconst button = new Button({ x: 200, y: 150, text: 'Click' });\nscene.add(button);\n```\n\n### Not handling disabled state\n\n```javascript\n// ❌ Wrong - can click disabled button\nbutton.disable();\nbutton.on('tap', () => {\n  // This still fires!\n});\n\n// ✅ Right - check interactive state\nbutton.on('tap', () => {\n  if (!button.interactive) return;\n  // Handle click\n});\n\n// Or better: use onClick which respects disabled state\nbutton.onClick = () => {\n  // This won't fire when disabled\n};\n```\n\n## Next Steps\n\n- [NinePatch](/ui/ninepatch) - Scalable UI panels\n- [Tap Gesture](/gestures/tap) - Understanding tap detection\n- [Tweening](/animation/tweening) - Animate buttons"
      },
      {
        "slug": "ui/ninepatch",
        "title": "NinePatch",
        "description": "Scalable UI panels with preserved corners",
        "path": "ui/ninepatch.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/ui/ninepatch.md",
        "content": "# NinePatch\n\nNinePatch sprites scale UI elements like panels and dialogs while preserving corner and edge details. The image is divided into 9 sections, with corners staying fixed and edges/center stretching.\n\n## What is Nine-Patch?\n\nA nine-patch image divides a texture into 9 regions:\n\n```\n┌─────┬─────────┬─────┐\n│  1  │    2    │  3  │  ← Top (fixed height)\n├─────┼─────────┼─────┤\n│  4  │    5    │  6  │  ← Middle (stretches)\n├─────┼─────────┼─────┤\n│  7  │    8    │  9  │  ← Bottom (fixed height)\n└─────┴─────────┴─────┘\n  ↑       ↑       ↑\nFixed  Stretch  Fixed\nwidth   width   width\n```\n\n- **Corners (1, 3, 7, 9)**: Never stretch, maintain original size\n- **Edges (2, 4, 6, 8)**: Stretch in one direction only\n- **Center (5)**: Stretches in both directions\n\nThis allows UI elements to scale to any size without distortion.\n\n## Basic NinePatch\n\nCreate a nine-patch panel that animates to show corners staying fixed:\n\n```codemirror\nimport { Game, Scene, NinePatch, Text, Sprite } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\n// Create a nine-patch image programmatically\nconst canvas = document.createElement('canvas');\ncanvas.width = 64;\ncanvas.height = 64;\nconst ctx = canvas.getContext('2d');\n\n// Background\nctx.fillStyle = '#1a1a2e';\nctx.fillRect(0, 0, 64, 64);\n\n// Border\nctx.strokeStyle = '#4fc3f7';\nctx.lineWidth = 2;\nctx.strokeRect(1, 1, 62, 62);\n\n// Decorative corners (16x16 patches)\nctx.fillStyle = '#4fc3f7';\nctx.beginPath();\nctx.arc(8, 8, 6, 0, Math.PI * 2);\nctx.fill();\nctx.beginPath();\nctx.arc(56, 8, 6, 0, Math.PI * 2);\nctx.fill();\nctx.beginPath();\nctx.arc(8, 56, 6, 0, Math.PI * 2);\nctx.fill();\nctx.beginPath();\nctx.arc(56, 56, 6, 0, Math.PI * 2);\nctx.fill();\n\n// Inner border accent\nctx.strokeStyle = '#2ecc71';\nctx.lineWidth = 1;\nctx.strokeRect(4, 4, 56, 56);\n\nconst img = new Image();\nimg.src = canvas.toDataURL();\n\nimg.onload = () => {\n  // Create nine-patch panel\n  const panel = new NinePatch({\n    x: 200, y: 150,\n    width: 180, height: 140,\n    image: img,\n    corners: 16  // 16px corners stay fixed\n  });\n\n  const title = new Text({\n    text: 'Dialog Panel',\n    x: 200, y: 110,\n    fontSize: 18,\n    color: '#4fc3f7',\n    align: 'center'\n  });\n\n  const description = new Text({\n    text: 'Corners stay sharp',\n    x: 200, y: 140,\n    fontSize: 13,\n    color: '#aaa',\n    align: 'center'\n  });\n\n  const button = new Sprite({\n    x: 200, y: 175,\n    width: 100, height: 30,\n    color: '#2ecc71',\n    radius: 6\n  });\n\n  const buttonText = new Text({\n    text: 'OK',\n    x: 200, y: 175,\n    fontSize: 14,\n    color: '#ffffff',\n    align: 'center',\n    baseline: 'middle'\n  });\n\n  const subtitle = new Text({\n    text: 'Watch the decorative corners stay fixed',\n    x: 200, y: 260,\n    fontSize: 12,\n    color: '#888',\n    align: 'center'\n  });\n\n  // Animate size - corners won't distort!\n  let growing = true;\n  function animate() {\n    const targetWidth = growing ? 280 : 180;\n    const targetHeight = growing ? 200 : 140;\n\n    panel.tween(\n      { width: targetWidth, height: targetHeight },\n      { duration: 2000, easing: 'easeInOutQuad', onComplete: () => { growing = !growing; animate(); } }\n    );\n\n    button.tween({ y: growing ? 205 : 175 }, { duration: 2000, easing: 'easeInOutQuad' });\n    buttonText.tween({ y: growing ? 205 : 175 }, { duration: 2000, easing: 'easeInOutQuad' });\n    description.tween({ y: growing ? 155 : 140 }, { duration: 2000, easing: 'easeInOutQuad' });\n  }\n\n  animate();\n\n  scene.add(panel);\n  scene.add(title);\n  scene.add(description);\n  scene.add(button);\n  scene.add(buttonText);\n  scene.add(subtitle);\n};\n\ngame.setScene(scene);\ngame.start();\n```\n\nWith an actual NinePatch image:\n\n```javascript\nimport { NinePatch } from '@mode-7/zap';\n\nconst panel = new NinePatch({\n  x: 200,\n  y: 150,\n  width: 300,      // Can be any width\n  height: 200,     // Can be any height\n  image: '/ui/panel.png',  // Nine-patch image\n  corners: 16      // Corner size in pixels\n});\n\nscene.add(panel);\n```\n\n## Corner Size\n\nThe `corners` parameter defines the size of the fixed corner regions:\n\n```javascript\n// Small corners (8px)\nconst panel1 = new NinePatch({\n  x: 100, y: 100,\n  width: 200, height: 150,\n  image: '/ui/panel.png',\n  corners: 8\n});\n\n// Medium corners (16px) - typical\nconst panel2 = new NinePatch({\n  x: 100, y: 100,\n  width: 200, height: 150,\n  image: '/ui/panel.png',\n  corners: 16\n});\n\n// Large corners (32px)\nconst panel3 = new NinePatch({\n  x: 100, y: 100,\n  width: 200, height: 150,\n  image: '/ui/panel.png',\n  corners: 32\n});\n```\n\n## Creating Nine-Patch Images\n\n### Image Requirements\n\n1. **Square corners**: Corner regions must be equal size\n2. **Symmetrical**: Top/bottom and left/right should match\n3. **Repeatable edges**: Edge graphics should tile seamlessly\n4. **Stretchable center**: Center content should handle stretching\n\n### Example Structure\n\nFor a panel with 16px corners from a 48x48 source image:\n\n```\nSource image: 48x48 pixels\n- Corners: 16x16px each (4 corners)\n- Edges: 16px wide/tall, center 16px long\n- Center: 16x16px\n```\n\n## Common Patterns\n\n### Dialog Box\n\nScalable dialog with content:\n\n```javascript\nconst dialog = new NinePatch({\n  x: 200,\n  y: 150,\n  width: 320,\n  height: 240,\n  image: '/ui/dialog-panel.png',\n  corners: 20\n});\n\nconst title = new Text({\n  text: 'Warning',\n  x: 200,\n  y: 80,\n  fontSize: 18,\n  color: '#fff',\n  align: 'center'\n});\n\nconst message = new Text({\n  text: 'Are you sure you want to continue?',\n  x: 200,\n  y: 150,\n  fontSize: 14,\n  color: '#ccc',\n  align: 'center'\n});\n\nscene.add(dialog);\nscene.add(title);\nscene.add(message);\n```\n\n### Tooltip\n\nSmall nine-patch for tooltips:\n\n```javascript\nconst tooltip = new NinePatch({\n  x: mouseX,\n  y: mouseY - 40,\n  width: 120,\n  height: 40,\n  image: '/ui/tooltip.png',\n  corners: 8\n});\n\nconst tooltipText = new Text({\n  text: 'Health Potion',\n  fontSize: 12,\n  color: '#fff',\n  align: 'center',\n  baseline: 'middle'\n});\n\ntooltip.addChild(tooltipText);\nscene.add(tooltip);\n```\n\n### Progress Bar Background\n\nUse for resizable progress bar containers:\n\n```javascript\nconst progressBg = new NinePatch({\n  x: 200,\n  y: 50,\n  width: 300,\n  height: 30,\n  image: '/ui/progress-bg.png',\n  corners: 8\n});\n\nconst progressFill = new Sprite({\n  x: 200,\n  y: 50,\n  width: 150,  // 50% progress\n  height: 26,\n  color: '#51cf66',\n  anchorX: 0.5,\n  anchorY: 0.5\n});\n\nscene.add(progressBg);\nscene.add(progressFill);\n```\n\n### Inventory Slots\n\nGrid of scalable slots:\n\n```javascript\nfor (let row = 0; row < 3; row++) {\n  for (let col = 0; col < 5; col++) {\n    const slot = new NinePatch({\n      x: 100 + col * 65,\n      y: 100 + row * 65,\n      width: 60,\n      height: 60,\n      image: '/ui/inventory-slot.png',\n      corners: 12,\n      interactive: true\n    });\n\n    slot.on('tap', () => {\n      console.log(`Slot ${row},${col} clicked`);\n    });\n\n    scene.add(slot);\n  }\n}\n```\n\n### Speech Bubble\n\nNine-patch for character dialogue:\n\n```javascript\nconst bubble = new NinePatch({\n  x: character.x,\n  y: character.y - 80,\n  width: 200,\n  height: 60,\n  image: '/ui/speech-bubble.png',\n  corners: 16\n});\n\nconst dialogue = new Text({\n  text: 'Hello, traveler!',\n  fontSize: 14,\n  color: '#000',\n  align: 'center',\n  baseline: 'middle'\n});\n\nbubble.addChild(dialogue);\nscene.add(bubble);\n```\n\n### Dynamic Sizing\n\nResize nine-patch based on content:\n\n```javascript\nconst text = 'This is a message that might be very long or very short';\n\n// Measure text (approximate)\nconst textWidth = text.length * 8;  // Rough estimate\nconst padding = 40;\n\nconst panel = new NinePatch({\n  x: 200,\n  y: 150,\n  width: Math.max(200, Math.min(380, textWidth + padding)),\n  height: 100,\n  image: '/ui/panel.png',\n  corners: 16\n});\n\nconst label = new Text({\n  text: text,\n  fontSize: 14,\n  align: 'center',\n  baseline: 'middle'\n});\n\npanel.addChild(label);\nscene.add(panel);\n```\n\n## Combining with Buttons\n\nButtons inside panels:\n\n```javascript\nconst settingsPanel = new NinePatch({\n  x: 200,\n  y: 150,\n  width: 280,\n  height: 200,\n  image: '/ui/panel.png',\n  corners: 20\n});\n\nconst saveButton = new Button({\n  x: 200,\n  y: 180,\n  text: 'Save Settings',\n  onClick: () => {\n    saveSettings();\n  }\n});\n\nscene.add(settingsPanel);\nscene.add(saveButton);\n```\n\n## Animated Panels\n\nAnimate nine-patch size:\n\n```javascript\nconst panel = new NinePatch({\n  x: 200,\n  y: 150,\n  width: 100,   // Start small\n  height: 80,\n  image: '/ui/panel.png',\n  corners: 16,\n  scaleX: 0,\n  scaleY: 0\n});\n\nscene.add(panel);\n\n// Animate in\npanel.tween(\n  { scaleX: 1, scaleY: 1 },\n  { duration: 300, easing: 'easeOutBack' }\n);\n\n// Then expand\npanel.tween(\n  { width: 300, height: 200 },\n  { duration: 400, easing: 'easeOutQuad', delay: 300 }\n);\n```\n\n## Design Tips\n\n### Creating Nine-Patch Graphics\n\n1. **Start with corners**: Design distinctive corners first\n2. **Make edges tileable**: Ensure edges repeat seamlessly\n3. **Test at multiple sizes**: Check how it looks small and large\n4. **Avoid detail in center**: Center will stretch, keep it simple\n5. **Use consistent border width**: All edges should be the same thickness\n\n### Good Use Cases\n\n- Dialog boxes\n- Panels and windows\n- Tooltips\n- Progress bar containers\n- Inventory slots\n- Speech bubbles\n- Button backgrounds (alternative to solid color)\n\n### Bad Use Cases\n\n- Small icons (just use regular sprites)\n- Decorative elements that shouldn't stretch\n- Images with important center content\n- Complex patterns that don't tile well\n\n## Properties\n\nNinePatch extends Sprite, so it has all sprite properties:\n\n```javascript\nconst panel = new NinePatch({\n  x: 200,\n  y: 150,\n  width: 300,\n  height: 200,\n  image: '/ui/panel.png',\n  corners: 16,\n\n  // Sprite properties also work\n  alpha: 0.9,\n  rotation: 0,\n  scaleX: 1,\n  scaleY: 1,\n  interactive: true,\n  anchorX: 0.5,\n  anchorY: 0.5\n});\n```\n\n## Performance\n\n- **Efficient rendering**: Uses single image with 9 draw calls\n- **Better than tiling**: More efficient than creating tile grid\n- **Cache friendly**: Source image stays in memory\n- **Scale vs Size**: Changing `width`/`height` is better than `scaleX`/`scaleY`\n\n## Common Mistakes\n\n### Wrong corner size\n\n```javascript\n// ❌ Wrong - corners too large for image\nconst panel = new NinePatch({\n  image: '/ui/panel-24x24.png',  // 24x24 image\n  corners: 16  // Corners would overlap!\n});\n\n// ✅ Right - corners fit within image\nconst panel = new NinePatch({\n  image: '/ui/panel-48x48.png',  // 48x48 image\n  corners: 16  // Leaves 16px for center\n});\n```\n\n### Scaling instead of resizing\n\n```javascript\n// ❌ Wrong - scales entire nine-patch (defeats the purpose)\npanel.scaleX = 2;\npanel.scaleY = 2;\n\n// ✅ Right - resize to preserve corner detail\npanel.width *= 2;\npanel.height *= 2;\n```\n\n### Forgetting to set image\n\n```javascript\n// ❌ Wrong - no image provided\nconst panel = new NinePatch({\n  x: 200, y: 150,\n  width: 200, height: 150,\n  corners: 16\n});\n// Will render nothing or fall back to sprite behavior\n\n// ✅ Right - provide image\nconst panel = new NinePatch({\n  x: 200, y: 150,\n  width: 200, height: 150,\n  image: '/ui/panel.png',\n  corners: 16\n});\n```\n\n## Alternative: CSS-Style Borders\n\nIf you don't have nine-patch images, you can create similar effects with Sprite borders:\n\n```javascript\n// Use colored sprite with rounded corners\nconst panel = new Sprite({\n  x: 200,\n  y: 150,\n  width: 300,\n  height: 200,\n  color: '#16213e',\n  radius: 12  // Rounded corners simulate nine-patch effect\n});\n```\n\n## Next Steps\n\n- [Button](/ui/button) - Interactive button component\n- [Sprites](/visual/sprites) - Understanding sprite rendering\n- [Text](/visual/text) - Adding text to panels"
      }
    ],
    "utilities": [
      {
        "slug": "utilities/asset-loader",
        "title": "Asset Loader",
        "description": "Load and cache images efficiently",
        "path": "utilities/asset-loader.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/utilities/asset-loader.md",
        "content": "# Asset Loader\n\nThe AssetLoader efficiently loads and caches images, preventing duplicate requests and managing loading states. It provides both single and batch loading capabilities.\n\n## Global Asset Loader\n\nZap provides a global asset loader instance:\n\n```javascript\nimport { assetLoader } from '@mode-7/zap';\n\n// Load an image\nawait assetLoader.loadImage('player', '/images/player.png');\n\n// Get the loaded image\nconst playerImage = assetLoader.getImage('player');\n```\n\n## Load Single Image\n\nLoad one image at a time:\n\n```codemirror\nimport { Game, Scene, Sprite, assetLoader } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\n// Load image before using it\nassetLoader.loadImage('robot', '../assets/robot.png').then(() => {\n  const sprite = new Sprite({\n    x: 200,\n    y: 150,\n    width: 64,\n    height: 64,\n    image: assetLoader.getImage('robot')\n  });\n\n  scene.add(sprite);\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Load Multiple Images\n\nBatch load several images at once:\n\n```javascript\nimport { assetLoader } from '@mode-7/zap';\n\nawait assetLoader.loadImages({\n  player: '/images/player.png',\n  enemy: '/images/enemy.png',\n  background: '/images/background.png',\n  coin: '/images/coin.png'\n});\n\n// All images are now loaded and cached\nconst playerImg = assetLoader.getImage('player');\nconst enemyImg = assetLoader.getImage('enemy');\n```\n\n## Loading Screen\n\nCreate a loading screen before starting your game:\n\n```codemirror\nimport { Game, Scene, Sprite, Text, assetLoader } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\n// Loading scene\nconst loadingScene = new Scene();\n\nconst loadingText = new Text({\n  text: 'Loading...',\n  x: 200,\n  y: 150,\n  fontSize: 18,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nloadingScene.add(loadingText);\ngame.setScene(loadingScene);\ngame.start();\n\n// Load all assets\nassetLoader.loadImages({\n  player: '../assets/player.png',\n  enemy: '../assets/enemy.png',\n  background: '../assets/background.png'\n}).then(() => {\n  // Switch to game scene\n  const gameScene = new Scene();\n\n  const player = new Sprite({\n    x: 200,\n    y: 150,\n    width: 64,\n    height: 64,\n    image: assetLoader.getImage('player')\n  });\n\n  gameScene.add(player);\n  game.setScene(gameScene);\n});\n```\n\n## Progress Tracking\n\nTrack loading progress:\n\n```javascript\nconst assets = {\n  player: '/images/player.png',\n  enemy1: '/images/enemy1.png',\n  enemy2: '/images/enemy2.png',\n  background: '/images/background.png'\n};\n\nconst total = Object.keys(assets).length;\nlet loaded = 0;\n\n// Load with progress tracking\nconst promises = Object.entries(assets).map(async ([key, url]) => {\n  const image = await assetLoader.loadImage(key, url);\n  loaded++;\n\n  // Update progress\n  const progress = (loaded / total) * 100;\n  console.log(`Loading: ${progress}%`);\n  loadingText.text = `Loading: ${Math.floor(progress)}%`;\n\n  return image;\n});\n\nawait Promise.all(promises);\n```\n\n## Check if Loaded\n\nCheck whether an asset is already loaded:\n\n```javascript\nif (assetLoader.hasImage('player')) {\n  // Image is loaded, safe to use\n  const playerImg = assetLoader.getImage('player');\n  sprite.image = playerImg;\n} else {\n  // Need to load first\n  await assetLoader.loadImage('player', '/images/player.png');\n  sprite.image = assetLoader.getImage('player');\n}\n```\n\n## Preload Assets\n\nLoad all assets before game starts:\n\n```javascript\nasync function preloadAssets() {\n  await assetLoader.loadImages({\n    // Characters\n    player: '/images/player.png',\n    enemy: '/images/enemy.png',\n    boss: '/images/boss.png',\n\n    // Environment\n    background: '/images/background.png',\n    ground: '/images/ground.png',\n    platform: '/images/platform.png',\n\n    // Items\n    coin: '/images/coin.png',\n    powerup: '/images/powerup.png',\n    heart: '/images/heart.png',\n\n    // UI\n    button: '/images/button.png',\n    panel: '/images/panel.png'\n  });\n}\n\n// Preload before starting\nawait preloadAssets();\ngame.start();\n```\n\n## Custom Asset Loader\n\nCreate your own AssetLoader instance for specific purposes:\n\n```javascript\nimport { AssetLoader } from '@mode-7/zap';\n\n// Separate loader for level 1 assets\nconst level1Loader = new AssetLoader();\n\nawait level1Loader.loadImages({\n  enemy1: '/levels/1/enemy1.png',\n  enemy2: '/levels/1/enemy2.png',\n  background: '/levels/1/background.png'\n});\n\n// Later, clear level 1 assets\nlevel1Loader.clear();\n\n// Load level 2 assets\nawait level1Loader.loadImages({\n  enemy1: '/levels/2/enemy1.png',\n  enemy2: '/levels/2/enemy2.png',\n  background: '/levels/2/background.png'\n});\n```\n\n## Common Patterns\n\n### Lazy Loading\n\nLoad assets only when needed:\n\n```javascript\nasync function showLevel(levelNumber) {\n  // Show loading\n  loadingText.visible = true;\n\n  // Load level-specific assets\n  await assetLoader.loadImages({\n    background: `/levels/${levelNumber}/bg.png`,\n    enemies: `/levels/${levelNumber}/enemies.png`,\n    tileset: `/levels/${levelNumber}/tiles.png`\n  });\n\n  // Hide loading\n  loadingText.visible = false;\n\n  // Start level\n  startLevel(levelNumber);\n}\n```\n\n### Asset Management by Scene\n\nLoad and unload assets per scene:\n\n```javascript\nclass MenuScene extends Scene {\n  async load() {\n    await assetLoader.loadImages({\n      logo: '/menu/logo.png',\n      button: '/menu/button.png',\n      background: '/menu/background.png'\n    });\n  }\n}\n\nclass GameScene extends Scene {\n  async load() {\n    await assetLoader.loadImages({\n      player: '/game/player.png',\n      enemies: '/game/enemies.png',\n      tileset: '/game/tileset.png'\n    });\n  }\n}\n\n// Load menu assets\nawait menuScene.load();\ngame.setScene(menuScene);\n\n// Later, switch to game\nawait gameScene.load();\ngame.setScene(gameScene);\n```\n\n### Retry Failed Loads\n\nHandle and retry failed image loads:\n\n```javascript\nasync function loadWithRetry(key, url, maxRetries = 3) {\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      await assetLoader.loadImage(key, url);\n      return;\n    } catch (error) {\n      console.log(`Failed to load ${key}, retry ${i + 1}/${maxRetries}`);\n\n      if (i === maxRetries - 1) {\n        throw error;  // Final retry failed\n      }\n\n      // Wait before retry\n      await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n  }\n}\n\n// Usage\ntry {\n  await loadWithRetry('player', '/images/player.png');\n} catch (error) {\n  console.error('Failed to load player image after retries');\n}\n```\n\n### Loading Screen with Animation\n\nAnimated loading indicator:\n\n```javascript\nconst loadingScene = new Scene();\n\nconst loadingText = new Text({\n  text: 'Loading',\n  x: 200,\n  y: 140,\n  fontSize: 18,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nconst progressBar = new Sprite({\n  x: 200,\n  y: 180,\n  width: 0,  // Start at 0\n  height: 10,\n  color: '#51cf66'\n});\n\nloadingScene.add(loadingText);\nloadingScene.add(progressBar);\n\ngame.setScene(loadingScene);\ngame.start();\n\n// Load with progress\nconst assets = { /* ... */ };\nconst total = Object.keys(assets).length;\nlet loaded = 0;\n\nconst promises = Object.entries(assets).map(async ([key, url]) => {\n  await assetLoader.loadImage(key, url);\n  loaded++;\n\n  const progress = loaded / total;\n  loadingText.text = `Loading ${loaded}/${total}`;\n  progressBar.width = 300 * progress;\n});\n\nawait Promise.all(promises);\n\n// Fade out loading screen\nawait loadingText.tween({ alpha: 0 }, { duration: 300 });\nawait progressBar.tween({ alpha: 0 }, { duration: 300 });\n\n// Show game\ngame.setScene(gameScene);\n```\n\n### Asset Groups\n\nOrganize assets into logical groups:\n\n```javascript\nconst assetGroups = {\n  characters: {\n    player: '/images/player.png',\n    enemy1: '/images/enemy1.png',\n    enemy2: '/images/enemy2.png'\n  },\n\n  environment: {\n    background: '/images/background.png',\n    ground: '/images/ground.png',\n    trees: '/images/trees.png'\n  },\n\n  ui: {\n    button: '/ui/button.png',\n    panel: '/ui/panel.png',\n    heart: '/ui/heart.png'\n  }\n};\n\n// Load specific group\nasync function loadGroup(groupName) {\n  const group = assetGroups[groupName];\n  if (group) {\n    await assetLoader.loadImages(group);\n    console.log(`${groupName} loaded`);\n  }\n}\n\n// Load multiple groups\nawait loadGroup('characters');\nawait loadGroup('environment');\nawait loadGroup('ui');\n```\n\n## Error Handling\n\nHandle loading errors gracefully:\n\n```javascript\ntry {\n  await assetLoader.loadImage('player', '/images/player.png');\n} catch (error) {\n  console.error('Failed to load player image:', error);\n\n  // Use placeholder or default\n  const fallbackSprite = new Sprite({\n    x: 200, y: 150,\n    width: 64, height: 64,\n    color: '#e94560'  // Red placeholder\n  });\n\n  scene.add(fallbackSprite);\n}\n```\n\n## Caching Behavior\n\nThe AssetLoader automatically caches loaded images:\n\n```javascript\n// First call: loads from network\nawait assetLoader.loadImage('player', '/images/player.png');\n\n// Second call: returns cached image instantly\nawait assetLoader.loadImage('player', '/images/player.png');\n\n// Multiple simultaneous calls: only one network request\nconst promise1 = assetLoader.loadImage('enemy', '/images/enemy.png');\nconst promise2 = assetLoader.loadImage('enemy', '/images/enemy.png');\nconst promise3 = assetLoader.loadImage('enemy', '/images/enemy.png');\n\n// All three promises resolve to the same image\nawait Promise.all([promise1, promise2, promise3]);\n```\n\n## Clear Cache\n\nClear cached assets to free memory:\n\n```javascript\n// Clear all assets\nassetLoader.clear();\n\n// Or use a custom loader per level\nconst level1Loader = new AssetLoader();\nawait level1Loader.loadImages({ /* level 1 assets */ });\n\n// When level ends, clear\nlevel1Loader.clear();\n```\n\n## API Reference\n\n### `loadImage(key, url)`\n\nLoad a single image.\n\n**Parameters**:\n- `key` (string) - Unique identifier for the image\n- `url` (string) - Path to the image file\n\n**Returns**: Promise<HTMLImageElement>\n\n```javascript\nawait assetLoader.loadImage('player', '/images/player.png');\n```\n\n### `loadImages(assets)`\n\nLoad multiple images at once.\n\n**Parameters**:\n- `assets` (object) - Key-value pairs of identifiers and URLs\n\n**Returns**: Promise<void>\n\n```javascript\nawait assetLoader.loadImages({\n  player: '/images/player.png',\n  enemy: '/images/enemy.png'\n});\n```\n\n### `getImage(key)`\n\nGet a loaded image by key.\n\n**Parameters**:\n- `key` (string) - Image identifier\n\n**Returns**: HTMLImageElement | null\n\n```javascript\nconst image = assetLoader.getImage('player');\n```\n\n### `hasImage(key)`\n\nCheck if an image is loaded.\n\n**Parameters**:\n- `key` (string) - Image identifier\n\n**Returns**: boolean\n\n```javascript\nif (assetLoader.hasImage('player')) {\n  // Image is loaded\n}\n```\n\n### `clear()`\n\nClear all loaded assets.\n\n**Returns**: void\n\n```javascript\nassetLoader.clear();\n```\n\n## Performance Tips\n\n- **Preload critical assets**: Load essential images before game starts\n- **Lazy load level assets**: Load level-specific assets only when needed\n- **Use asset groups**: Organize assets logically for easier management\n- **Clear unused assets**: Free memory by clearing assets from completed levels\n- **Batch load**: Use `loadImages()` for better parallelization\n- **Cache appropriately**: Let AssetLoader cache, don't load same image twice\n\n## Common Mistakes\n\n### Not awaiting load\n\n```javascript\n// ❌ Wrong - image not loaded yet\nassetLoader.loadImage('player', '/images/player.png');\nconst sprite = new Sprite({ image: assetLoader.getImage('player') });\n\n// ✅ Right - wait for load to complete\nawait assetLoader.loadImage('player', '/images/player.png');\nconst sprite = new Sprite({ image: assetLoader.getImage('player') });\n```\n\n### Using URL instead of loaded image\n\n```javascript\n// ❌ Wrong - passing URL string\nconst sprite = new Sprite({ image: '/images/player.png' });\n\n// ✅ Right - pass loaded HTMLImageElement\nawait assetLoader.loadImage('player', '/images/player.png');\nconst sprite = new Sprite({ image: assetLoader.getImage('player') });\n```\n\n### Forgetting to handle errors\n\n```javascript\n// ❌ Wrong - unhandled errors crash game\nawait assetLoader.loadImage('player', '/images/player.png');\n\n// ✅ Right - graceful error handling\ntry {\n  await assetLoader.loadImage('player', '/images/player.png');\n} catch (error) {\n  console.error('Failed to load player:', error);\n  // Use fallback\n}\n```\n\n## Tips\n\n- **Load before use** - Always await loading before creating sprites\n- **Show loading feedback** - Users expect visual feedback during loads\n- **Handle errors** - Network can fail, always catch errors\n- **Organize by key** - Use descriptive, consistent naming for keys\n- **Clear when done** - Free memory by clearing unused assets\n- **Preload smartly** - Balance between preloading and lazy loading\n\n## Next Steps\n\n- [Sprites](/visual/sprites) - Using loaded images with sprites\n- [Sprite Animation](/visual/sprite-animation) - Animating sprite sheets\n- [Scenes](/core/scenes) - Managing asset loading per scene"
      },
      {
        "slug": "utilities/easing",
        "title": "Easing Functions",
        "description": "Timing functions for smooth, natural animations",
        "path": "utilities/easing.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/utilities/easing.md",
        "content": "# Easing Functions\n\nEasing functions control the timing and feel of animations. Instead of linear motion, easing creates natural acceleration and deceleration, making animations feel more polished and realistic.\n\n## Understanding Easing\n\nAll easing functions take a value from 0 to 1 (representing animation progress) and return a value from 0 to 1 (representing the eased progress):\n\n```javascript\nimport { Easing } from '@mode-7/zap';\n\n// Linear: constant speed\nEasing.linear(0.5);  // Returns 0.5\n\n// EaseOutQuad: starts fast, ends slow\nEasing.easeOutQuad(0.5);  // Returns ~0.75\n```\n\n## Using Easing with Tweens\n\nApply easing to any tween animation:\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst sprite = new Sprite({\n  x: 50,\n  y: 150,\n  width: 60,\n  height: 60,\n  color: '#e94560',\n  radius: 30\n});\n\nscene.add(sprite);\n\n// Animate with easing\nsprite.tween(\n  { x: 350 },\n  { duration: 2000, easing: 'easeOutBounce' }\n);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Easing Types\n\n### Linear\n\n**No easing** - constant speed throughout.\n\n```javascript\n// Linear motion\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'linear' });\n```\n\n**Use for**: Progress bars, loading indicators, anything that should move at constant speed.\n\n**Feel**: Robotic, mechanical, predictable.\n\n---\n\n### Quad (Quadratic)\n\n**Gentle acceleration/deceleration** - subtle, smooth easing.\n\n```javascript\n// Ease in: slow start, fast end\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInQuad' });\n\n// Ease out: fast start, slow end\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeOutQuad' });\n\n// Ease in-out: slow start, slow end\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInOutQuad' });\n```\n\n**Use for**: Subtle UI animations, cards sliding in, gentle movements.\n\n**Feel**: Smooth, natural, understated.\n\n---\n\n### Cubic\n\n**Moderate acceleration/deceleration** - noticeable curve.\n\n```javascript\n// Ease in: gradual acceleration\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInCubic' });\n\n// Ease out: gradual deceleration\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeOutCubic' });\n\n// Ease in-out: smooth curve\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInOutCubic' });\n```\n\n**Use for**: General purpose animations, menu transitions, modal dialogs.\n\n**Feel**: Smooth, polished, professional.\n\n---\n\n### Quart (Quartic)\n\n**Strong acceleration/deceleration** - dramatic curve.\n\n```javascript\n// Ease in: rapid acceleration\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInQuart' });\n\n// Ease out: rapid deceleration\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeOutQuart' });\n\n// Ease in-out: dramatic curve\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInOutQuart' });\n```\n\n**Use for**: Dramatic reveals, hero animations, important UI elements.\n\n**Feel**: Energetic, impactful, attention-grabbing.\n\n---\n\n### Quint (Quintic)\n\n**Very strong acceleration/deceleration** - extreme curve.\n\n```javascript\n// Ease in: very rapid acceleration\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInQuint' });\n\n// Ease out: very rapid deceleration\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeOutQuint' });\n\n// Ease in-out: extreme curve\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInOutQuint' });\n```\n\n**Use for**: Super dramatic effects, splash screens, cinematic transitions.\n\n**Feel**: Intense, powerful, cinematic.\n\n---\n\n### Sine\n\n**Sinusoidal curve** - very smooth and natural.\n\n```javascript\n// Ease in: gentle sinusoidal acceleration\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInSine' });\n\n// Ease out: gentle sinusoidal deceleration\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeOutSine' });\n\n// Ease in-out: smooth sinusoidal curve\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInOutSine' });\n```\n\n**Use for**: Subtle animations, floating elements, ambient motion.\n\n**Feel**: Organic, fluid, calming.\n\n---\n\n### Expo (Exponential)\n\n**Exponential acceleration/deceleration** - very dramatic.\n\n```javascript\n// Ease in: explosive acceleration\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInExpo' });\n\n// Ease out: explosive deceleration\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeOutExpo' });\n\n// Ease in-out: explosive curve\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInOutExpo' });\n```\n\n**Use for**: Fast actions, snappy UI, attention-demanding effects.\n\n**Feel**: Explosive, snappy, aggressive.\n\n---\n\n### Circ (Circular)\n\n**Circular curve** - smooth and pronounced.\n\n```javascript\n// Ease in: circular acceleration\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInCirc' });\n\n// Ease out: circular deceleration\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeOutCirc' });\n\n// Ease in-out: circular curve\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInOutCirc' });\n```\n\n**Use for**: Rounded motion, smooth reveals, polished UI.\n\n**Feel**: Rounded, smooth, refined.\n\n---\n\n### Back\n\n**Overshoots target** - pulls back before/after movement.\n\n```javascript\n// Ease in: pulls back, then launches forward\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInBack' });\n\n// Ease out: overshoots, then settles back\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeOutBack' });\n\n// Ease in-out: pulls back, overshoots, settles\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInOutBack' });\n```\n\n**Use for**: Playful UI, attention-grabbing buttons, fun animations.\n\n**Feel**: Playful, exaggerated, springy.\n\n---\n\n### Elastic\n\n**Spring-like oscillation** - bounces at start or end.\n\n```javascript\n// Ease in: spring compression before launch\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInElastic' });\n\n// Ease out: spring oscillation at end\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeOutElastic' });\n\n// Ease in-out: spring oscillation at both ends\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInOutElastic' });\n```\n\n**Use for**: Rubber band effects, playful UI, cartoonish motion.\n\n**Feel**: Bouncy, elastic, fun.\n\n---\n\n### Bounce\n\n**Bounces like a ball** - simulates gravity and bounce.\n\n```javascript\n// Ease in: reverse bounce before movement\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInBounce' });\n\n// Ease out: bounces at destination\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeOutBounce' });\n\n// Ease in-out: bounces at start and end\nsprite.tween({ x: 300 }, { duration: 1000, easing: 'easeInOutBounce' });\n```\n\n**Use for**: Dropping elements, playful interactions, game effects.\n\n**Feel**: Physical, bouncy, playful.\n\n---\n\n## Complete Reference\n\nAll 31 available easing functions:\n\n```javascript\n// Linear\n'linear'\n\n// Quad (gentle)\n'easeInQuad'\n'easeOutQuad'\n'easeInOutQuad'\n\n// Cubic (moderate)\n'easeInCubic'\n'easeOutCubic'\n'easeInOutCubic'\n\n// Quart (strong)\n'easeInQuart'\n'easeOutQuart'\n'easeInOutQuart'\n\n// Quint (very strong)\n'easeInQuint'\n'easeOutQuint'\n'easeInOutQuint'\n\n// Sine (smooth)\n'easeInSine'\n'easeOutSine'\n'easeInOutSine'\n\n// Expo (explosive)\n'easeInExpo'\n'easeOutExpo'\n'easeInOutExpo'\n\n// Circ (circular)\n'easeInCirc'\n'easeOutCirc'\n'easeInOutCirc'\n\n// Back (overshoot)\n'easeInBack'\n'easeOutBack'\n'easeInOutBack'\n\n// Elastic (spring)\n'easeInElastic'\n'easeOutElastic'\n'easeInOutElastic'\n\n// Bounce (gravity)\n'easeInBounce'\n'easeOutBounce'\n'easeInOutBounce'\n```\n\n## Choosing the Right Easing\n\n### In, Out, or In-Out?\n\n- **EaseIn**: Starts slow, ends fast. Use for elements leaving the screen.\n- **EaseOut**: Starts fast, ends slow. Use for elements entering the screen.\n- **EaseInOut**: Slow start and end. Use for elements moving within the screen.\n\n### By Use Case\n\n**Subtle, professional UI**:\n- `easeOutQuad` - Smooth, understated\n- `easeInOutCubic` - General purpose\n- `easeOutSine` - Very smooth\n\n**Attention-grabbing UI**:\n- `easeOutBack` - Playful overshoot\n- `easeOutBounce` - Bouncy landing\n- `easeOutElastic` - Spring effect\n\n**Dramatic reveals**:\n- `easeOutExpo` - Explosive deceleration\n- `easeOutQuint` - Very strong deceleration\n- `easeOutQuart` - Strong impact\n\n**Natural motion**:\n- `easeInOutSine` - Organic movement\n- `easeOutCubic` - Natural deceleration\n- `easeInOutQuad` - Gentle curves\n\n## Common Patterns\n\n### Button Press\n\n```javascript\nbutton.on('tap', () => {\n  // Press down\n  button.tween(\n    { scaleX: 0.9, scaleY: 0.9 },\n    { duration: 100, easing: 'easeOutQuad' }\n  ).then(() => {\n    // Release back\n    button.tween(\n      { scaleX: 1, scaleY: 1 },\n      { duration: 200, easing: 'easeOutBack' }  // Slight overshoot\n    );\n  });\n});\n```\n\n### Modal Dialog\n\n```javascript\n// Enter with dramatic slow-down\nmodal.scaleX = 0;\nmodal.scaleY = 0;\n\nmodal.tween(\n  { scaleX: 1, scaleY: 1 },\n  { duration: 400, easing: 'easeOutBack' }\n);\n\n// Exit quickly\nfunction closeModal() {\n  modal.tween(\n    { scaleX: 0, scaleY: 0 },\n    { duration: 200, easing: 'easeInQuad' }\n  );\n}\n```\n\n### Smooth Camera Pan\n\n```javascript\nfunction panTo(x, y) {\n  const duration = 1000;\n  const startTime = Date.now();\n  const startX = game.camera.x;\n  const startY = game.camera.y;\n\n  function update() {\n    const elapsed = Date.now() - startTime;\n    const progress = Math.min(elapsed / duration, 1);\n\n    // Use imported Easing object\n    const { Easing } = require('@mode-7/zap');\n    const eased = Easing.easeInOutCubic(progress);\n\n    game.camera.x = startX + (x - startX) * eased;\n    game.camera.y = startY + (y - startY) * eased;\n\n    if (progress < 1) {\n      requestAnimationFrame(update);\n    }\n  }\n\n  update();\n}\n```\n\n### Bouncing Ball\n\n```javascript\nball.tween(\n  { y: groundY },\n  { duration: 800, easing: 'easeOutBounce' }\n);\n```\n\n### Menu Slide In\n\n```javascript\n// Menu starts off-screen\nmenu.x = -menu.width;\n\n// Slides in with slight overshoot\nmenu.tween(\n  { x: 0 },\n  { duration: 400, easing: 'easeOutBack' }\n);\n```\n\n### Elastic Button Hover\n\n```javascript\nbutton.on('tap', () => {\n  // Compress\n  button.tween(\n    { scaleX: 0.8, scaleY: 0.8 },\n    { duration: 100, easing: 'easeInQuad' }\n  ).then(() => {\n    // Elastic release\n    button.tween(\n      { scaleX: 1, scaleY: 1 },\n      { duration: 600, easing: 'easeOutElastic' }\n    );\n  });\n});\n```\n\n### Loading Spinner\n\n```javascript\n// Constant rotation (linear)\nfunction spin() {\n  spinner.rotation = 0;\n  spinner.tween(\n    { rotation: Math.PI * 2 },\n    { duration: 1000, easing: 'linear' }\n  ).then(() => {\n    spin();  // Loop\n  });\n}\n\nspin();\n```\n\n## Custom Easing\n\nAccess the Easing object directly for custom implementations:\n\n```javascript\nimport { Easing } from '@mode-7/zap';\n\nfunction customAnimation(progress) {\n  // Apply easing manually\n  const eased = Easing.easeOutBounce(progress);\n\n  sprite.x = startX + (endX - startX) * eased;\n  sprite.y = startY + (endY - startY) * eased;\n}\n```\n\n## Comparison Guide\n\n**From gentlest to most dramatic**:\n\n1. `linear` - No easing\n2. `easeInOutQuad` - Very subtle\n3. `easeInOutSine` - Gentle and smooth\n4. `easeInOutCubic` - Moderate\n5. `easeInOutQuart` - Strong\n6. `easeInOutQuint` - Very strong\n7. `easeInOutExpo` - Explosive\n8. `easeInOutBack` - Overshoots\n9. `easeInOutElastic` - Spring-like\n10. `easeInOutBounce` - Most dramatic\n\n**Most commonly used**:\n\n- `easeOutQuad` - 40% of use cases (general UI)\n- `easeInOutCubic` - 30% of use cases (smooth motion)\n- `easeOutBack` - 15% of use cases (playful UI)\n- `easeOutBounce` - 10% of use cases (fun effects)\n- Others - 5% of use cases (special effects)\n\n## Performance\n\nAll easing functions are lightweight mathematical calculations:\n\n- **No overhead**: Pure math functions, no memory allocation\n- **Fast execution**: Simple polynomial or trigonometric calculations\n- **Safe for many tweens**: Can run hundreds simultaneously\n\n## Tips\n\n- **Start with easeOutQuad** - Works for 90% of UI animations\n- **Use easeOut for entrances** - Elements entering the screen\n- **Use easeIn for exits** - Elements leaving the screen\n- **Use easeInOut for movement** - Elements moving within view\n- **Match easing to intent** - Playful vs professional, subtle vs dramatic\n- **Don't overuse dramatic easings** - Back/Elastic/Bounce can be distracting\n- **Test different durations** - Easing + duration = feel\n\n## Common Mistakes\n\n### Wrong easing direction\n\n```javascript\n// ❌ Wrong - element enters screen with easeIn (starts slow)\npanel.x = -panel.width;\npanel.tween({ x: 0 }, { duration: 400, easing: 'easeInQuad' });\n\n// ✅ Right - element enters with easeOut (ends slow, more natural)\npanel.x = -panel.width;\npanel.tween({ x: 0 }, { duration: 400, easing: 'easeOutQuad' });\n```\n\n### Too dramatic for subtle UI\n\n```javascript\n// ❌ Wrong - distracting for simple button\nbutton.tween({ scaleX: 1.1 }, { easing: 'easeOutElastic' });\n\n// ✅ Right - subtle for UI element\nbutton.tween({ scaleX: 1.1 }, { easing: 'easeOutQuad' });\n```\n\n### Linear for organic motion\n\n```javascript\n// ❌ Wrong - feels robotic\ncharacter.tween({ x: 500 }, { duration: 1000, easing: 'linear' });\n\n// ✅ Right - feels natural\ncharacter.tween({ x: 500 }, { duration: 1000, easing: 'easeInOutCubic' });\n```\n\n## Next Steps\n\n- [Tweening](/animation/tweening) - Using easing in animations\n- [Camera](/core/camera) - Smooth camera movements\n- [Button](/ui/button) - Animated UI interactions"
      },
      {
        "slug": "utilities/fonts",
        "title": "Fonts",
        "description": "Load Google Fonts and custom web fonts",
        "path": "utilities/fonts.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/utilities/fonts.md",
        "content": "# Fonts\n\nZap provides utilities for loading Google Fonts and custom web fonts, ensuring fonts are ready before rendering text.\n\n## Load Google Font\n\nLoad a single Google Font:\n\n```codemirror\nimport { Game, Scene, Text, loadGoogleFont } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\n// Load font before creating text\nloadGoogleFont('Poppins', [400, 700]).then(() => {\n  const title = new Text({\n    text: 'Hello Poppins!',\n    x: 200,\n    y: 150,\n    fontSize: 32,\n    fontFamily: 'Poppins',\n    fontWeight: 700,\n    color: '#4fc3f7',\n    align: 'center'\n  });\n\n  scene.add(title);\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Load Multiple Google Fonts\n\nLoad several fonts at once:\n\n```javascript\nimport { loadGoogleFonts } from '@mode-7/zap';\n\nawait loadGoogleFonts([\n  { family: 'Poppins', weights: [400, 700] },\n  { family: 'Roboto Mono', weights: [400] },\n  { family: 'Press Start 2P', weights: [400] }\n]);\n\n// All fonts are now ready to use\n```\n\n## Load Custom Font\n\nLoad fonts from your own files:\n\n```javascript\nimport { loadCustomFont } from '@mode-7/zap';\n\nawait loadCustomFont('MyFont', '/fonts/myfont.woff2', 400);\n\n// Use custom font\nconst text = new Text({\n  text: 'Custom Font Text',\n  fontFamily: 'MyFont',\n  fontSize: 24\n});\n```\n\n## Font Weights\n\nSpecify which weights to load:\n\n```javascript\n// Single weight\nawait loadGoogleFont('Roboto', [400]);\n\n// Multiple weights\nawait loadGoogleFont('Roboto', [300, 400, 700, 900]);\n\n// Common combinations\nawait loadGoogleFont('Open Sans', [400, 600, 700]);  // Regular, SemiBold, Bold\nawait loadGoogleFont('Montserrat', [300, 400, 500, 700]);  // Light to Bold\n```\n\n## Popular Google Fonts\n\n### Modern & Clean\n\n```javascript\n// Poppins - geometric sans-serif\nawait loadGoogleFont('Poppins', [400, 600, 700]);\n\n// Inter - UI-focused sans-serif\nawait loadGoogleFont('Inter', [400, 500, 700]);\n\n// Montserrat - urban sans-serif\nawait loadGoogleFont('Montserrat', [400, 700]);\n```\n\n### Retro & Gaming\n\n```javascript\n// Press Start 2P - pixel/arcade style\nawait loadGoogleFont('Press Start 2P', [400]);\n\n// VT323 - terminal/monospace\nawait loadGoogleFont('VT323', [400]);\n\n// Orbitron - sci-fi/futuristic\nawait loadGoogleFont('Orbitron', [400, 700, 900]);\n```\n\n### Playful & Fun\n\n```javascript\n// Fredoka One - rounded, bold\nawait loadGoogleFont('Fredoka One', [400]);\n\n// Righteous - chunky, fun\nawait loadGoogleFont('Righteous', [400]);\n\n// Bungee - urban display\nawait loadGoogleFont('Bungee', [400]);\n```\n\n### Monospace\n\n```javascript\n// Roboto Mono - clean monospace\nawait loadGoogleFont('Roboto Mono', [400, 700]);\n\n// Courier Prime - typewriter style\nawait loadGoogleFont('Courier Prime', [400, 700]);\n\n// Space Mono - geometric monospace\nawait loadGoogleFont('Space Mono', [400, 700]);\n```\n\n## Loading with Progress\n\nShow loading progress for fonts:\n\n```codemirror\nimport { Game, Scene, Text, loadGoogleFonts } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst loadingScene = new Scene();\n\nconst loadingText = new Text({\n  text: 'Loading fonts...',\n  x: 200,\n  y: 150,\n  fontSize: 16,\n  color: '#888',\n  align: 'center'\n});\n\nloadingScene.add(loadingText);\ngame.setScene(loadingScene);\ngame.start();\n\n// Load fonts\nloadGoogleFonts([\n  { family: 'Poppins', weights: [400, 700] },\n  { family: 'Press Start 2P', weights: [400] }\n]).then(() => {\n  // Fonts loaded, show game\n  const gameScene = new Scene();\n\n  const title = new Text({\n    text: 'Game Title',\n    x: 200,\n    y: 100,\n    fontSize: 32,\n    fontFamily: 'Poppins',\n    fontWeight: 700,\n    color: '#4fc3f7',\n    align: 'center'\n  });\n\n  gameScene.add(title);\n  game.setScene(gameScene);\n});\n```\n\n## Font Caching\n\nFonts are automatically cached to prevent duplicate loads:\n\n```javascript\n// First call: loads from Google Fonts\nawait loadGoogleFont('Poppins', [400]);\n\n// Second call: returns immediately (cached)\nawait loadGoogleFont('Poppins', [400]);\n\n// Different weights: loads new weights\nawait loadGoogleFont('Poppins', [700]);\n```\n\n## Custom Font Formats\n\nSupport for multiple font formats:\n\n```javascript\n// WOFF2 (best compression, modern browsers)\nawait loadCustomFont('MyFont', '/fonts/myfont.woff2');\n\n// WOFF (wider browser support)\nawait loadCustomFont('MyFont', '/fonts/myfont.woff');\n\n// TTF (universal compatibility)\nawait loadCustomFont('MyFont', '/fonts/myfont.ttf');\n```\n\n## Common Patterns\n\n### Pixel Art Game\n\n```javascript\nawait loadGoogleFont('Press Start 2P', [400]);\n\nconst title = new Text({\n  text: 'PIXEL QUEST',\n  fontSize: 20,\n  fontFamily: 'Press Start 2P',\n  color: '#fff'\n});\n```\n\n### Sci-Fi Game\n\n```javascript\nawait loadGoogleFont('Orbitron', [400, 700, 900]);\n\nconst hud = new Text({\n  text: 'SHIELDS: 100%',\n  fontSize: 18,\n  fontFamily: 'Orbitron',\n  fontWeight: 700,\n  color: '#4fc3f7'\n});\n```\n\n### Casual Mobile Game\n\n```javascript\nawait loadGoogleFont('Fredoka One', [400]);\n\nconst score = new Text({\n  text: 'Score: 1250',\n  fontSize: 24,\n  fontFamily: 'Fredoka One',\n  color: '#f39c12'\n});\n```\n\n### RPG / Fantasy\n\n```javascript\nawait loadGoogleFont('MedievalSharp', [400]);\n\nconst dialogue = new Text({\n  text: 'Greetings, traveler!',\n  fontSize: 16,\n  fontFamily: 'MedievalSharp',\n  color: '#fff'\n});\n```\n\n### Terminal / Hacker Theme\n\n```javascript\nawait loadGoogleFont('VT323', [400]);\n\nconst terminal = new Text({\n  text: '> System booting...',\n  fontSize: 18,\n  fontFamily: 'VT323',\n  color: '#51cf66'\n});\n```\n\n### Modern UI\n\n```javascript\nawait loadGoogleFonts([\n  { family: 'Inter', weights: [400, 600] },\n  { family: 'Roboto Mono', weights: [400] }\n]);\n\nconst heading = new Text({\n  text: 'Settings',\n  fontSize: 24,\n  fontFamily: 'Inter',\n  fontWeight: 600,\n  color: '#fff'\n});\n\nconst code = new Text({\n  text: 'Version 1.0.0',\n  fontSize: 12,\n  fontFamily: 'Roboto Mono',\n  color: '#888'\n});\n```\n\n## Error Handling\n\nHandle font loading errors:\n\n```javascript\ntry {\n  await loadGoogleFont('NonExistentFont', [400]);\n} catch (error) {\n  console.error('Font load failed:', error);\n  // Fall back to default font\n  text.fontFamily = 'Arial';\n}\n```\n\n## Preload All Fonts\n\nLoad fonts before game initialization:\n\n```javascript\nasync function preloadFonts() {\n  await loadGoogleFonts([\n    { family: 'Poppins', weights: [400, 600, 700] },\n    { family: 'Roboto Mono', weights: [400] },\n    { family: 'Press Start 2P', weights: [400] }\n  ]);\n}\n\n// Preload fonts\nawait preloadFonts();\n\n// Then start game\nconst game = new Game({ width: 400, height: 300 });\ngame.start();\n```\n\n## Font Combinations\n\nPair fonts effectively:\n\n```javascript\n// Heading + Body\nawait loadGoogleFonts([\n  { family: 'Poppins', weights: [700] },      // Headings\n  { family: 'Open Sans', weights: [400] }     // Body text\n]);\n\n// Display + UI\nawait loadGoogleFonts([\n  { family: 'Righteous', weights: [400] },    // Game title\n  { family: 'Roboto', weights: [400, 700] }   // UI elements\n]);\n\n// Retro + Modern\nawait loadGoogleFonts([\n  { family: 'Press Start 2P', weights: [400] }, // Pixel text\n  { family: 'Inter', weights: [400, 600] }      // Modern UI\n]);\n```\n\n## Font Loading Best Practices\n\n### Load Early\n\n```javascript\n// ✅ Good - load before creating text\nawait loadGoogleFont('Poppins', [400]);\n\nconst text = new Text({\n  text: 'Hello',\n  fontFamily: 'Poppins'\n});\n```\n\n### Limit Weights\n\n```javascript\n// ❌ Bad - too many weights\nawait loadGoogleFont('Roboto', [100, 200, 300, 400, 500, 600, 700, 800, 900]);\n\n// ✅ Good - only needed weights\nawait loadGoogleFont('Roboto', [400, 700]);\n```\n\n### Batch Load\n\n```javascript\n// ❌ Bad - sequential loading\nawait loadGoogleFont('Poppins', [400]);\nawait loadGoogleFont('Roboto', [400]);\nawait loadGoogleFont('Orbitron', [400]);\n\n// ✅ Good - parallel loading\nawait loadGoogleFonts([\n  { family: 'Poppins', weights: [400] },\n  { family: 'Roboto', weights: [400] },\n  { family: 'Orbitron', weights: [400] }\n]);\n```\n\n## API Reference\n\n### `loadGoogleFont(fontFamily, weights)`\n\nLoad a single Google Font.\n\n**Parameters**:\n- `fontFamily` (string) - Font family name (e.g., 'Poppins', 'Roboto')\n- `weights` (number[]) - Array of font weights (default: [400])\n\n**Returns**: Promise<void>\n\n```javascript\nawait loadGoogleFont('Poppins', [400, 700]);\n```\n\n### `loadGoogleFonts(fonts)`\n\nLoad multiple Google Fonts at once.\n\n**Parameters**:\n- `fonts` (object[]) - Array of font configurations\n  - `family` (string) - Font family name\n  - `weights` (number[]) - Font weights (optional, default: [400])\n\n**Returns**: Promise<void>\n\n```javascript\nawait loadGoogleFonts([\n  { family: 'Poppins', weights: [400, 700] },\n  { family: 'Roboto Mono', weights: [400] }\n]);\n```\n\n### `loadCustomFont(fontFamily, url, weight)`\n\nLoad a custom font from a URL.\n\n**Parameters**:\n- `fontFamily` (string) - Font family name to use in CSS\n- `url` (string) - Path to font file (.woff2, .woff, .ttf)\n- `weight` (number) - Font weight (default: 400)\n\n**Returns**: Promise<void>\n\n```javascript\nawait loadCustomFont('MyFont', '/fonts/myfont.woff2', 400);\n```\n\n## Performance Tips\n\n- **Load fonts early**: Load during initial loading screen\n- **Limit weights**: Only load weights you'll actually use\n- **Use WOFF2**: Best compression for custom fonts\n- **Batch load**: Load multiple fonts in parallel\n- **Cache effectively**: Let Zap handle caching automatically\n- **Preload critical fonts**: Load display fonts before game starts\n\n## Common Mistakes\n\n### Using font before loading\n\n```javascript\n// ❌ Wrong - font not loaded yet\nconst text = new Text({\n  text: 'Hello',\n  fontFamily: 'Poppins'\n});\nawait loadGoogleFont('Poppins', [400]);\n\n// ✅ Right - load font first\nawait loadGoogleFont('Poppins', [400]);\nconst text = new Text({\n  text: 'Hello',\n  fontFamily: 'Poppins'\n});\n```\n\n### Wrong font family name\n\n```javascript\n// ❌ Wrong - incorrect spacing\nawait loadGoogleFont('PressStart2P', [400]);\n\n// ✅ Right - correct spacing\nawait loadGoogleFont('Press Start 2P', [400]);\n```\n\n### Loading wrong weight\n\n```javascript\n// ❌ Wrong - weight 800 not loaded\nawait loadGoogleFont('Roboto', [400]);\nconst text = new Text({\n  fontFamily: 'Roboto',\n  fontWeight: 800  // Not loaded!\n});\n\n// ✅ Right - load all needed weights\nawait loadGoogleFont('Roboto', [400, 800]);\nconst text = new Text({\n  fontFamily: 'Roboto',\n  fontWeight: 800\n});\n```\n\n## Tips\n\n- **Test font rendering** - Ensure fonts display correctly before release\n- **Use fallbacks** - Specify fallback fonts: `fontFamily: 'Poppins, Arial, sans-serif'`\n- **Match game theme** - Choose fonts that fit your visual style\n- **Readable sizes** - Minimum 12px for body text, 16px+ for important UI\n- **Consider licensing** - Google Fonts are free, check licenses for custom fonts\n- **Preview fonts** - Use [Google Fonts](https://fonts.google.com/) to preview\n\n## Next Steps\n\n- [Text](/visual/text) - Creating text entities\n- [Asset Loader](/utilities/asset-loader) - Loading other assets\n- [Button](/ui/button) - Buttons with custom fonts"
      },
      {
        "slug": "utilities/layout",
        "title": "Layout",
        "description": "Position entities with grid, circle, and alignment utilities",
        "path": "utilities/layout.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/utilities/layout.md",
        "content": "# Layout\n\nLayout utilities help you position multiple entities quickly using grids, circles, rows, columns, and alignment functions.\n\n## Grid Layout\n\nPosition entities in a grid:\n\n```codemirror\nimport { Game, Scene, Sprite, Layout } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\n// Create 12 boxes\nconst boxes = [];\nfor (let i = 0; i < 12; i++) {\n  const box = new Sprite({\n    width: 50,\n    height: 50,\n    color: '#4fc3f7',\n    radius: 8\n  });\n  boxes.push(box);\n  scene.add(box);\n}\n\n// Arrange in 4x3 grid\nLayout.layoutGrid(boxes, {\n  columns: 4,\n  rows: 3,\n  cellWidth: 50,\n  cellHeight: 50,\n  spacing: 10,\n  startX: 50,\n  startY: 50\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Circle Layout\n\nArrange entities in a circle:\n\n```codemirror\nimport { Game, Scene, Sprite, Layout } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\n// Create 8 dots\nconst dots = [];\nfor (let i = 0; i < 8; i++) {\n  const dot = new Sprite({\n    width: 30,\n    height: 30,\n    color: '#e94560',\n    radius: 15\n  });\n  dots.push(dot);\n  scene.add(dot);\n}\n\n// Arrange in circle\nLayout.layoutCircle(dots, 200, 150, 100);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Row Layout\n\nPosition entities horizontally:\n\n```codemirror\nimport { Game, Scene, Sprite, Layout } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\n// Create 5 boxes\nconst boxes = [];\nfor (let i = 0; i < 5; i++) {\n  const box = new Sprite({\n    width: 50,\n    height: 50,\n    color: '#51cf66',\n    radius: 8\n  });\n  boxes.push(box);\n  scene.add(box);\n}\n\n// Arrange in horizontal row\nLayout.layoutRow(boxes, 50, 150, 70);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Column Layout\n\nPosition entities vertically:\n\n```codemirror\nimport { Game, Scene, Sprite, Layout } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\n// Create 4 boxes\nconst boxes = [];\nfor (let i = 0; i < 4; i++) {\n  const box = new Sprite({\n    width: 60,\n    height: 40,\n    color: '#f39c12',\n    radius: 6\n  });\n  boxes.push(box);\n  scene.add(box);\n}\n\n// Arrange in vertical column\nLayout.layoutColumn(boxes, 200, 50, 60);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Center Entity\n\nCenter a single entity on screen:\n\n```javascript\nimport { Layout } from '@mode-7/zap';\n\nconst sprite = new Sprite({\n  width: 100,\n  height: 100,\n  color: '#4fc3f7'\n});\n\n// Center on 400x300 canvas\nLayout.center(sprite, 400, 300);\n\nscene.add(sprite);\n```\n\n## Common Patterns\n\n### Inventory Grid\n\nCreate an inventory system:\n\n```javascript\nimport { Layout } from '@mode-7/zap';\n\nconst inventorySlots = [];\n\n// Create 20 inventory slots (4x5 grid)\nfor (let i = 0; i < 20; i++) {\n  const slot = new NinePatch({\n    width: 60,\n    height: 60,\n    image: '/ui/slot.png',\n    corners: 12,\n    interactive: true\n  });\n\n  slot.on('tap', () => {\n    console.log(`Slot ${i} clicked`);\n  });\n\n  inventorySlots.push(slot);\n  scene.add(slot);\n}\n\n// Arrange in grid\nLayout.layoutGrid(inventorySlots, {\n  columns: 4,\n  rows: 5,\n  cellWidth: 60,\n  cellHeight: 60,\n  spacing: 5,\n  startX: 50,\n  startY: 50\n});\n```\n\n### Menu Buttons\n\nVertical menu with buttons:\n\n```javascript\nimport { Layout } from '@mode-7/zap';\n\nconst menuButtons = [\n  new Button({ text: 'Play', width: 160, height: 50 }),\n  new Button({ text: 'Options', width: 160, height: 50 }),\n  new Button({ text: 'Credits', width: 160, height: 50 }),\n  new Button({ text: 'Quit', width: 160, height: 50 })\n];\n\nmenuButtons.forEach(btn => scene.add(btn));\n\n// Arrange in vertical column\nLayout.layoutColumn(menuButtons,200, 80, 70);\n```\n\n### Radial Menu\n\nCircular menu around cursor:\n\n```javascript\nimport { Layout } from '@mode-7/zap';\n\nfunction showRadialMenu(x, y) {\n  const options = ['⚔️', '🛡️', '🏹', '🪄', '💊', '📜'];\n\n  const menuItems = options.map(icon => {\n    const item = new Sprite({\n      width: 50,\n      height: 50,\n      color: '#16213e',\n      radius: 25,\n      interactive: true\n    });\n\n    const label = new Text({\n      text: icon,\n      fontSize: 24,\n      align: 'center',\n      baseline: 'middle'\n    });\n\n    item.addChild(label);\n    scene.add(item);\n\n    return item;\n  });\n\n  // Arrange in circle around cursor\n  Layout.layoutCircle(menuItems, x, y, 80);\n}\n\n// Show on right-click\ncanvas.addEventListener('contextmenu', (e) => {\n  e.preventDefault();\n  showRadialMenu(e.clientX, e.clientY);\n});\n```\n\n### Tile Grid\n\nCreate a tile-based game board:\n\n```javascript\nimport { Layout } from '@mode-7/zap';\n\nconst tiles = [];\nconst tileTypes = ['grass', 'water', 'stone', 'sand'];\n\n// Create 10x10 grid of tiles\nfor (let i = 0; i < 100; i++) {\n  const type = randomItem(tileTypes);\n\n  const tile = new Sprite({\n    width: 32,\n    height: 32,\n    image: assetLoader.getImage(type)\n  });\n\n  tiles.push(tile);\n  scene.add(tile);\n}\n\n// Arrange in 10x10 grid\nLayout.layoutGrid(tiles, {\n  columns: 10,\n  rows: 10,\n  cellWidth: 32,\n  cellHeight: 32,\n  spacing: 0,\n  startX: 20,\n  startY: 20\n});\n```\n\n### Planet Orbit\n\nPosition planets in orbit:\n\n```javascript\nimport { Layout } from '@mode-7/zap';\n\nconst planets = [\n  new Sprite({ width: 20, height: 20, color: '#888', radius: 10 }),  // Mercury\n  new Sprite({ width: 30, height: 30, color: '#f39c12', radius: 15 }), // Venus\n  new Sprite({ width: 32, height: 32, color: '#4fc3f7', radius: 16 }), // Earth\n  new Sprite({ width: 26, height: 26, color: '#e94560', radius: 13 })  // Mars\n];\n\nplanets.forEach(planet => scene.add(planet));\n\n// Position around sun\nconst sun = new Sprite({\n  x: 200, y: 150,\n  width: 50, height: 50,\n  color: '#f1c40f',\n  radius: 25\n});\n\nscene.add(sun);\nLayout.layoutCircle(planets,200, 150, 120);\n```\n\n### Card Hand\n\nArrange cards in an arc (like a hand of cards):\n\n```javascript\nimport { Layout } from '@mode-7/zap';\n\nconst cards = [];\nfor (let i = 0; i < 5; i++) {\n  const card = new Sprite({\n    width: 60,\n    height: 90,\n    color: '#fff',\n    radius: 6,\n    interactive: true\n  });\n\n  cards.push(card);\n  scene.add(card);\n}\n\n// Position in semi-circle at bottom\nLayout.layoutCircle(cards,200, 250, 180, Math.PI * 0.7);  // Start at ~135°\n```\n\n### Responsive Grid\n\nAdjust grid based on screen size:\n\n```javascript\nimport { Layout } from '@mode-7/zap';\n\nfunction createResponsiveGrid(items, canvasWidth, canvasHeight) {\n  const itemsPerRow = canvasWidth < 400 ? 3 : 5;\n  const cellSize = canvasWidth / (itemsPerRow + 1);\n\n  Layout.layoutGrid(items, {\n    columns: itemsPerRow,\n    rows: Math.ceil(items.length / itemsPerRow),\n    cellWidth: cellSize,\n    cellHeight: cellSize,\n    spacing: cellSize * 0.1,\n    startX: 20,\n    startY: 20\n  });\n}\n```\n\n### Toolbar\n\nHorizontal toolbar with icons:\n\n```javascript\nimport { Layout } from '@mode-7/zap';\n\nconst tools = ['✏️', '🖌️', '🧹', '🎨', '💾'];\n\nconst toolbar = tools.map(icon => {\n  const button = new Sprite({\n    width: 50,\n    height: 50,\n    color: '#16213e',\n    radius: 8,\n    interactive: true\n  });\n\n  const label = new Text({\n    text: icon,\n    fontSize: 24,\n    align: 'center',\n    baseline: 'middle'\n  });\n\n  button.addChild(label);\n  scene.add(button);\n\n  return button;\n});\n\n// Arrange horizontally\nLayout.layoutRow(toolbar,50, 30, 60);\n```\n\n### Level Select Grid\n\nGrid of level buttons:\n\n```javascript\nimport { Layout } from '@mode-7/zap';\n\nconst levelButtons = [];\nconst unlockedLevels = Storage.get('unlockedLevels', [1]);\n\nfor (let i = 1; i <= 20; i++) {\n  const isUnlocked = unlockedLevels.includes(i);\n\n  const button = new Sprite({\n    width: 60,\n    height: 60,\n    color: isUnlocked ? '#4fc3f7' : '#333',\n    radius: 10,\n    interactive: isUnlocked\n  });\n\n  const label = new Text({\n    text: String(i),\n    fontSize: 20,\n    color: isUnlocked ? '#fff' : '#666',\n    align: 'center',\n    baseline: 'middle'\n  });\n\n  button.addChild(label);\n\n  if (isUnlocked) {\n    button.on('tap', () => startLevel(i));\n  }\n\n  levelButtons.push(button);\n  scene.add(button);\n}\n\n// 5x4 grid\nLayout.layoutGrid(levelButtons, {\n  columns: 5,\n  rows: 4,\n  cellWidth: 60,\n  cellHeight: 60,\n  spacing: 10,\n  startX: 40,\n  startY: 40\n});\n```\n\n## Dynamic Layouts\n\nRe-layout on changes:\n\n```javascript\nimport { Layout } from '@mode-7/zap';\n\nlet items = [];\n\nfunction addItem() {\n  const item = new Sprite({\n    width: 50,\n    height: 50,\n    color: '#51cf66',\n    radius: 8\n  });\n\n  items.push(item);\n  scene.add(item);\n\n  // Re-layout all items\n  updateLayout();\n}\n\nfunction removeItem(item) {\n  const index = items.indexOf(item);\n  if (index !== -1) {\n    items.splice(index, 1);\n    scene.remove(item);\n    updateLayout();\n  }\n}\n\nfunction updateLayout() {\n  Layout.layoutGrid(items, {\n    columns: 4,\n    rows: Math.ceil(items.length / 4),\n    cellWidth: 50,\n    cellHeight: 50,\n    spacing: 10,\n    startX: 50,\n    startY: 50\n  });\n}\n```\n\n## API Reference\n\n### `layoutGrid(entities, options)`\n\nPosition entities in a grid.\n\n**Parameters**:\n- `entities` (Entity[]) - Array of entities to position\n- `options` (GridOptions):\n  - `columns` (number) - Number of columns\n  - `rows` (number) - Number of rows\n  - `cellWidth` (number) - Width of each cell\n  - `cellHeight` (number) - Height of each cell\n  - `spacing` (number) - Space between cells (default: 0)\n  - `startX` (number) - Starting X position (default: 0)\n  - `startY` (number) - Starting Y position (default: 0)\n\n**Returns**: void\n\n```javascript\nLayout.layoutGrid(sprites, {\n  columns: 4,\n  rows: 3,\n  cellWidth: 60,\n  cellHeight: 60,\n  spacing: 10,\n  startX: 50,\n  startY: 50\n});\n```\n\n### `layoutCircle(entities, centerX, centerY, radius, startAngle?)`\n\nPosition entities in a circle.\n\n**Parameters**:\n- `entities` (Entity[]) - Array of entities to position\n- `centerX` (number) - Circle center X coordinate\n- `centerY` (number) - Circle center Y coordinate\n- `radius` (number) - Circle radius\n- `startAngle` (number) - Starting angle in radians (default: 0)\n\n**Returns**: void\n\n```javascript\nLayout.layoutCircle(sprites,200, 150, 100);\n\n// Start at 90 degrees (top of circle)\nLayout.layoutCircle(sprites,200, 150, 100, Math.PI / 2);\n```\n\n### `layoutRow(entities, startX, y, spacing)`\n\nPosition entities in a horizontal row.\n\n**Parameters**:\n- `entities` (Entity[]) - Array of entities to position\n- `startX` (number) - Starting X position\n- `y` (number) - Y position for all entities\n- `spacing` (number) - Space between entities\n\n**Returns**: void\n\n```javascript\nLayout.layoutRow(buttons,50, 150, 80);\n```\n\n### `layoutColumn(entities, x, startY, spacing)`\n\nPosition entities in a vertical column.\n\n**Parameters**:\n- `entities` (Entity[]) - Array of entities to position\n- `x` (number) - X position for all entities\n- `startY` (number) - Starting Y position\n- `spacing` (number) - Space between entities\n\n**Returns**: void\n\n```javascript\nLayout.layoutColumn(menuItems,200, 50, 60);\n```\n\n### `center(entity, width, height)`\n\nCenter an entity within given dimensions.\n\n**Parameters**:\n- `entity` (Entity) - Entity to center\n- `width` (number) - Container width\n- `height` (number) - Container height\n\n**Returns**: void\n\n```javascript\nLayout.center(sprite, game.canvas.width, game.canvas.height);\n```\n\n## Layout Tips\n\n- **Use spacing for breathing room** - Add spacing between grid cells\n- **Consider anchors** - Entities are positioned at their anchor point\n- **Responsive layouts** - Adjust grid columns based on canvas size\n- **Re-layout on changes** - Call layout functions when adding/removing items\n- **Combine layouts** - Use multiple layout types in the same scene\n\n## Common Mistakes\n\n### Wrong cell size\n\n```javascript\n// ❌ Wrong - cell size doesn't match sprite size\nLayout.layoutGrid(sprites, {\n  columns: 4,\n  rows: 3,\n  cellWidth: 50,   // But sprites are 80px wide!\n  cellHeight: 50\n});\n\n// ✅ Right - match sprite dimensions\nLayout.layoutGrid(sprites, {\n  columns: 4,\n  rows: 3,\n  cellWidth: 80,   // Matches sprite width\n  cellHeight: 80,\n  spacing: 10      // Add spacing for separation\n});\n```\n\n### Forgetting to add to scene\n\n```javascript\n// ❌ Wrong - layout before adding to scene\nLayout.layoutGrid(sprites, { /* ... */ });\nsprites.forEach(s => scene.add(s));\n\n// ✅ Right - add to scene first, then layout\nsprites.forEach(s => scene.add(s));\nLayout.layoutGrid(sprites, { /* ... */ });\n```\n\n### Not enough rows\n\n```javascript\n// ❌ Wrong - 12 items won't fit in 4x2 grid\nLayout.layoutGrid(sprites, {  // 12 sprites\n  columns: 4,\n  rows: 2  // Only 8 positions!\n});\n\n// ✅ Right - ensure enough cells\nLayout.layoutGrid(sprites, {  // 12 sprites\n  columns: 4,\n  rows: 3  // 12 positions\n});\n```\n\n## Next Steps\n\n- [Math](/utilities/math) - Math utilities for custom layouts\n- [Sprites](/visual/sprites) - Creating sprites to layout\n- [Scenes](/core/scenes) - Organizing layouts in scenes"
      },
      {
        "slug": "utilities/math",
        "title": "Math Utilities",
        "description": "Helpful math functions for game development",
        "path": "utilities/math.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/utilities/math.md",
        "content": "# Math Utilities\n\nZap provides commonly-used math functions for clamping, interpolation, mapping ranges, and random generation.\n\n## Clamp\n\nConstrain a value between minimum and maximum:\n\n```codemirror\nimport { Game, Scene, Sprite, Text, MathZ } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst player = new Sprite({\n  x: 200,\n  y: 150,\n  width: 50,\n  height: 50,\n  color: '#e94560',\n  radius: 25,\n  interactive: true\n});\n\nconst info = new Text({\n  text: 'Drag the circle',\n  x: 200,\n  y: 30,\n  fontSize: 14,\n  color: '#888',\n  align: 'center'\n});\n\nscene.add(player);\nscene.add(info);\n\n// Keep player within bounds\nplayer.on('drag', (event) => {\n  player.x = MathZ.clamp(player.x + event.delta.x, 50, 350);\n  player.y = MathZ.clamp(player.y + event.delta.y, 50, 250);\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Lerp (Linear Interpolation)\n\nBlend smoothly between two values:\n\n```codemirror\nimport { Game, Scene, Sprite, MathZ } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst target = new Sprite({\n  x: 350,\n  y: 150,\n  width: 40,\n  height: 40,\n  color: '#51cf66',\n  radius: 20\n});\n\nconst follower = new Sprite({\n  x: 50,\n  y: 150,\n  width: 30,\n  height: 30,\n  color: '#4fc3f7',\n  radius: 15\n});\n\nscene.add(target);\nscene.add(follower);\n\n// Smoothly follow target\nscene.on('update', () => {\n  follower.x = MathZ.lerp(follower.x, target.x, 0.05);\n  follower.y = MathZ.lerp(follower.y, target.y, 0.05);\n});\n\n// Move target with mouse\ngame.on('drag', (event) => {\n  target.x = event.position.x;\n  target.y = event.position.y;\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Map Range\n\nConvert a value from one range to another:\n\n```javascript\nimport { MathZ } from '@mode-7/zap';\n\n// Map mouse X (0-400) to rotation (0-2π)\nconst mouseX = 200;\nconst rotation = MathZ.map(mouseX, 0, 400, 0, Math.PI * 2);\n\n// Map health (0-100) to color (red to green)\nconst health = 75;\nconst greenValue = MathZ.map(health, 0, 100, 0, 255);\n\n// Map distance (0-500) to volume (1.0-0.0)\nconst distance = 250;\nconst volume = MathZ.map(distance, 0, 500, 1.0, 0.0);\n```\n\n## Random Integer\n\nGenerate random whole numbers:\n\n```codemirror\nimport { Game, Scene, Text, MathZ } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst result = new Text({\n  text: 'Click to roll dice',\n  x: 200,\n  y: 120,\n  fontSize: 32,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nconst instruction = new Text({\n  text: 'Click anywhere',\n  x: 200,\n  y: 180,\n  fontSize: 14,\n  color: '#888',\n  align: 'center'\n});\n\nscene.add(result);\nscene.add(instruction);\n\ngame.on('tap', () => {\n  const roll = MathZ.randomInt(1, 6);\n  result.text = `Rolled: ${roll}`;\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Random Float\n\nGenerate random decimal numbers:\n\n```javascript\nimport { MathZ } from '@mode-7/zap';\n\n// Random speed between 50 and 150\nconst speed = MathZ.randomFloat(50, 150);\n\n// Random opacity\nconst alpha = MathZ.randomFloat(0.5, 1.0);\n\n// Random position\nconst x = MathZ.randomFloat(0, game.canvas.width);\nconst y = MathZ.randomFloat(0, game.canvas.height);\n```\n\n## Random Item\n\nPick a random element from an array:\n\n```codemirror\nimport { Game, Scene, Sprite, Text, MathZ } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst colors = ['#e94560', '#4fc3f7', '#51cf66', '#f39c12', '#9b59b6'];\n\nconst box = new Sprite({\n  x: 200,\n  y: 120,\n  width: 100,\n  height: 100,\n  color: '#4fc3f7',\n  radius: 12,\n  interactive: true\n});\n\nconst label = new Text({\n  text: 'Click to change color',\n  x: 200,\n  y: 200,\n  fontSize: 14,\n  color: '#888',\n  align: 'center'\n});\n\nscene.add(box);\nscene.add(label);\n\nbox.on('tap', () => {\n  box.color = MathZ.randomItem(colors);\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Common Patterns\n\n### Smooth Camera Follow\n\n```javascript\nimport { MathZ } from '@mode-7/zap';\n\nscene.on('update', () => {\n  // Smoothly follow player (0.1 = smooth, 1.0 = instant)\n  game.camera.x = MathZ.lerp(game.camera.x, player.x, 0.1);\n  game.camera.y = MathZ.lerp(game.camera.y, player.y, 0.1);\n});\n```\n\n### Health Bar Color\n\n```javascript\nimport { MathZ } from '@mode-7/zap';\n\nfunction getHealthColor(health, maxHealth) {\n  // Clamp health to valid range\n  health = MathZ.clamp(health, 0, maxHealth);\n\n  // Map health to hue (0=red, 120=green)\n  const hue = MathZ.map(health, 0, maxHealth, 0, 120);\n\n  return `hsl(${hue}, 70%, 50%)`;\n}\n\nhealthBar.color = getHealthColor(player.health, 100);\n```\n\n### Distance-Based Volume\n\n```javascript\nimport { MathZ } from '@mode-7/zap';\n\nfunction getVolumeByDistance(distance, maxDistance = 500) {\n  const clampedDistance = MathZ.clamp(distance, 0, maxDistance);\n  return MathZ.map(clampedDistance, 0, maxDistance, 1.0, 0.0);\n}\n\nconst dx = player.x - sound.x;\nconst dy = player.y - sound.y;\nconst distance = Math.sqrt(dx * dx + dy * dy);\n\nsound.volume = getVolumeByDistance(distance);\n```\n\n### Random Enemy Spawn\n\n```javascript\nimport { MathZ } from '@mode-7/zap';\n\nfunction spawnEnemy() {\n  const types = ['zombie', 'skeleton', 'ghost'];\n  const type = MathZ.randomItem(types);\n\n  const enemy = new Sprite({\n    x: MathZ.randomInt(50, 350),\n    y: MathZ.randomInt(50, 250),\n    width: 40,\n    height: 40,\n    image: assetLoader.getImage(type)\n  });\n\n  enemy.speed = MathZ.randomFloat(50, 150);\n  enemy.health = MathZ.randomInt(20, 50);\n\n  scene.add(enemy);\n}\n```\n\n### Constrain to Bounds\n\n```javascript\nimport { clamp } from '@mode-7/zap';\n\nscene.on('update', (deltaTime) => {\n  // Move player\n  player.x += velocity.x * deltaTime;\n  player.y += velocity.y * deltaTime;\n\n  // Keep within game bounds\n  player.x = MathZ.clamp(player.x, 0, game.canvas.width);\n  player.y = MathZ.clamp(player.y, 0, game.canvas.height);\n});\n```\n\n### Smooth Rotation\n\n```javascript\nimport { lerp } from '@mode-7/zap';\n\nscene.on('update', () => {\n  // Calculate target angle to mouse\n  const dx = mouse.x - sprite.x;\n  const dy = mouse.y - sprite.y;\n  const targetAngle = Math.atan2(dy, dx);\n\n  // Smoothly rotate toward target\n  sprite.rotation = MathZ.lerp(sprite.rotation, targetAngle, 0.1);\n});\n```\n\n### Random Particle Spawn\n\n```javascript\nimport { MathZ } from '@mode-7/zap';\n\nfunction createParticle(x, y) {\n  const colors = ['#ff6b6b', '#f39c12', '#f1c40f'];\n\n  const particle = new Particle({\n    x,\n    y,\n    velocity: {\n      x: MathZ.randomFloat(-100, 100),\n      y: MathZ.randomFloat(-150, -50)\n    },\n    color: MathZ.randomItem(colors),\n    size: MathZ.randomFloat(4, 10),\n    lifetime: MathZ.randomFloat(0.5, 1.5)\n  });\n\n  scene.add(particle);\n}\n```\n\n### Map Joystick to Speed\n\n```javascript\nimport { map } from '@mode-7/zap';\n\n// Joystick gives -1 to 1\nconst joystickX = 0.7;\n\n// Map to speed (-200 to 200)\nconst speedX = MathZ.map(joystickX, -1, 1, -200, 200);\n\nplayer.velocityX = speedX;\n```\n\n### Difficulty Scaling\n\n```javascript\nimport { MathZ } from '@mode-7/zap';\n\nfunction getDifficulty(level) {\n  // Clamp level to reasonable range\n  level = MathZ.clamp(level, 1, 50);\n\n  return {\n    enemyCount: Math.floor(MathZ.map(level, 1, 50, 3, 20)),\n    enemySpeed: MathZ.map(level, 1, 50, 50, 200),\n    enemyHealth: Math.floor(MathZ.map(level, 1, 50, 20, 200)),\n    spawnRate: MathZ.map(level, 1, 50, 3000, 500)\n  };\n}\n\nconst difficulty = getDifficulty(currentLevel);\n```\n\n### Screenshake Intensity\n\n```javascript\nimport { MathZ } from '@mode-7/zap';\n\nfunction shake(damage) {\n  // Map damage (0-100) to intensity (0-20)\n  const intensity = MathZ.map(MathZ.clamp(damage, 0, 100), 0, 100, 0, 20);\n  const duration = MathZ.map(MathZ.clamp(damage, 0, 100), 0, 100, 200, 600);\n\n  game.camera.shake(intensity, duration);\n}\n```\n\n### Random Color Generation\n\n```javascript\nimport { MathZ } from '@mode-7/zap';\n\nfunction randomColor() {\n  const r = MathZ.randomInt(0, 255);\n  const g = MathZ.randomInt(0, 255);\n  const b = MathZ.randomInt(0, 255);\n\n  return `rgb(${r}, ${g}, ${b})`;\n}\n\nsprite.color = randomColor();\n```\n\n### Weighted Random Choice\n\n```javascript\nimport { randomFloat } from '@mode-7/zap';\n\nfunction weightedRandom(items, weights) {\n  const total = weights.reduce((sum, w) => sum + w, 0);\n  let random = MathZ.randomFloat(0, total);\n\n  for (let i = 0; i < items.length; i++) {\n    random -= weights[i];\n    if (random <= 0) {\n      return items[i];\n    }\n  }\n\n  return items[items.length - 1];\n}\n\n// 70% common, 25% rare, 5% legendary\nconst loot = weightedRandom(\n  ['common', 'rare', 'legendary'],\n  [70, 25, 5]\n);\n```\n\n## API Reference\n\n### `clamp(value, min, max)`\n\nConstrain a value between min and max.\n\n**Parameters**:\n- `value` (number) - Value to clamp\n- `min` (number) - Minimum value\n- `max` (number) - Maximum value\n\n**Returns**: number\n\n```javascript\nclamp(150, 0, 100);   // Returns 100\nclamp(-10, 0, 100);   // Returns 0\nclamp(50, 0, 100);    // Returns 50\n```\n\n### `lerp(start, end, t)`\n\nLinear interpolation between two values.\n\n**Parameters**:\n- `start` (number) - Start value\n- `end` (number) - End value\n- `t` (number) - Interpolation factor (0-1)\n\n**Returns**: number\n\n```javascript\nlerp(0, 100, 0);     // Returns 0\nlerp(0, 100, 0.5);   // Returns 50\nlerp(0, 100, 1);     // Returns 100\nlerp(0, 100, 0.25);  // Returns 25\n```\n\n### `map(value, inMin, inMax, outMin, outMax)`\n\nMap a value from one range to another.\n\n**Parameters**:\n- `value` (number) - Value to map\n- `inMin` (number) - Input range minimum\n- `inMax` (number) - Input range maximum\n- `outMin` (number) - Output range minimum\n- `outMax` (number) - Output range maximum\n\n**Returns**: number\n\n```javascript\nmap(50, 0, 100, 0, 1);        // Returns 0.5\nmap(200, 0, 400, 0, Math.PI * 2);  // Returns π\nmap(75, 0, 100, 0, 255);      // Returns 191.25\n```\n\n### `randomInt(min, max)`\n\nGenerate random integer (inclusive).\n\n**Parameters**:\n- `min` (number) - Minimum value (inclusive)\n- `max` (number) - Maximum value (inclusive)\n\n**Returns**: number\n\n```javascript\nrandomInt(1, 6);     // Returns 1, 2, 3, 4, 5, or 6\nrandomInt(0, 10);    // Returns 0 through 10\nrandomInt(100, 200); // Returns 100 through 200\n```\n\n### `randomFloat(min, max)`\n\nGenerate random float.\n\n**Parameters**:\n- `min` (number) - Minimum value\n- `max` (number) - Maximum value\n\n**Returns**: number\n\n```javascript\nrandomFloat(0, 1);      // Returns 0.0 to 1.0\nrandomFloat(50, 150);   // Returns 50.0 to 150.0\nrandomFloat(-1, 1);     // Returns -1.0 to 1.0\n```\n\n### `randomItem(items)`\n\nPick random item from array.\n\n**Parameters**:\n- `items` (T[]) - Array of items\n\n**Returns**: T\n\n```javascript\nrandomItem([1, 2, 3, 4, 5]);           // Returns random number\nrandomItem(['red', 'blue', 'green']);  // Returns random color\nrandomItem([weapon1, weapon2]);        // Returns random weapon\n```\n\n## Tips\n\n- **Use clamp for boundaries** - Prevent values from going out of range\n- **Use lerp for smooth motion** - Better than instant jumps\n- **Use map for conversions** - Convert between different value ranges\n- **Random for variety** - Add unpredictability to games\n- **Combine functions** - Use together for complex behaviors\n\n## Common Mistakes\n\n### Lerp with t > 1\n\n```javascript\n// ❌ Wrong - t should be 0-1\nconst x = lerp(0, 100, 5);  // Overshoots to 500!\n\n// ✅ Right - clamp t to 0-1\nconst t = clamp(progress, 0, 1);\nconst x = lerp(0, 100, t);\n```\n\n### Map with inverted ranges\n\n```javascript\n// ❌ Wrong - ranges don't match direction\nconst volume = map(distance, 0, 500, 0, 1);  // Volume increases with distance!\n\n// ✅ Right - flip output range\nconst volume = map(distance, 0, 500, 1, 0);  // Volume decreases with distance\n```\n\n### randomInt off-by-one\n\n```javascript\n// ❌ Wrong - won't include 6\nconst roll = randomInt(1, 5);  // Only 1-5\n\n// ✅ Right - inclusive max\nconst roll = randomInt(1, 6);  // 1-6 (proper die roll)\n```\n\n## Next Steps\n\n- [Layout](/utilities/layout) - Uses math for positioning\n- [Tweening](/animation/tweening) - Smooth animations with lerp\n- [Camera](/core/camera) - Clamping and smooth following"
      },
      {
        "slug": "utilities/storage",
        "title": "Storage",
        "description": "Save and load game data with localStorage",
        "path": "utilities/storage.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/utilities/storage.md",
        "content": "# Storage\n\nThe Storage utility provides easy localStorage access for persisting game data, with automatic JSON serialization and type-safe retrieval.\n\n## Save Data\n\nStore data in localStorage:\n\n```codemirror\nimport { Game, Scene, Sprite, Text, Storage } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nlet score = 0;\n\nconst scoreText = new Text({\n  text: `Score: ${score}`,\n  x: 200,\n  y: 100,\n  fontSize: 20,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nconst button = new Sprite({\n  x: 200,\n  y: 150,\n  width: 120,\n  height: 50,\n  color: '#51cf66',\n  radius: 8,\n  interactive: true\n});\n\nconst buttonLabel = new Text({\n  text: 'Add Point',\n  fontSize: 14,\n  color: '#fff',\n  align: 'center',\n  baseline: 'middle'\n});\n\nbutton.addChild(buttonLabel);\n\nbutton.on('tap', () => {\n  score++;\n  scoreText.text = `Score: ${score}`;\n\n  // Save score\n  Storage.set('score', score);\n});\n\nscene.add(scoreText);\nscene.add(button);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Load Data\n\nRetrieve saved data:\n\n```javascript\nimport { Storage } from '@mode-7/zap';\n\n// Load score (returns null if not found)\nconst score = Storage.get('score');\n\nif (score !== null) {\n  console.log('Loaded score:', score);\n} else {\n  console.log('No saved score');\n}\n\n// Load with default value\nconst highScore = Storage.get('highScore', 0);\n```\n\n## Store Objects\n\nSave complex data structures:\n\n```javascript\nimport { Storage } from '@mode-7/zap';\n\n// Save player data\nconst playerData = {\n  name: 'Player1',\n  level: 5,\n  health: 100,\n  position: { x: 200, y: 150 },\n  inventory: ['sword', 'shield', 'potion']\n};\n\nStorage.set('player', playerData);\n\n// Load player data\nconst loadedPlayer = Storage.get('player');\nconsole.log(loadedPlayer.name);       // 'Player1'\nconsole.log(loadedPlayer.level);      // 5\nconsole.log(loadedPlayer.inventory);  // ['sword', 'shield', 'potion']\n```\n\n## Delete Data\n\nRemove specific saved data:\n\n```codemirror\nimport { Game, Scene, Sprite, Text, Storage } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\n// Save initial score\nStorage.set('score', 100);\n\nconst status = new Text({\n  text: 'Score saved: 100',\n  x: 200,\n  y: 100,\n  fontSize: 16,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nconst deleteBtn = new Sprite({\n  x: 200,\n  y: 150,\n  width: 140,\n  height: 45,\n  color: '#e94560',\n  radius: 8,\n  interactive: true\n});\n\nconst deleteLabel = new Text({\n  text: 'Delete Score',\n  fontSize: 14,\n  color: '#fff',\n  align: 'center',\n  baseline: 'middle'\n});\n\ndeleteBtn.addChild(deleteLabel);\n\ndeleteBtn.on('tap', () => {\n  Storage.remove('score');\n  status.text = 'Score deleted!';\n  status.color = '#888';\n});\n\nscene.add(status);\nscene.add(deleteBtn);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Clear All Data\n\nRemove all game data:\n\n```javascript\nimport { Storage } from '@mode-7/zap';\n\n// Clear all saved game data\nStorage.clear();\n\nconsole.log('All game data cleared');\n```\n\n## Check if Exists\n\nCheck if a key exists in storage:\n\n```javascript\nimport { Storage } from '@mode-7/zap';\n\nif (Storage.has('player')) {\n  // Load existing save\n  const player = Storage.get('player');\n  console.log('Continuing game...');\n} else {\n  // New game\n  console.log('Starting new game...');\n}\n```\n\n## List All Keys\n\nGet all saved keys:\n\n```javascript\nimport { Storage } from '@mode-7/zap';\n\nconst keys = Storage.keys();\nconsole.log('Saved data:', keys);  // ['score', 'highScore', 'player', ...]\n```\n\n## Common Patterns\n\n### Save/Load Game State\n\nComplete game state management:\n\n```javascript\nfunction saveGame() {\n  const gameState = {\n    score: player.score,\n    level: currentLevel,\n    position: { x: player.x, y: player.y },\n    health: player.health,\n    inventory: player.inventory,\n    timestamp: Date.now()\n  };\n\n  Storage.set('saveGame', gameState);\n  console.log('Game saved!');\n}\n\nfunction loadGame() {\n  const saveData = Storage.get('saveGame');\n\n  if (saveData) {\n    player.score = saveData.score;\n    currentLevel = saveData.level;\n    player.x = saveData.position.x;\n    player.y = saveData.position.y;\n    player.health = saveData.health;\n    player.inventory = saveData.inventory;\n\n    console.log('Game loaded!');\n    return true;\n  }\n\n  return false;\n}\n\n// Auto-save every 30 seconds\ninterval(30000, saveGame);\n```\n\n### High Score System\n\nTrack and display high scores:\n\n```javascript\nfunction checkHighScore(score) {\n  const currentHigh = Storage.get('highScore', 0);\n\n  if (score > currentHigh) {\n    Storage.set('highScore', score);\n    showMessage('New High Score!');\n    return true;\n  }\n\n  return false;\n}\n\n// Usage\nif (checkHighScore(playerScore)) {\n  // Celebrate!\n}\n```\n\n### Settings Menu\n\nSave player preferences:\n\n```javascript\n// Default settings\nconst defaultSettings = {\n  soundEnabled: true,\n  musicEnabled: true,\n  volume: 0.7,\n  difficulty: 'normal'\n};\n\n// Load settings\nfunction loadSettings() {\n  return Storage.get('settings', defaultSettings);\n}\n\n// Save settings\nfunction saveSettings(settings) {\n  Storage.set('settings', settings);\n}\n\n// Usage\nconst settings = loadSettings();\n\nif (settings.soundEnabled) {\n  playSound('click');\n}\n```\n\n### Level Progress\n\nTrack completed levels:\n\n```javascript\nfunction unlockLevel(levelNumber) {\n  const progress = Storage.get('levelProgress', []);\n\n  if (!progress.includes(levelNumber)) {\n    progress.push(levelNumber);\n    Storage.set('levelProgress', progress);\n  }\n}\n\nfunction isLevelUnlocked(levelNumber) {\n  const progress = Storage.get('levelProgress', []);\n  return levelNumber === 1 || progress.includes(levelNumber - 1);\n}\n\n// Usage\nunlockLevel(5);\nif (isLevelUnlocked(5)) {\n  startLevel(5);\n}\n```\n\n### Achievement System\n\nTrack player achievements:\n\n```javascript\nfunction unlockAchievement(id, name) {\n  const achievements = Storage.get('achievements', {});\n\n  if (!achievements[id]) {\n    achievements[id] = {\n      name,\n      unlockedAt: Date.now()\n    };\n\n    Storage.set('achievements', achievements);\n    showAchievementNotification(name);\n  }\n}\n\nfunction hasAchievement(id) {\n  const achievements = Storage.get('achievements', {});\n  return achievements.hasOwnProperty(id);\n}\n\n// Usage\nunlockAchievement('first_win', 'First Victory');\n```\n\n### Multiple Save Slots\n\nManage multiple save files:\n\n```javascript\nfunction saveToSlot(slot, gameState) {\n  Storage.set(`save_slot_${slot}`, {\n    ...gameState,\n    savedAt: Date.now()\n  });\n}\n\nfunction loadFromSlot(slot) {\n  return Storage.get(`save_slot_${slot}`);\n}\n\nfunction deleteSlot(slot) {\n  Storage.remove(`save_slot_${slot}`);\n}\n\nfunction getSaveSlots() {\n  return [1, 2, 3].map(slot => ({\n    slot,\n    data: loadFromSlot(slot)\n  }));\n}\n\n// Usage\nsaveToSlot(1, gameState);  // Save to slot 1\nconst save = loadFromSlot(1);  // Load from slot 1\n```\n\n### Statistics Tracking\n\nTrack player statistics:\n\n```javascript\nfunction incrementStat(stat, amount = 1) {\n  const stats = Storage.get('stats', {});\n  stats[stat] = (stats[stat] || 0) + amount;\n  Storage.set('stats', stats);\n}\n\nfunction getStat(stat) {\n  const stats = Storage.get('stats', {});\n  return stats[stat] || 0;\n}\n\n// Usage\nincrementStat('enemiesDefeated');\nincrementStat('coinsCollected', 10);\n\nconsole.log('Enemies defeated:', getStat('enemiesDefeated'));\n```\n\n### First-Time User Detection\n\nDetect new vs returning users:\n\n```javascript\nfunction isFirstVisit() {\n  return !Storage.has('hasVisited');\n}\n\nfunction markVisited() {\n  Storage.set('hasVisited', true);\n  Storage.set('firstVisitDate', Date.now());\n}\n\n// Show tutorial for first-time users\nif (isFirstVisit()) {\n  showTutorial();\n  markVisited();\n}\n```\n\n### Last Played Timestamp\n\nTrack when user last played:\n\n```javascript\nfunction updateLastPlayed() {\n  Storage.set('lastPlayed', Date.now());\n}\n\nfunction getTimeSinceLastPlayed() {\n  const lastPlayed = Storage.get('lastPlayed');\n\n  if (!lastPlayed) return null;\n\n  const elapsed = Date.now() - lastPlayed;\n  const hours = elapsed / (1000 * 60 * 60);\n\n  return hours;\n}\n\n// Welcome back message\nconst hoursSince = getTimeSinceLastPlayed();\n\nif (hoursSince && hoursSince > 24) {\n  showMessage('Welcome back!');\n}\n\nupdateLastPlayed();\n```\n\n### Daily Rewards\n\nImplement daily login rewards:\n\n```javascript\nfunction canClaimDailyReward() {\n  const lastClaim = Storage.get('lastDailyReward');\n\n  if (!lastClaim) return true;\n\n  const hoursSince = (Date.now() - lastClaim) / (1000 * 60 * 60);\n  return hoursSince >= 24;\n}\n\nfunction claimDailyReward() {\n  if (canClaimDailyReward()) {\n    Storage.set('lastDailyReward', Date.now());\n\n    // Increment streak\n    const streak = Storage.get('loginStreak', 0);\n    Storage.set('loginStreak', streak + 1);\n\n    giveReward();\n    return true;\n  }\n\n  return false;\n}\n```\n\n### Migration/Versioning\n\nHandle save data format changes:\n\n```javascript\nconst CURRENT_VERSION = 2;\n\nfunction migrateData() {\n  const version = Storage.get('dataVersion', 1);\n\n  if (version < 2) {\n    // Migrate from v1 to v2\n    const oldPlayer = Storage.get('player');\n    if (oldPlayer) {\n      oldPlayer.newField = 'defaultValue';\n      Storage.set('player', oldPlayer);\n    }\n  }\n\n  Storage.set('dataVersion', CURRENT_VERSION);\n}\n\n// Run on game start\nmigrateData();\n```\n\n## Type Safety\n\nUse TypeScript for type-safe storage:\n\n```typescript\ninterface PlayerData {\n  name: string;\n  level: number;\n  score: number;\n  inventory: string[];\n}\n\n// Type-safe save\nconst player: PlayerData = {\n  name: 'Hero',\n  level: 5,\n  score: 1000,\n  inventory: ['sword']\n};\n\nStorage.set<PlayerData>('player', player);\n\n// Type-safe load\nconst loaded = Storage.get<PlayerData>('player');\nconsole.log(loaded?.name);  // TypeScript knows this is a string\n```\n\n## Storage Limits\n\nBe aware of localStorage limits:\n\n```javascript\n// Check available space (approximate)\nfunction getStorageSize() {\n  let total = 0;\n  const keys = Storage.keys();\n\n  keys.forEach(key => {\n    const value = Storage.get(key);\n    total += JSON.stringify(value).length;\n  });\n\n  const kb = total / 1024;\n  const mb = kb / 1024;\n\n  return { bytes: total, kb, mb };\n}\n\nconst size = getStorageSize();\nconsole.log(`Storage used: ${size.kb.toFixed(2)} KB`);\n```\n\n## API Reference\n\n### `Storage.set(key, data)`\n\nStore data in localStorage.\n\n**Parameters**:\n- `key` (string) - Storage key\n- `data` (any) - Data to store (auto-serialized to JSON)\n\n**Returns**: void\n\n```javascript\nStorage.set('score', 100);\nStorage.set('player', { name: 'Hero', level: 5 });\n```\n\n### `Storage.get(key, defaultValue?)`\n\nRetrieve data from localStorage.\n\n**Parameters**:\n- `key` (string) - Storage key\n- `defaultValue` (any) - Optional default if key doesn't exist\n\n**Returns**: Stored data or default value or null\n\n```javascript\nconst score = Storage.get('score');  // null if not found\nconst highScore = Storage.get('highScore', 0);  // 0 if not found\n```\n\n### `Storage.remove(key)`\n\nDelete specific key from localStorage.\n\n**Parameters**:\n- `key` (string) - Storage key to remove\n\n**Returns**: void\n\n```javascript\nStorage.remove('score');\n```\n\n### `Storage.clear()`\n\nRemove all game data (keys with \"zap_\" prefix).\n\n**Returns**: void\n\n```javascript\nStorage.clear();\n```\n\n### `Storage.has(key)`\n\nCheck if key exists in storage.\n\n**Parameters**:\n- `key` (string) - Storage key\n\n**Returns**: boolean\n\n```javascript\nif (Storage.has('player')) {\n  // Load existing save\n}\n```\n\n### `Storage.keys()`\n\nGet all storage keys (without \"zap_\" prefix).\n\n**Returns**: string[]\n\n```javascript\nconst keys = Storage.keys();\nconsole.log('Saved keys:', keys);\n```\n\n## Best Practices\n\n- **Save frequently** - Auto-save progress to prevent data loss\n- **Validate loaded data** - Check data structure before using\n- **Use default values** - Provide sensible defaults with `get()`\n- **Handle errors gracefully** - Storage can fail (private browsing, quota exceeded)\n- **Keep data small** - LocalStorage has size limits (~5-10MB)\n- **Clear old saves** - Remove outdated data\n\n## Common Mistakes\n\n### Not providing defaults\n\n```javascript\n// ❌ Wrong - might be null\nconst score = Storage.get('score');\nconst newScore = score + 10;  // Error if score is null!\n\n// ✅ Right - provide default\nconst score = Storage.get('score', 0);\nconst newScore = score + 10;  // Safe\n```\n\n### Forgetting to save\n\n```javascript\n// ❌ Wrong - changes not saved\nplayer.score += 100;\n// Lost on page reload!\n\n// ✅ Right - save changes\nplayer.score += 100;\nStorage.set('player', player);\n```\n\n### Storing functions\n\n```javascript\n// ❌ Wrong - functions can't be serialized\nconst obj = {\n  name: 'Player',\n  move: function() { /* ... */ }\n};\nStorage.set('player', obj);  // move() will be lost!\n\n// ✅ Right - only store data\nconst obj = {\n  name: 'Player',\n  x: 100,\n  y: 100\n};\nStorage.set('player', obj);\n```\n\n## Tips\n\n- **Auto-save on important events** - Level completion, score milestones\n- **Clear on reset** - Use `Storage.clear()` for \"reset game\" functionality\n- **Namespace your keys** - Use prefixes for organization: `level_1_score`\n- **Test private browsing** - localStorage may not work in private mode\n- **Compress large data** - Consider compression for large save files\n- **Backup important saves** - Provide export/import functionality\n\n## Next Steps\n\n- [Timers](/utilities/timers) - Auto-save with intervals\n- [Scenes](/core/scenes) - Save/load scene state\n- [Game](/core/game) - Initialize from saved data"
      },
      {
        "slug": "utilities/timers",
        "title": "Timers",
        "description": "Delays, intervals, and time-based utilities",
        "path": "utilities/timers.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/utilities/timers.md",
        "content": "# Timers\n\nZap provides timer utilities for delays, intervals, and time-based game logic with easy cancellation and management.\n\n## Delay\n\nExecute a callback after a delay:\n\n```codemirror\nimport { Game, Scene, Sprite, Text, delay } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst box = new Sprite({\n  x: 200,\n  y: 150,\n  width: 80,\n  height: 80,\n  color: '#e94560',\n  radius: 8,\n  interactive: true\n});\n\nconst label = new Text({\n  text: 'Click me!',\n  x: 200,\n  y: 230,\n  fontSize: 14,\n  color: '#888',\n  align: 'center'\n});\n\nbox.on('tap', () => {\n  label.text = 'Exploding in 2 seconds...';\n  label.color = '#f39c12';\n\n  // Execute after 2 seconds\n  delay(2000, () => {\n    box.visible = false;\n    label.text = 'Boom!';\n    label.color = '#e94560';\n  });\n});\n\nscene.add(box);\nscene.add(label);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Interval\n\nExecute a callback repeatedly at regular intervals:\n\n```codemirror\nimport { Game, Scene, Text, interval } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nlet count = 0;\n\nconst counter = new Text({\n  text: `Count: ${count}`,\n  x: 200,\n  y: 150,\n  fontSize: 24,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nscene.add(counter);\n\n// Increment every second\ninterval(1000, () => {\n  count++;\n  counter.text = `Count: ${count}`;\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Wait (Async)\n\nPromise-based delay for async/await:\n\n```javascript\nimport { wait } from '@mode-7/zap';\n\nasync function sequence() {\n  console.log('Starting...');\n\n  await wait(1000);\n  console.log('1 second passed');\n\n  await wait(1000);\n  console.log('2 seconds passed');\n\n  await wait(1000);\n  console.log('3 seconds passed');\n}\n\nsequence();\n```\n\n## Cancel Timers\n\nCancel delays and intervals before they execute:\n\n```codemirror\nimport { Game, Scene, Sprite, Text, delay } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst box = new Sprite({\n  x: 200,\n  y: 120,\n  width: 80,\n  height: 80,\n  color: '#e94560',\n  radius: 8,\n  interactive: true\n});\n\nconst cancelBtn = new Sprite({\n  x: 200,\n  y: 200,\n  width: 100,\n  height: 40,\n  color: '#888',\n  radius: 6,\n  interactive: true\n});\n\nconst cancelLabel = new Text({\n  text: 'Cancel',\n  fontSize: 14,\n  color: '#fff',\n  align: 'center',\n  baseline: 'middle'\n});\n\ncancelBtn.addChild(cancelLabel);\n\nconst status = new Text({\n  text: 'Click box to start timer',\n  x: 200,\n  y: 260,\n  fontSize: 12,\n  color: '#888',\n  align: 'center'\n});\n\nlet timer = null;\n\nbox.on('tap', () => {\n  status.text = 'Timer started (3s)...';\n  status.color = '#4fc3f7';\n\n  timer = delay(3000, () => {\n    box.visible = false;\n    status.text = 'Box disappeared!';\n  });\n});\n\ncancelBtn.on('tap', () => {\n  if (timer) {\n    timer.cancel();\n    status.text = 'Timer cancelled!';\n    status.color = '#f39c12';\n    timer = null;\n  }\n});\n\nscene.add(box);\nscene.add(cancelBtn);\nscene.add(status);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Common Patterns\n\n### Countdown Timer\n\nCreate a countdown:\n\n```javascript\nimport { interval } from '@mode-7/zap';\n\nlet timeLeft = 60;  // 60 seconds\n\nconst timer = interval(1000, () => {\n  timeLeft--;\n  countdownText.text = `Time: ${timeLeft}s`;\n\n  if (timeLeft <= 0) {\n    timer.cancel();\n    gameOver();\n  }\n});\n```\n\n### Respawn Timer\n\nDelay before respawning:\n\n```javascript\nplayer.on('death', () => {\n  player.visible = false;\n\n  delay(3000, () => {\n    player.x = spawnPoint.x;\n    player.y = spawnPoint.y;\n    player.health = 100;\n    player.visible = true;\n  });\n});\n```\n\n### Flash Effect\n\nMake an element flash repeatedly:\n\n```javascript\nimport { interval } from '@mode-7/zap';\n\nlet flashCount = 0;\nconst maxFlashes = 6;\n\nconst flashTimer = interval(200, () => {\n  sprite.visible = !sprite.visible;\n  flashCount++;\n\n  if (flashCount >= maxFlashes) {\n    flashTimer.cancel();\n    sprite.visible = true;\n  }\n});\n```\n\n### Power-Up Duration\n\nTemporary power-up:\n\n```javascript\nfunction activatePowerUp(duration) {\n  player.speed *= 2;\n  player.color = '#f39c12';\n\n  delay(duration, () => {\n    player.speed /= 2;\n    player.color = '#4fc3f7';\n  });\n}\n\n// 5-second speed boost\nactivatePowerUp(5000);\n```\n\n### Sequential Events\n\nChain multiple timed events:\n\n```javascript\nimport { wait } from '@mode-7/zap';\n\nasync function intro() {\n  titleText.text = 'Welcome';\n  await wait(1500);\n\n  titleText.text = 'to';\n  await wait(1000);\n\n  titleText.text = 'My Game!';\n  await wait(2000);\n\n  // Start game\n  game.setScene(gameScene);\n}\n\nintro();\n```\n\n### Spawn Waves\n\nSpawn enemies in waves:\n\n```javascript\nimport { interval } from '@mode-7/zap';\n\nlet wave = 1;\n\nconst waveTimer = interval(10000, () => {\n  console.log(`Spawning wave ${wave}`);\n\n  for (let i = 0; i < wave * 3; i++) {\n    spawnEnemy();\n  }\n\n  wave++;\n\n  if (wave > 10) {\n    waveTimer.cancel();\n    console.log('All waves complete!');\n  }\n});\n```\n\n### Auto-Save\n\nPeriodic auto-save:\n\n```javascript\nimport { interval } from '@mode-7/zap';\n\n// Auto-save every 30 seconds\ninterval(30000, () => {\n  saveGame();\n  console.log('Game auto-saved');\n});\n```\n\n### Delayed Message\n\nShow temporary message:\n\n```javascript\nfunction showMessage(text, duration = 2000) {\n  messageText.text = text;\n  messageText.visible = true;\n\n  delay(duration, () => {\n    messageText.visible = false;\n  });\n}\n\n// Usage\nshowMessage('Level Complete!', 3000);\n```\n\n### Blinking Cursor\n\nAnimated cursor effect:\n\n```javascript\nimport { interval } from '@mode-7/zap';\n\ninterval(500, () => {\n  cursor.visible = !cursor.visible;\n});\n```\n\n### Combo Timer\n\nReset combo after inactivity:\n\n```javascript\nlet comboCount = 0;\nlet comboTimer = null;\n\nfunction registerHit() {\n  comboCount++;\n  comboText.text = `Combo x${comboCount}`;\n\n  // Cancel existing timer\n  if (comboTimer) {\n    comboTimer.cancel();\n  }\n\n  // Reset combo after 2 seconds of no hits\n  comboTimer = delay(2000, () => {\n    comboCount = 0;\n    comboText.text = '';\n  });\n}\n```\n\n### Animation Loop\n\nSimple repeating animation:\n\n```javascript\nimport { wait } from '@mode-7/zap';\n\nasync function animateLoop() {\n  while (true) {\n    await sprite.tween({ y: 200 }, { duration: 1000 });\n    await wait(500);\n    await sprite.tween({ y: 100 }, { duration: 1000 });\n    await wait(500);\n  }\n}\n\nanimateLoop();\n```\n\n### Delayed Callback Chain\n\nExecute callbacks in sequence:\n\n```javascript\nimport { delay } from '@mode-7/zap';\n\ndelay(1000, () => {\n  console.log('Step 1');\n\n  delay(1000, () => {\n    console.log('Step 2');\n\n    delay(1000, () => {\n      console.log('Step 3');\n    });\n  });\n});\n\n// Better with async/await\nasync function steps() {\n  await wait(1000);\n  console.log('Step 1');\n\n  await wait(1000);\n  console.log('Step 2');\n\n  await wait(1000);\n  console.log('Step 3');\n}\n```\n\n### Rate Limiting\n\nPrevent rapid repeated actions:\n\n```javascript\nlet canFire = true;\n\nbutton.on('tap', () => {\n  if (!canFire) return;\n\n  fireBullet();\n  canFire = false;\n\n  // Cooldown\n  delay(500, () => {\n    canFire = true;\n  });\n});\n```\n\n### Timed Challenge\n\nTime-limited task:\n\n```javascript\nfunction startChallenge() {\n  challengeActive = true;\n  challengeText.text = 'Collect 10 coins in 30 seconds!';\n\n  delay(30000, () => {\n    challengeActive = false;\n\n    if (coinsCollected >= 10) {\n      showMessage('Challenge Complete!');\n    } else {\n      showMessage('Challenge Failed!');\n    }\n  });\n}\n```\n\n## Clear All Timers\n\nCancel all active timers at once:\n\n```javascript\nimport { timerManager } from '@mode-7/zap';\n\n// When changing scenes or ending game\ntimerManager.clearAll();\n```\n\n## API Reference\n\n### `delay(ms, callback)`\n\nExecute callback after delay.\n\n**Parameters**:\n- `ms` (number) - Delay in milliseconds\n- `callback` (function) - Function to execute\n\n**Returns**: TimerHandle with `cancel()` method\n\n```javascript\nconst timer = delay(2000, () => {\n  console.log('2 seconds later');\n});\n\n// Cancel if needed\ntimer.cancel();\n```\n\n### `interval(ms, callback)`\n\nExecute callback repeatedly at interval.\n\n**Parameters**:\n- `ms` (number) - Interval in milliseconds\n- `callback` (function) - Function to execute\n\n**Returns**: TimerHandle with `cancel()` method\n\n```javascript\nconst timer = interval(1000, () => {\n  console.log('Every second');\n});\n\n// Stop interval\ntimer.cancel();\n```\n\n### `wait(ms)`\n\nPromise-based delay.\n\n**Parameters**:\n- `ms` (number) - Delay in milliseconds\n\n**Returns**: Promise<void>\n\n```javascript\nawait wait(1000);\nconsole.log('1 second later');\n```\n\n### `timerManager.clearAll()`\n\nCancel all active timers.\n\n**Returns**: void\n\n```javascript\ntimerManager.clearAll();\n```\n\n## Delay vs Wait\n\nChoose based on your needs:\n\n### Use `delay()` for:\n\n- Simple callbacks\n- Non-async code\n- When you need cancellation\n\n```javascript\nconst timer = delay(1000, () => {\n  console.log('Done');\n});\n\ntimer.cancel();  // Can cancel\n```\n\n### Use `wait()` for:\n\n- Async/await code\n- Sequential operations\n- Promise chains\n\n```javascript\nasync function sequence() {\n  await wait(1000);\n  console.log('Step 1');\n\n  await wait(1000);\n  console.log('Step 2');\n}\n```\n\n## Performance Considerations\n\n- **Use timers wisely**: Too many timers can impact performance\n- **Cancel when done**: Always cancel timers you don't need\n- **Clear on scene change**: Use `clearAll()` when switching scenes\n- **Prefer tweens for animation**: Use tweens instead of intervals for smooth animation\n\n## Common Mistakes\n\n### Forgetting to cancel\n\n```javascript\n// ❌ Wrong - timer keeps running\nfunction startGame() {\n  interval(1000, updateScore);\n}\n\n// Call multiple times = multiple intervals!\nstartGame();\nstartGame();\nstartGame();\n\n// ✅ Right - store and cancel previous\nlet scoreTimer = null;\n\nfunction startGame() {\n  if (scoreTimer) {\n    scoreTimer.cancel();\n  }\n  scoreTimer = interval(1000, updateScore);\n}\n```\n\n### Using delay instead of tween\n\n```javascript\n// ❌ Wrong - choppy animation\nlet x = 0;\ninterval(16, () => {\n  x += 1;\n  sprite.x = x;\n});\n\n// ✅ Right - smooth tween\nsprite.tween({ x: 100 }, { duration: 1000 });\n```\n\n### Not handling scene changes\n\n```javascript\n// ❌ Wrong - timers continue after scene change\ndelay(5000, () => {\n  // This runs even if scene changed!\n  gameScene.showMessage('Time up!');\n});\n\ngame.setScene(menuScene);  // Scene changed, but timer still runs\n\n// ✅ Right - clear timers on scene change\ntimerManager.clearAll();\ngame.setScene(menuScene);\n```\n\n## Tips\n\n- **Store timer handles** - Keep references if you need to cancel\n- **Use wait() for sequences** - Cleaner than nested delays\n- **Clear on cleanup** - Cancel timers in cleanup/destroy methods\n- **Avoid tiny intervals** - Use 16ms minimum (60fps), prefer tweens for animation\n- **Name your timers** - Use descriptive variable names (e.g., `respawnTimer`)\n\n## Next Steps\n\n- [Tweening](/animation/tweening) - Smooth property animations\n- [Scenes](/core/scenes) - Managing game scenes\n- [Storage](/utilities/storage) - Saving timer state"
      }
    ],
    "visual": [
      {
        "slug": "visual/animation",
        "title": "Sprite Animation",
        "description": "Frame-based sprite sheet animations",
        "path": "visual/animation.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/visual/animation.md",
        "content": "# Sprite Animation\n\nSprite supports frame-based animations from sprite sheets. Define multiple named animations and play them on demand with configurable frame rates and looping.\n\n## Basic Animation\n\nCreate an animated Sprite by specifying `frameWidth`, `frameHeight`, and `animations`:\n\n```javascript\nimport { Sprite } from '@mode-7/zap';\n\nconst hero = new Sprite({\n  x: 200,\n  y: 150,\n  width: 64,\n  height: 64,\n  image: '/assets/spritesheet.png',\n  frameWidth: 64,\n  frameHeight: 64,\n  animations: {\n    idle: { frames: [0, 1, 2, 3], fps: 6, loop: true },\n    run: { frames: [4, 5, 6, 7], fps: 12, loop: true },\n    jump: { frames: [8, 9], fps: 10, loop: false }\n  }\n});\n\n// Play an animation\nhero.play('idle');\n```\n\n## Animation Properties\n\nEach animation has three properties:\n\n- **frames**: Array of frame indices (0-based, left-to-right, top-to-bottom)\n- **fps**: Frames per second (optional, default: 10)\n- **loop**: Whether to loop (optional, default: true)\n\n```javascript\nanimations: {\n  walk: {\n    frames: [0, 1, 2, 3],\n    fps: 8,\n    loop: true\n  }\n}\n```\n\n## Interactive Animation Demo\n\n```codemirror\nimport { Game, Scene, Sprite, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst hero = new Sprite({\n  x: 200,\n  y: 140,\n  width: 64,\n  height: 64,\n  image: '../assets/robot.png',\n  frameWidth: 64,\n  frameHeight: 64,\n  animations: {\n    idle: { frames: [0, 1, 2, 3], fps: 6, loop: true }\n  },\n  interactive: true\n});\n\nconst status = new Text({\n  x: 200,\n  y: 220,\n  text: 'Tap to toggle animation',\n  fontSize: 14,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nscene.add(hero);\nscene.add(status);\n\nhero.play('idle');\n\nlet playing = true;\nhero.on('tap', () => {\n  if (playing) {\n    hero.pause();\n    status.text = 'Paused - Tap to resume';\n  } else {\n    hero.resume();\n    status.text = 'Playing - Tap to pause';\n  }\n  playing = !playing;\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Sprite Sheet Layout\n\nFrames are read from the sprite sheet left-to-right, top-to-bottom:\n\n```\nFrame indices in a 4x2 sprite sheet:\n┌───┬───┬───┬───┐\n│ 0 │ 1 │ 2 │ 3 │\n├───┼───┼───┼───┤\n│ 4 │ 5 │ 6 │ 7 │\n└───┴───┴───┴───┘\n```\n\nThe engine automatically calculates frame positions based on:\n- `frameWidth` and `frameHeight`\n- Total image dimensions\n- Frame index\n\n## Playing Animations\n\nUse `play()` to start an animation:\n\n```javascript\n// Play with default settings\nhero.play('walk');\n\n// Override fps\nhero.play('walk', { fps: 12 });\n\n// Override loop\nhero.play('jump', { loop: false });\n\n// Override both\nhero.play('attack', { fps: 15, loop: false });\n```\n\n## Animation Controls\n\nControl playback with these methods:\n\n```javascript\nhero.play('run');      // Start playing\nhero.pause();          // Pause (keeps current frame)\nhero.resume();         // Resume from paused state\nhero.stop();           // Stop (also pauses)\n```\n\n## Animation Events\n\nListen for when animations complete (non-looping only):\n\n```javascript\nhero.play('attack', { loop: false });\n\nhero.on('animationcomplete', (animationName) => {\n  console.log(`${animationName} finished!`);\n  hero.play('idle');  // Return to idle\n});\n```\n\n## Adding Animations Dynamically\n\nAdd animations after creation:\n\n```javascript\nconst sprite = new Sprite({\n  x: 200,\n  y: 150,\n  width: 64,\n  height: 64,\n  image: '/assets/sheet.png',\n  frameWidth: 64,\n  frameHeight: 64\n});\n\n// Add animation later\nsprite.addAnimation('dance', {\n  frames: [12, 13, 14, 15],\n  fps: 8,\n  loop: true\n});\n\nsprite.play('dance');\n```\n\n## Character with Multiple States\n\n```codemirror\nimport { Game, Scene, Sprite, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst character = new Sprite({\n  x: 200,\n  y: 180,\n  width: 72,\n  height: 72,\n  image: '../assets/robot.png',\n  frameWidth: 64,\n  frameHeight: 64,\n  animations: {\n    idle: { frames: [0, 1, 2, 3], fps: 6, loop: true },\n    jump: { frames: [4, 5, 6, 7], fps: 14, loop: false }\n  },\n  interactive: true\n});\n\nconst status = new Text({\n  x: 200,\n  y: 260,\n  text: 'Tap to jump',\n  fontSize: 14,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nscene.add(character);\nscene.add(status);\n\ncharacter.play('idle');\n\nlet jumping = false;\n\ncharacter.on('tap', () => {\n  if (jumping) return;\n\n  jumping = true;\n  status.text = 'Jumping!';\n  character.play('jump', { loop: false });\n\n  // Animate upward\n  const startY = character.y;\n  character.tween({ y: startY - 50 }, {\n    duration: 250,\n    easing: 'easeOutQuad'\n  }).then(() => {\n    character.tween({ y: startY }, {\n      duration: 250,\n      easing: 'easeInQuad'\n    });\n  });\n});\n\ncharacter.on('animationcomplete', (name) => {\n  if (name === 'jump') {\n    character.play('idle');\n    status.text = 'Tap to jump';\n    jumping = false;\n  }\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Performance Tips\n\n- **Sprite atlases**: Pack multiple animations into one image\n- **Power-of-2 frames**: Use frame sizes like 32, 64, 128 for best performance\n- **Reasonable FPS**: 8-12 FPS is often enough for smooth animation\n- **Stop unused animations**: Call `stop()` when animations aren't visible\n- **Reuse sprite sheets**: Share images between multiple sprites\n\n## Common Patterns\n\n### State Machine\n\n```javascript\nconst states = {\n  IDLE: 'idle',\n  WALK: 'walk',\n  JUMP: 'jump',\n  ATTACK: 'attack'\n};\n\nlet currentState = states.IDLE;\n\nfunction setState(newState) {\n  if (currentState === newState) return;\n  currentState = newState;\n  hero.play(newState);\n}\n\n// Example: change state based on input\nif (isMoving) {\n  setState(states.WALK);\n} else {\n  setState(states.IDLE);\n}\n```\n\n### Animation Chains\n\n```javascript\n// Play animations in sequence\nhero.play('windup', { loop: false });\n\nhero.on('animationcomplete', (name) => {\n  if (name === 'windup') {\n    hero.play('attack', { loop: false });\n  } else if (name === 'attack') {\n    hero.play('recover', { loop: false });\n  } else if (name === 'recover') {\n    hero.play('idle');\n  }\n});\n```\n\n### Direction-based Animation\n\n```javascript\nconst hero = new Sprite({\n  // ... setup\n  animations: {\n    'walk-right': { frames: [0, 1, 2, 3], fps: 8 },\n    'walk-left': { frames: [4, 5, 6, 7], fps: 8 },\n    'walk-up': { frames: [8, 9, 10, 11], fps: 8 },\n    'walk-down': { frames: [12, 13, 14, 15], fps: 8 }\n  }\n});\n\nfunction walk(direction) {\n  hero.play(`walk-${direction}`);\n}\n\nwalk('right');  // Play walk-right animation\n```\n\n## Next Steps\n\n- [Shapes](/visual/shapes) - Create colored shapes\n- [Sprites](/visual/sprites) - Load static images\n- [Text](/visual/text) - Render text\n- [Tweening](/animation/animations) - Smooth property animations"
      },
      {
        "slug": "visual/shapes",
        "title": "Shapes",
        "description": "Create colored rectangles, rounded rectangles, and circles",
        "path": "visual/shapes.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/visual/shapes.md",
        "content": "# Shapes\n\nSprites can render colored shapes including rectangles, rounded rectangles, and perfect circles. Shapes are the fastest rendering option in Zap.\n\n## Creating Shapes\n\nCreate a shape by specifying a `color` property and no `image`:\n\n```javascript\nimport { Sprite } from '@mode-7/zap';\n\nconst rect = new Sprite({\n  x: 200,\n  y: 150,\n  width: 80,\n  height: 60,\n  color: '#e94560'\n});\n```\n\n## Rectangle\n\nA basic rectangle with sharp corners:\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst rect = new Sprite({\n  x: 200,\n  y: 150,\n  width: 100,\n  height: 70,\n  color: '#e94560',\n  radius: 0  // Sharp corners (default)\n});\n\nscene.add(rect);\ngame.setScene(scene);\ngame.start();\n```\n\n## Rounded Rectangle\n\nAdd rounded corners with the `radius` property:\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst rounded = new Sprite({\n  x: 200,\n  y: 150,\n  width: 100,\n  height: 70,\n  color: '#4fc3f7',\n  radius: 15  // Rounded corners\n});\n\nscene.add(rounded);\ngame.setScene(scene);\ngame.start();\n```\n\nThe `radius` controls how rounded the corners are. Larger values create more rounded corners.\n\n## Circle\n\nCreate a perfect circle by setting `width` equal to `height` and `radius` to half the width:\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst circle = new Sprite({\n  x: 200,\n  y: 150,\n  width: 80,\n  height: 80,\n  radius: 40,  // radius = width / 2 for perfect circle\n  color: '#2ecc71'\n});\n\nscene.add(circle);\ngame.setScene(scene);\ngame.start();\n```\n\n**Formula for perfect circle**: `radius = width / 2` (where `width === height`)\n\n## Multiple Shapes\n\n```codemirror\nimport { Game, Scene, Sprite } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\n// Rectangle\nconst rect = new Sprite({\n  x: 100,\n  y: 150,\n  width: 60,\n  height: 80,\n  color: '#e94560'\n});\n\n// Rounded rectangle\nconst rounded = new Sprite({\n  x: 200,\n  y: 150,\n  width: 60,\n  height: 80,\n  color: '#f39c12',\n  radius: 10\n});\n\n// Circle\nconst circle = new Sprite({\n  x: 300,\n  y: 150,\n  width: 60,\n  height: 60,\n  radius: 30,\n  color: '#2ecc71'\n});\n\nscene.add(rect);\nscene.add(rounded);\nscene.add(circle);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Properties\n\nAll shape properties can be modified after creation:\n\n```javascript\nsprite.color = '#51cf66';      // Change color\nsprite.radius = 20;            // Change corner radius\nsprite.width = 120;            // Change size\nsprite.height = 90;\nsprite.alpha = 0.5;            // Make semi-transparent\n```\n\n## Performance Tips\n\n- **Shapes are fastest**: Colored shapes render faster than images\n- **Avoid transparency**: Fully opaque shapes (`alpha: 1`) render fastest\n- **Batch rendering**: Zap automatically batches shapes for optimal performance\n- **Reuse sprites**: Modify existing sprites instead of creating new ones\n\n## Common Patterns\n\n### Button-like Shape\n\n```javascript\nconst button = new Sprite({\n  x: 200,\n  y: 150,\n  width: 120,\n  height: 50,\n  color: '#667eea',\n  radius: 25,  // Half the height for pill shape\n  interactive: true\n});\n\nbutton.on('tap', () => {\n  button.color = '#5a67d8';  // Darken on tap\n});\n```\n\n### Animated Circle\n\n```javascript\nconst circle = new Sprite({\n  x: 200,\n  y: 150,\n  width: 40,\n  height: 40,\n  radius: 20,\n  color: '#4fc3f7'\n});\n\n// Pulse animation\ncircle.tween(\n  { scaleX: 1.5, scaleY: 1.5, alpha: 0.3 },\n  { duration: 1000, loop: true, easing: 'easeInOutQuad' }\n);\n```\n\n## Next Steps\n\n- [Sprites](/visual/sprites) - Load and display images\n- [Sprite Animation](/visual/animation) - Animate sprite sheets\n- [Text](/visual/text) - Render text"
      },
      {
        "slug": "visual/sprites",
        "title": "Image Sprites",
        "description": "Load and display images with Sprite",
        "path": "visual/sprites.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/visual/sprites.md",
        "content": "# Image Sprites\n\nSprites can display images loaded from URLs or image elements. They support automatic sizing, event handling, and all standard transform properties.\n\n## Loading Images\n\nLoad an image by providing a URL to the `image` property:\n\n```javascript\nimport { Sprite } from '@mode-7/zap';\n\nconst sprite = new Sprite({\n  x: 200,\n  y: 150,\n  width: 100,\n  height: 100,\n  image: '/assets/character.png'\n});\n\n// Listen for when the image loads\nsprite.on('imageload', (img) => {\n  console.log('Image loaded:', img.width, img.height);\n});\n```\n\n## Auto-Sizing\n\nIf you don't specify `width` and `height`, the sprite will automatically size to match the image dimensions:\n\n```javascript\nconst sprite = new Sprite({\n  x: 200,\n  y: 150,\n  image: '/assets/logo.png'  // Will use image's natural size\n});\n```\n\n## Using HTMLImageElement\n\nYou can also pass an existing `HTMLImageElement`:\n\n```javascript\nconst img = new Image();\nimg.src = '/assets/sprite.png';\n\nconst sprite = new Sprite({\n  x: 200,\n  y: 150,\n  width: 100,\n  height: 100,\n  image: img\n});\n```\n\n## Image Loading Demo\n\n```codemirror\nimport { Game, Scene, Sprite, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst sprite = new Sprite({\n  x: 200,\n  y: 120,\n  width: 100,\n  height: 100,\n  image: '../assets/pixel-girl.png',\n  scaleX: 0,\n  scaleY: 0\n});\n\nconst status = new Text({\n  x: 200,\n  y: 220,\n  text: 'Loading image...',\n  fontSize: 14,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nscene.add(sprite);\nscene.add(status);\n\n// Listen for when the image loads\nsprite.on('imageload', () => {\n  status.text = 'Image loaded!';\n  // Animate in\n  sprite.tween(\n    { scaleX: 1, scaleY: 1 },\n    { duration: 400, easing: 'easeOutBack' }\n  );\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Scaling Images\n\nControl how images are displayed with `width` and `height`:\n\n```javascript\n// Original size (if known)\nconst sprite1 = new Sprite({\n  x: 100,\n  y: 150,\n  width: 64,\n  height: 64,\n  image: '/assets/icon.png'\n});\n\n// Scaled up\nconst sprite2 = new Sprite({\n  x: 200,\n  y: 150,\n  width: 128,   // 2x larger\n  height: 128,\n  image: '/assets/icon.png'\n});\n\n// Scaled with transform\nsprite1.scaleX = 2;  // 2x width\nsprite1.scaleY = 2;  // 2x height\n```\n\n## Circular Clip\n\nCreate circular image sprites:\n\n```javascript\nconst avatar = new Sprite({\n  x: 200,\n  y: 150,\n  width: 80,\n  height: 80,\n  radius: 40,  // Half of width/height for circle\n  image: '/assets/profile.jpg'\n});\n```\n\n## Preloading Images\n\nUse AssetLoader to preload images before creating sprites:\n\n```javascript\nimport { assetLoader, Sprite } from '@mode-7/zap';\n\n// Preload images\nawait assetLoader.loadImages({\n  hero: '/assets/hero.png',\n  enemy: '/assets/enemy.png',\n  background: '/assets/bg.png'\n});\n\n// Use preloaded images\nconst hero = new Sprite({\n  x: 200,\n  y: 150,\n  width: 64,\n  height: 64,\n  image: assetLoader.getImage('hero')\n});\n```\n\n## Properties\n\nImage sprites support all sprite properties:\n\n```javascript\nsprite.x = 300;\nsprite.y = 200;\nsprite.rotation = Math.PI / 4;   // 45 degrees\nsprite.scaleX = 1.5;              // Scale width\nsprite.scaleY = 1.5;              // Scale height\nsprite.alpha = 0.8;               // 80% opacity\nsprite.anchorX = 0;               // Change anchor point\nsprite.anchorY = 0;\n```\n\n## Interactive Images\n\nMake images respond to touch/mouse events:\n\n```javascript\nconst sprite = new Sprite({\n  x: 200,\n  y: 150,\n  width: 100,\n  height: 100,\n  image: '/assets/button.png',\n  interactive: true  // Enable gestures\n});\n\nsprite.on('tap', () => {\n  sprite.tween(\n    { scaleX: 1.1, scaleY: 1.1 },\n    { duration: 100 }\n  ).then(() => {\n    sprite.tween(\n      { scaleX: 1, scaleY: 1 },\n      { duration: 100 }\n    );\n  });\n});\n```\n\n## Error Handling\n\nHandle image loading errors:\n\n```javascript\nconst sprite = new Sprite({\n  x: 200,\n  y: 150,\n  width: 100,\n  height: 100\n});\n\ntry {\n  await sprite.loadImage('/assets/missing.png');\n} catch (error) {\n  console.error('Failed to load image:', error);\n  // Fallback to colored sprite\n  sprite.color = '#e94560';\n}\n```\n\n## Performance Tips\n\n- **Preload images**: Use AssetLoader for better performance\n- **Reuse images**: Share Image objects between sprites\n- **Appropriate sizes**: Load images at the size you'll display them\n- **Sprite atlases**: Use sprite sheets for multiple images (see Animation docs)\n- **Power of 2**: Use power-of-2 dimensions (64, 128, 256, etc.) for best performance\n\n## Common Patterns\n\n### Card Sprite\n\n```javascript\nconst card = new Sprite({\n  x: 200,\n  y: 150,\n  width: 100,\n  height: 140,\n  image: '/assets/card-back.png',\n  radius: 8,  // Rounded corners\n  interactive: true\n});\n\ncard.on('tap', () => {\n  // Flip animation\n  card.tween(\n    { scaleX: 0, rotation: Math.PI },\n    { duration: 200 }\n  ).then(async () => {\n    await card.loadImage('/assets/card-front.png');\n    card.tween(\n      { scaleX: 1 },\n      { duration: 200 }\n    );\n  });\n});\n```\n\n### Parallax Background\n\n```javascript\nconst bg1 = new Sprite({\n  x: 400,\n  y: 300,\n  width: 800,\n  height: 600,\n  image: '/assets/bg-layer1.png',\n  zIndex: 0\n});\n\nconst bg2 = new Sprite({\n  x: 400,\n  y: 300,\n  width: 800,\n  height: 600,\n  image: '/assets/bg-layer2.png',\n  zIndex: 1\n});\n\n// Move backgrounds at different speeds\ngame.on('update', (dt) => {\n  bg1.x -= 20 * dt;\n  bg2.x -= 40 * dt;  // Faster for depth effect\n});\n```\n\n## Next Steps\n\n- [Sprite Animation](/visual/animation) - Animate sprite sheets\n- [Shapes](/visual/shapes) - Create colored shapes\n- [Asset Loader](/utilities/assetloader) - Preload images efficiently"
      },
      {
        "slug": "visual/text",
        "title": "Text",
        "description": "Render text with custom fonts, colors, and alignment",
        "path": "visual/text.md",
        "githubRawUrl": "https://raw.githubusercontent.com/Mode7Labs/zap/main/docs/docs/markdown/visual/text.md",
        "content": "# Text\n\nThe Text entity renders text with customizable fonts, sizes, colors, and alignment. It supports system fonts, web fonts, and Google Fonts.\n\n## Basic Text\n\nCreate text by specifying the `text` property and position:\n\n```javascript\nimport { Text } from '@mode-7/zap';\n\nconst hello = new Text({\n  text: 'Hello Zap!',\n  x: 200,\n  y: 150,\n  fontSize: 24,\n  color: '#ffffff'\n});\n```\n\n## Simple Text Demo\n\n```codemirror\nimport { Game, Scene, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst title = new Text({\n  text: 'Hello Zap!',\n  x: 200,\n  y: 120,\n  fontSize: 32,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nconst subtitle = new Text({\n  text: 'Lightweight 2D game engine',\n  x: 200,\n  y: 160,\n  fontSize: 16,\n  color: '#888',\n  align: 'center'\n});\n\nscene.add(title);\nscene.add(subtitle);\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Text Properties\n\n### Font Size\n\nControl text size with `fontSize` (in pixels):\n\n```javascript\nconst small = new Text({\n  text: 'Small',\n  fontSize: 12\n});\n\nconst large = new Text({\n  text: 'Large',\n  fontSize: 48\n});\n```\n\n### Color\n\nSet text color with hex codes:\n\n```javascript\nconst text = new Text({\n  text: 'Colored Text',\n  color: '#e94560'  // Red\n});\n\n// Change color after creation\ntext.color = '#2ecc71';  // Green\n```\n\n### Font Family\n\nUse system fonts or web fonts:\n\n```javascript\nconst text = new Text({\n  text: 'Custom Font',\n  fontFamily: 'Georgia, serif'\n});\n\n// Or after creation\ntext.fontFamily = 'Courier New, monospace';\n```\n\n## Text Alignment\n\nControl horizontal alignment with the `align` property:\n\n```codemirror\nimport { Game, Scene, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst leftText = new Text({\n  text: 'Left aligned',\n  x: 50,\n  y: 100,\n  fontSize: 16,\n  color: '#fff',\n  align: 'left'\n});\n\nconst centerText = new Text({\n  text: 'Center aligned',\n  x: 200,\n  y: 150,\n  fontSize: 16,\n  color: '#fff',\n  align: 'center'\n});\n\nconst rightText = new Text({\n  text: 'Right aligned',\n  x: 350,\n  y: 200,\n  fontSize: 16,\n  color: '#fff',\n  align: 'right'\n});\n\nscene.add(leftText);\nscene.add(centerText);\nscene.add(rightText);\n\ngame.setScene(scene);\ngame.start();\n```\n\nAvailable alignments:\n- `'left'` - Align to left of x position\n- `'center'` - Center on x position (default)\n- `'right'` - Align to right of x position\n\n## Baseline Alignment\n\nControl vertical alignment with `baseline`:\n\n```javascript\nconst text = new Text({\n  text: 'Baseline',\n  baseline: 'middle'  // 'top', 'middle', 'bottom', 'alphabetic'\n});\n```\n\n- `'top'` - Top of text at y position\n- `'middle'` - Center of text at y position (default)\n- `'bottom'` - Bottom of text at y position\n- `'alphabetic'` - Alphabetic baseline at y position\n\n## Loading Custom Fonts\n\nFor detailed information on loading Google Fonts and custom web fonts, see the **[Fonts](/utilities/fonts)** documentation.\n\nQuick example:\n\n```javascript\nimport { loadGoogleFont, Text } from '@mode-7/zap';\n\n// Load a Google Font before using it\nawait loadGoogleFont('Poppins', [400, 600]);\n\nconst text = new Text({\n  text: 'Styled with Poppins',\n  x: 200,\n  y: 150,\n  fontSize: 28,\n  fontFamily: 'Poppins, sans-serif',\n  color: '#f39c12'\n});\n```\n\n## Interactive Text\n\nText can respond to gestures just like sprites:\n\n```codemirror\nimport { Game, Scene, Text } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst button = new Text({\n  text: 'CLICK ME',\n  x: 200,\n  y: 150,\n  fontSize: 24,\n  color: '#4fc3f7',\n  align: 'center',\n  interactive: true  // Enable gestures\n});\n\nscene.add(button);\n\nbutton.on('tap', () => {\n  button.color = button.color === '#4fc3f7' ? '#e94560' : '#4fc3f7';\n  button.tween(\n    { scaleX: 1.2, scaleY: 1.2 },\n    { duration: 100 }\n  ).then(() => {\n    button.tween(\n      { scaleX: 1, scaleY: 1 },\n      { duration: 100 }\n    );\n  });\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Dynamic Text\n\nUpdate text content dynamically:\n\n```javascript\nconst score = new Text({\n  text: 'Score: 0',\n  x: 200,\n  y: 50\n});\n\nlet points = 0;\n\nfunction addPoints(amount) {\n  points += amount;\n  score.text = `Score: ${points}`;\n}\n```\n\n## Transforms\n\nText supports all entity transforms:\n\n```javascript\ntext.rotation = Math.PI / 4;  // Rotate 45 degrees\ntext.scaleX = 2;              // Scale width 2x\ntext.scaleY = 2;              // Scale height 2x\ntext.alpha = 0.5;             // 50% opacity\n```\n\n## Animated Text\n\nCombine text with tweening for effects:\n\n```codemirror\nimport { Game, Scene, Text, delay } from '@VERSION';\n\nconst game = new Game({\n  width: 400,\n  height: 300,\n  backgroundColor: '#0f3460'\n});\n\nconst scene = new Scene();\n\nconst text = new Text({\n  text: 'GAME OVER',\n  x: 200,\n  y: 150,\n  fontSize: 48,\n  color: '#e94560',\n  align: 'center',\n  alpha: 0,\n  scaleX: 0.5,\n  scaleY: 0.5\n});\n\nscene.add(text);\n\n// Fade in and scale up\ntext.tween(\n  { alpha: 1, scaleX: 1, scaleY: 1 },\n  { duration: 800, easing: 'easeOutBack' }\n);\n\n// Pulse animation\ndelay(1000, () => {\n  text.tween(\n    { scaleX: 1.1, scaleY: 1.1 },\n    { duration: 500, loop: true, easing: 'easeInOutQuad' }\n  );\n});\n\ngame.setScene(scene);\ngame.start();\n```\n\n## Performance Tips\n\n- **Limit text changes**: Updating text frequently can impact performance\n- **Reuse text entities**: Change `text` property instead of creating new ones\n- **Avoid many fonts**: Stick to 2-3 font families per game\n- **Preload fonts**: Load custom fonts before creating text (see [Fonts](/utilities/fonts))\n- **Use appropriate sizes**: Smaller text renders faster\n\n## Common Patterns\n\n### Score Display\n\n```javascript\nconst scoreText = new Text({\n  text: 'Score: 0',\n  x: 20,\n  y: 20,\n  fontSize: 18,\n  color: '#fff',\n  align: 'left'\n});\n\nlet score = 0;\n\nfunction updateScore(points) {\n  score += points;\n  scoreText.text = `Score: ${score}`;\n}\n```\n\n### Countdown Timer\n\n```javascript\nconst timerText = new Text({\n  text: '3:00',\n  x: 200,\n  y: 30,\n  fontSize: 20,\n  color: '#4fc3f7',\n  align: 'center'\n});\n\nlet timeLeft = 180; // seconds\n\nscene.interval(1000, () => {\n  timeLeft--;\n  const minutes = Math.floor(timeLeft / 60);\n  const seconds = timeLeft % 60;\n  timerText.text = `${minutes}:${seconds.toString().padStart(2, '0')}`;\n\n  if (timeLeft <= 10) {\n    timerText.color = '#e94560';  // Red warning\n  }\n});\n```\n\n### Dialogue Box\n\n```javascript\nconst dialogue = new Text({\n  text: '',\n  x: 200,\n  y: 250,\n  fontSize: 14,\n  color: '#fff',\n  align: 'center'\n});\n\nfunction showDialogue(message) {\n  dialogue.text = message;\n  dialogue.alpha = 0;\n  dialogue.tween(\n    { alpha: 1 },\n    { duration: 300 }\n  );\n}\n\nfunction hideDialogue() {\n  dialogue.tween(\n    { alpha: 0 },\n    { duration: 300 }\n  );\n}\n```\n\n### Multiline Text\n\n```javascript\nconst instructions = new Text({\n  text: 'Line 1\\nLine 2\\nLine 3',  // Use \\n for line breaks\n  x: 200,\n  y: 150,\n  fontSize: 14,\n  color: '#fff',\n  align: 'center'\n});\n```\n\n## Next Steps\n\n- [Shapes](/visual/shapes) - Create colored shapes\n- [Sprites](/visual/sprites) - Display images\n- [Animations](/animation/animations) - Tween text properties\n- [Layout](/utilities/layout) - Position text with layout helpers"
      }
    ]
  }
}