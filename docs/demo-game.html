<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Color Match - Made with Zap</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #1e3a8a 0%, #7c3aed 100%);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
    }

    #game-container {
      position: relative;
      box-shadow: 0 20px 60px rgba(0,0,0,0.4);
      border-radius: 16px;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <div id="game-container"></div>

  <script type="module">
    import { Game, Scene, Sprite, Text, Layout } from 'https://esm.sh/@mode-7/zap@0.1.2';

    // Game configuration
    const GRID_SIZE = 8;
    const CELL_SIZE = 60;
    const CELL_SPACING = 10;
    const CIRCLE_RADIUS = 28;
    const COLORS = ['#ef4444', '#f59e0b', '#10b981', '#3b82f6', '#8b5cf6'];
    const GRID_START_X = 100;
    const GRID_START_Y = 150;

    // Game state
    let score = 0;
    let combo = 0;
    let grid = [];
    let currentTrail = [];
    let isProcessing = false;

    // Create game
    const game = new Game({
      width: 800,
      height: 800,
      backgroundColor: '#1f2937',
      parent: '#game-container',
      showFPS: true
    });

    const scene = new Scene();

    // Create score text
    const scoreText = new Text({
      text: 'SCORE: 0',
      x: 400,
      y: 40,
      fontSize: 24,
      fontFamily: 'Arial, sans-serif',
      color: '#ffffff',
      align: 'center',
      baseline: 'middle'
    });
    scene.add(scoreText);

    // Create tagline text
    const tagline = new Text({
      text: 'Built with sprites and tweens using Zap',
      x: 400,
      y: 70,
      fontSize: 14,
      fontFamily: 'Arial, sans-serif',
      color: '#9ca3af',
      align: 'center',
      baseline: 'middle'
    });
    scene.add(tagline);

    // Create combo text (hidden initially)
    const comboText = new Text({
      text: '',
      x: 400,
      y: 100,
      fontSize: 20,
      fontFamily: 'Arial, sans-serif',
      color: '#fbbf24',
      align: 'center',
      baseline: 'middle',
      alpha: 0
    });
    scene.add(comboText);

    // Create grid
    function createCircle(row, col, color = null) {
      const circle = new Sprite({
        width: CIRCLE_RADIUS * 2,
        height: CIRCLE_RADIUS * 2,
        color: color || Layout.randomItem(COLORS),
        radius: CIRCLE_RADIUS,
        interactive: true,
        x: GRID_START_X + col * (CELL_SIZE + CELL_SPACING) + CIRCLE_RADIUS,
        y: GRID_START_Y + row * (CELL_SIZE + CELL_SPACING) + CIRCLE_RADIUS
      });

      circle.gridRow = row;
      circle.gridCol = col;
      circle.isHighlighted = false;
      circle.originalColor = circle.color;

      // Drag start - begin trail
      circle.on('dragstart', () => {
        if (isProcessing) return;

        currentTrail = [circle];
        highlightCircle(circle);
      });

      // Drag - extend trail
      circle.on('drag', (e) => {
        if (isProcessing) return;

        // Check if dragging over a new circle
        const circles = grid.flat().filter(c => c && c !== circle);
        for (const other of circles) {
          if (other.containsPoint(e.position.x, e.position.y)) {
            addToTrail(other);
            break;
          }
        }
      });

      // Drag end - check for matches
      circle.on('dragend', () => {
        if (isProcessing) return;

        if (currentTrail.length >= 3) {
          matchTrail();
        } else {
          clearTrail();
        }
      });

      return circle;
    }

    function highlightCircle(circle) {
      circle.isHighlighted = true;
      circle.tween(
        { scaleX: 1.2, scaleY: 1.2 },
        { duration: 150, easing: 'easeOutQuad' }
      );
    }

    function unhighlightCircle(circle) {
      circle.isHighlighted = false;
      circle.tween(
        { scaleX: 1, scaleY: 1 },
        { duration: 150, easing: 'easeOutQuad' }
      );
    }

    function addToTrail(circle) {
      // Can't add if already in trail
      if (currentTrail.includes(circle)) return;

      // Must be adjacent to last circle in trail
      const last = currentTrail[currentTrail.length - 1];
      const rowDiff = Math.abs(circle.gridRow - last.gridRow);
      const colDiff = Math.abs(circle.gridCol - last.gridCol);

      // Must be adjacent (not diagonal)
      if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
        // Must be same color
        if (circle.originalColor === last.originalColor) {
          currentTrail.push(circle);
          highlightCircle(circle);
        }
      }
    }

    function clearTrail() {
      currentTrail.forEach(circle => unhighlightCircle(circle));
      currentTrail = [];
    }

    async function matchTrail() {
      if (currentTrail.length < 3) {
        clearTrail();
        return;
      }

      isProcessing = true;

      // Calculate score
      const points = currentTrail.length * 10 * (combo + 1);
      score += points;
      scoreText.text = `SCORE: ${score}`;

      // Update combo
      combo++;
      if (combo > 1) {
        comboText.text = `COMBO x${combo}!`;
        comboText.alpha = 1;
        comboText.tween(
          { scaleX: 1.5, scaleY: 1.5 },
          { duration: 200, easing: 'easeOutBack' }
        );
        setTimeout(() => {
          comboText.tween(
            { scaleX: 1, scaleY: 1, alpha: 0 },
            { duration: 300, easing: 'easeInQuad' }
          );
        }, 1000);
      }

      // Animate and remove matched circles
      const matched = [...currentTrail];
      currentTrail = [];

      for (const circle of matched) {
        circle.tween(
          { scaleX: 0, scaleY: 0, rotation: Math.PI * 2, alpha: 0 },
          { duration: 300, easing: 'easeInBack' }
        );

        // Remove from grid
        grid[circle.gridRow][circle.gridCol] = null;
      }

      // Wait for animation
      await wait(400);

      // Remove from scene
      matched.forEach(circle => scene.remove(circle));

      // Apply gravity and refill
      await applyGravity();
      await refillGrid();

      isProcessing = false;
    }

    async function applyGravity() {
      let moved = true;

      while (moved) {
        moved = false;

        // Check each column from bottom to top
        for (let col = 0; col < GRID_SIZE; col++) {
          for (let row = GRID_SIZE - 1; row >= 0; row--) {
            if (grid[row][col] === null) {
              // Find circle above
              for (let r = row - 1; r >= 0; r--) {
                if (grid[r][col] !== null) {
                  // Move circle down
                  const circle = grid[r][col];
                  grid[row][col] = circle;
                  grid[r][col] = null;

                  circle.gridRow = row;

                  const newY = GRID_START_Y + row * (CELL_SIZE + CELL_SPACING) + CIRCLE_RADIUS;
                  circle.tween(
                    { y: newY },
                    { duration: 200, easing: 'easeOutBounce' }
                  );

                  moved = true;
                  break;
                }
              }
            }
          }
        }

        if (moved) {
          await wait(250);
        }
      }
    }

    async function refillGrid() {
      const newCircles = [];

      for (let col = 0; col < GRID_SIZE; col++) {
        for (let row = 0; row < GRID_SIZE; row++) {
          if (grid[row][col] === null) {
            const circle = createCircle(row, col);

            // Start from above the grid
            circle.y = GRID_START_Y - 100;
            circle.alpha = 0;

            grid[row][col] = circle;
            scene.add(circle);
            newCircles.push(circle);

            // Animate falling in
            const targetY = GRID_START_Y + row * (CELL_SIZE + CELL_SPACING) + CIRCLE_RADIUS;

            setTimeout(() => {
              circle.tween(
                { y: targetY, alpha: 1 },
                { duration: 400, easing: 'easeOutBounce' }
              );
            }, col * 50);
          }
        }
      }

      await wait(500);
    }

    function wait(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Initialize grid
    function initGrid() {
      for (let row = 0; row < GRID_SIZE; row++) {
        grid[row] = [];
        for (let col = 0; col < GRID_SIZE; col++) {
          const circle = createCircle(row, col);
          grid[row][col] = circle;
          scene.add(circle);

          // Stagger entrance animation
          circle.scaleX = 0;
          circle.scaleY = 0;

          setTimeout(() => {
            circle.tween(
              { scaleX: 1, scaleY: 1 },
              { duration: 300, easing: 'easeOutBack' }
            );
          }, (row * GRID_SIZE + col) * 20);
        }
      }
    }

    // Add instructions
    const instructions = new Text({
      text: 'Swipe 3+ matching colors!',
      x: 400,
      y: 720,
      fontSize: 18,
      fontFamily: 'Arial, sans-serif',
      color: '#9ca3af',
      align: 'center',
      baseline: 'middle'
    });
    scene.add(instructions);

    // Start game
    initGrid();
    game.setScene(scene);
    game.start();

    // Reset combo after inactivity
    let comboTimer;
    game.canvas.addEventListener('pointerup', () => {
      clearTimeout(comboTimer);
      comboTimer = setTimeout(() => {
        combo = 0;
      }, 2000);
    });
  </script>
</body>
</html>
