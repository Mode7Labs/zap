<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>@mode7/zap Documentation & Examples</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0f0f23;
      color: #fff;
      overflow: hidden;
    }

    .container {
      display: flex;
      height: 100vh;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      background: #1a1a2e;
      border-right: 1px solid #2a2a3e;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }

    .sidebar-header {
      padding: 24px;
      border-bottom: 1px solid #2a2a3e;
    }

    .sidebar-header h1 {
      font-size: 20px;
      color: #4fc3f7;
      margin-bottom: 8px;
    }

    .sidebar-header p {
      font-size: 13px;
      color: #888;
    }

    .nav-items {
      padding: 12px 0;
    }

    .nav-section-title {
      padding: 20px 24px 8px 24px;
      font-size: 11px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .nav-section-title:not(:first-child) {
      margin-top: 8px;
      border-top: 1px solid #2a2a3e;
      padding-top: 20px;
    }

    .nav-item {
      padding: 12px 24px;
      cursor: pointer;
      transition: all 0.2s;
      border-left: 3px solid transparent;
      font-size: 14px;
      color: #ccc;
    }

    .nav-item:hover {
      background: #0f3460;
      color: #fff;
    }

    .nav-item.active {
      background: #0f3460;
      border-left-color: #4fc3f7;
      color: #fff;
    }

    .nav-item-icon {
      margin-right: 10px;
    }

    /* Main Content */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .content-header {
      padding: 24px 32px;
      border-bottom: 1px solid #2a2a3e;
      background: #16213e;
    }

    .content-header h2 {
      font-size: 24px;
      margin-bottom: 8px;
    }

    .content-header p {
      color: #888;
      font-size: 14px;
    }

    .content-body {
      flex: 1;
      overflow-y: auto;
      padding: 32px;
    }

    .demo-section {
      display: none;
      animation: fadeIn 0.3s;
    }

    .demo-section.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .demo-container {
      background: #1a1a2e;
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 24px;
    }

    .demo-canvas-wrapper {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 400px;
      background: #0f0f23;
      border-radius: 8px;
      margin-bottom: 20px;
    }

    canvas {
      border-radius: 8px;
    }

    .code-section {
      background: #1a1a2e;
      border-radius: 12px;
      padding: 24px;
    }

    .code-section h3 {
      color: #4fc3f7;
      margin-bottom: 16px;
      font-size: 16px;
    }

    pre {
      background: #0f0f23;
      padding: 20px;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 13px;
      line-height: 1.6;
    }

    .keyword { color: #c792ea; }
    .string { color: #c3e88d; }
    .function { color: #82aaff; }
    .comment { color: #546e7a; }
    .number { color: #f78c6c; }

    /* Loading state */
    .loading {
      text-align: center;
      padding: 60px;
      color: #888;
    }

    /* Documentation content */
    .doc-content {
      max-width: 800px;
    }

    .doc-content h3 {
      color: #4fc3f7;
      font-size: 20px;
      margin-top: 32px;
      margin-bottom: 16px;
    }

    .doc-content h3:first-child {
      margin-top: 0;
    }

    .doc-content p {
      color: #ccc;
      line-height: 1.8;
      margin-bottom: 16px;
    }

    .doc-content ul, .doc-content ol {
      color: #ccc;
      line-height: 1.8;
      margin-bottom: 16px;
      padding-left: 24px;
    }

    .doc-content li {
      margin-bottom: 8px;
    }

    .doc-content code {
      background: #1a1a2e;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 13px;
      color: #4fc3f7;
    }

    .doc-content pre code {
      background: transparent;
      padding: 0;
    }

    .doc-content .info-box {
      background: #16213e;
      border-left: 3px solid #4fc3f7;
      padding: 16px 20px;
      margin: 24px 0;
      border-radius: 4px;
    }

    .doc-content .info-box p:last-child {
      margin-bottom: 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Sidebar Navigation -->
    <div class="sidebar">
      <div class="sidebar-header">
        <h1>@mode7/zap</h1>
        <p>Documentation & Examples</p>
      </div>
      <div class="nav-items">
        <div class="nav-section-title">Getting Started</div>
        <div class="nav-item active" data-demo="installation">
          <span class="nav-item-icon">üì•</span> Installation
        </div>
        <div class="nav-item" data-demo="quickstart">
          <span class="nav-item-icon">‚ö°</span> Quick Start
        </div>

        <div class="nav-section-title">Core Concepts</div>
        <div class="nav-item" data-demo="architecture">
          <span class="nav-item-icon">üèóÔ∏è</span> Architecture
        </div>
        <div class="nav-item" data-demo="game">
          <span class="nav-item-icon">‚öôÔ∏è</span> Game Configuration
        </div>
        <div class="nav-item" data-demo="scenes">
          <span class="nav-item-icon">üé¨</span> Scenes
        </div>
        <div class="nav-item" data-demo="entities">
          <span class="nav-item-icon">üéØ</span> Entities
        </div>

        <div class="nav-section-title">Visual Elements</div>
        <div class="nav-item" data-demo="sprites">
          <span class="nav-item-icon">üé®</span> Sprites & Shapes
        </div>
        <div class="nav-item" data-demo="images">
          <span class="nav-item-icon">üñºÔ∏è</span> Image Sprites
        </div>
        <div class="nav-item" data-demo="animatedsprite">
          <span class="nav-item-icon">üé¨</span> Animated Sprites
        </div>
        <div class="nav-item" data-demo="ninepatch">
          <span class="nav-item-icon">üìê</span> Nine-Patch
        </div>
        <div class="nav-item" data-demo="text">
          <span class="nav-item-icon">‚úèÔ∏è</span> Text Rendering
        </div>
        <div class="nav-item" data-demo="fonts">
          <span class="nav-item-icon">üî§</span> Google Fonts
        </div>

        <div class="nav-section-title">UI Components</div>
        <div class="nav-item" data-demo="button">
          <span class="nav-item-icon">üîò</span> Button
        </div>

        <div class="nav-section-title">Camera</div>
        <div class="nav-item" data-demo="camera">
          <span class="nav-item-icon">üìπ</span> Camera Control
        </div>

        <div class="nav-section-title">Audio</div>
        <div class="nav-item" data-demo="audio">
          <span class="nav-item-icon">üîä</span> Sound & Music
        </div>

        <div class="nav-section-title">Interactions</div>
        <div class="nav-item" data-demo="tap">
          <span class="nav-item-icon">üëÜ</span> Tap Gesture
        </div>
        <div class="nav-item" data-demo="swipe">
          <span class="nav-item-icon">üëà</span> Swipe Gesture
        </div>
        <div class="nav-item" data-demo="drag">
          <span class="nav-item-icon">‚úã</span> Drag Gesture
        </div>
        <div class="nav-item" data-demo="touchtrail">
          <span class="nav-item-icon">‚ú®</span> Touch Trail
        </div>

        <div class="nav-section-title">Animation & Effects</div>
        <div class="nav-item" data-demo="animations">
          <span class="nav-item-icon">‚ú®</span> Animations
        </div>
        <div class="nav-item" data-demo="easing">
          <span class="nav-item-icon">üìà</span> Easing Functions
        </div>
        <div class="nav-item" data-demo="particles">
          <span class="nav-item-icon">üéÜ</span> Particles
        </div>

        <div class="nav-section-title">Utilities</div>
        <div class="nav-item" data-demo="collision">
          <span class="nav-item-icon">üí•</span> Collision Detection
        </div>
        <div class="nav-item" data-demo="layout">
          <span class="nav-item-icon">üìê</span> Layout Helpers
        </div>
        <div class="nav-item" data-demo="assetloader">
          <span class="nav-item-icon">üì¶</span> Asset Loader
        </div>
        <div class="nav-item" data-demo="storage">
          <span class="nav-item-icon">üíæ</span> Storage
        </div>
        <div class="nav-item" data-demo="timer">
          <span class="nav-item-icon">‚è±Ô∏è</span> Timers
        </div>
      </div>
    </div>

    <!-- Main Content Area -->
    <div class="main-content">
      <div class="content-header">
        <h2 id="demo-title">Installation</h2>
        <p id="demo-description">Get started with @mode7/zap</p>
      </div>
      <div class="content-body">
        <div id="demo-content">
          <!-- Demo content will be loaded here -->
          <div class="loading">Select a topic from the sidebar</div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import {
      Game,
      Scene,
      Sprite,
      Text,
      AnimatedSprite,
      NinePatch,
      Button,
      ParticleEmitter,
      TouchTrail,
      loadGoogleFont,
      Layout,
      Easing,
      AssetLoader,
      Storage,
      audioManager,
      delay,
      interval,
      wait
    } from '../dist/index.mjs';

    let currentGame = null;

    const demos = {
      installation: {
        title: 'Installation',
        description: 'Get started with @mode7/zap',
        isDoc: true,
        content: `
          <div class="doc-content">
            <h3>Install via npm</h3>
            <p>Install Zap using npm or your preferred package manager:</p>
            <div class="code-section">
              <pre><span class="comment"># Using npm</span>
npm install @mode7/zap

<span class="comment"># Using yarn</span>
yarn add @mode7/zap

<span class="comment"># Using pnpm</span>
pnpm add @mode7/zap</pre>
            </div>

            <h3>CDN Usage</h3>
            <p>You can also use Zap directly from a CDN without installation:</p>
            <div class="code-section">
              <pre><span class="keyword">&lt;script</span> <span class="string">type</span>=<span class="string">"module"</span><span class="keyword">&gt;</span>
  <span class="keyword">import</span> { Game, Scene, Sprite } <span class="keyword">from</span> <span class="string">'https://esm.sh/@mode7/zap'</span>;

  <span class="comment">// Your code here...</span>
<span class="keyword">&lt;/script&gt;</span></pre>
            </div>

            <h3>Requirements</h3>
            <ul>
              <li>Modern browser with ES6+ support</li>
              <li>HTML5 Canvas support</li>
              <li>No external dependencies required</li>
            </ul>

            <div class="info-box">
              <p><strong>üí° Note:</strong> Zap is designed to be lightweight and framework-agnostic. It works great with vanilla JavaScript, React, Vue, or any other framework.</p>
            </div>
          </div>
        `
      },

      quickstart: {
        title: 'Quick Start',
        description: 'Create your first game in minutes',
        isDoc: true,
        content: `
          <div class="doc-content">
            <h3>Your First Game</h3>
            <p>Let's create a simple interactive game with just a few lines of code:</p>

            <div class="code-section">
              <pre><span class="keyword">import</span> { Game, Scene, Sprite } <span class="keyword">from</span> <span class="string">'@mode7/zap'</span>;

<span class="comment">// 1. Create a game instance</span>
<span class="keyword">const</span> game = <span class="keyword">new</span> <span class="function">Game</span>({
  width: <span class="number">400</span>,
  height: <span class="number">300</span>,
  backgroundColor: <span class="string">'#0f3460'</span>
});

<span class="comment">// 2. Create a scene</span>
<span class="keyword">const</span> scene = <span class="keyword">new</span> <span class="function">Scene</span>();

<span class="comment">// 3. Add a sprite</span>
<span class="keyword">const</span> player = <span class="keyword">new</span> <span class="function">Sprite</span>({
  x: <span class="number">200</span>,
  y: <span class="number">150</span>,
  width: <span class="number">50</span>,
  height: <span class="number">50</span>,
  color: <span class="string">'#e94560'</span>,
  interactive: <span class="keyword">true</span>
});

<span class="comment">// 4. Add interaction</span>
player.<span class="function">on</span>(<span class="string">'tap'</span>, () => {
  player.<span class="function">tween</span>(
    { rotation: player.rotation + Math.PI },
    { duration: <span class="number">300</span> }
  );
});

<span class="comment">// 5. Start the game</span>
scene.<span class="function">add</span>(player);
game.<span class="function">setScene</span>(scene);
game.<span class="function">start</span>();</pre>
            </div>

            <h3>What's Happening?</h3>
            <ol>
              <li><strong>Game Instance:</strong> Creates a 400x300 canvas with a dark blue background</li>
              <li><strong>Scene:</strong> A container for all your game objects</li>
              <li><strong>Sprite:</strong> A visual game object with position, size, and color</li>
              <li><strong>Interaction:</strong> Makes the sprite respond to tap/click events</li>
              <li><strong>Start:</strong> Begins the game loop and renders everything</li>
            </ol>

            <div class="info-box">
              <p><strong>üéØ Pro Tip:</strong> All Zap entities support gestures (tap, swipe, drag), animations, and parent-child hierarchies out of the box!</p>
            </div>

            <h3>Next Steps</h3>
            <p>Now that you've created your first game, explore:</p>
            <ul>
              <li><strong>Game Configuration</strong> - Learn about all available options including FPS control, debug mode, and rendering quality</li>
              <li><strong>Scenes</strong> - Manage multiple game states like menus, levels, and game over screens</li>
              <li><strong>Gestures</strong> - Add tap, swipe, drag, and pinch interactions</li>
              <li><strong>Animations</strong> - Tween properties with easing functions</li>
            </ul>
          </div>
        `
      },

      architecture: {
        title: 'Architecture',
        description: 'Understanding how Zap is structured',
        isDoc: true,
        content: `
          <div class="doc-content">
            <h3>Core Components</h3>
            <p>Zap is built around a simple, intuitive architecture:</p>

            <div class="code-section">
              <pre>Game
 ‚îú‚îÄ‚îÄ Scene(s)
 ‚îÇ    ‚îú‚îÄ‚îÄ Entity (Sprite, Text, etc.)
 ‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ Child Entities
 ‚îÇ    ‚îî‚îÄ‚îÄ ParticleEmitter
 ‚îú‚îÄ‚îÄ Camera
 ‚îî‚îÄ‚îÄ Managers
      ‚îú‚îÄ‚îÄ GestureManager
      ‚îú‚îÄ‚îÄ TweenManager
      ‚îî‚îÄ‚îÄ AudioManager</pre>
            </div>

            <h3>Game</h3>
            <p>The <code>Game</code> class is your main entry point. It manages:</p>
            <ul>
              <li>Canvas rendering context</li>
              <li>Game loop (update/render cycle)</li>
              <li>Scene management</li>
              <li>Global managers (gestures, tweens, audio)</li>
            </ul>
            <p>See <strong>Game Configuration</strong> for all available options including FPS control, rendering quality, and debug tools.</p>

            <h3>Entities</h3>
            <p>Everything visual in your game is an <strong>Entity</strong>:</p>
            <ul>
              <li><code>Sprite</code> - Basic shapes, colors, and images</li>
              <li><code>Text</code> - Text rendering with custom fonts</li>
              <li><code>ParticleEmitter</code> - Particle effects</li>
            </ul>

            <h3>Managers</h3>
            <p>Managers are internal singleton systems that work behind the scenes. You don't interact with them directly - instead, you use convenient methods on entities:</p>
            <ul>
              <li><strong>GestureManager:</strong> Detects touch/mouse input when you use <code>entity.on('tap', ...)</code></li>
              <li><strong>TweenManager:</strong> Updates animations when you call <code>entity.tween(...)</code></li>
              <li><strong>AudioManager:</strong> Plays sounds when you call <code>AudioManager.play(...)</code></li>
            </ul>

            <p>The managers handle the complex logic, while entities provide a simple API.</p>

            <div class="info-box">
              <p><strong>‚ö° Performance:</strong> Zap uses a single requestAnimationFrame loop and batches all rendering operations for optimal performance, even with hundreds of entities.</p>
            </div>
          </div>
        `
      },

      game: {
        title: 'Game Configuration',
        description: 'Configure your game with flexible options',
        isDoc: true,
        content: `
          <div class="doc-content">
            <h3>Creating a Game</h3>
            <p>The <code>Game</code> class is highly configurable. All options are optional with sensible defaults:</p>

            <div class="code-section">
              <pre><span class="keyword">import</span> { Game } <span class="keyword">from</span> <span class="string">'@mode7/zap'</span>;

<span class="comment">// Minimal setup with defaults</span>
<span class="keyword">const</span> game = <span class="keyword">new</span> <span class="function">Game</span>();

<span class="comment">// Custom configuration</span>
<span class="keyword">const</span> game = <span class="keyword">new</span> <span class="function">Game</span>({
  <span class="comment">// Display</span>
  width: <span class="number">800</span>,                <span class="comment">// Default: 800</span>
  height: <span class="number">600</span>,               <span class="comment">// Default: 600</span>
  backgroundColor: <span class="string">'#0f3460'</span>,  <span class="comment">// Default: '#000000'</span>

  <span class="comment">// Rendering Quality</span>
  pixelRatio: <span class="number">2</span>,             <span class="comment">// Default: window.devicePixelRatio</span>
  antialias: <span class="keyword">true</span>,            <span class="comment">// Default: true</span>
  imageSmoothingQuality: <span class="string">'high'</span>, <span class="comment">// 'low' | 'medium' | 'high'</span>

  <span class="comment">// Performance</span>
  targetFPS: <span class="number">60</span>,             <span class="comment">// Default: null (unlimited)</span>
  maxDeltaTime: <span class="number">0.1</span>,         <span class="comment">// Default: 0.1 (prevent spiral of death)</span>

  <span class="comment">// Features</span>
  enableTouchTrail: <span class="keyword">false</span>,   <span class="comment">// Default: false</span>

  <span class="comment">// Debug</span>
  showFPS: <span class="keyword">true</span>,             <span class="comment">// Default: false</span>
  debug: <span class="keyword">false</span>                <span class="comment">// Default: false</span>
});</pre>
            </div>

            <h3>Display Options</h3>
            <ul>
              <li><code>width</code> - Canvas width in pixels (default: 800)</li>
              <li><code>height</code> - Canvas height in pixels (default: 600)</li>
              <li><code>canvas</code> - Existing canvas element to use (default: creates new)</li>
              <li><code>parent</code> - Parent element or selector (default: document.body)</li>
              <li><code>backgroundColor</code> - Background color (default: '#000000')</li>
            </ul>

            <h3>Rendering Quality</h3>
            <ul>
              <li><code>pixelRatio</code> - Device pixel ratio for sharp rendering (default: window.devicePixelRatio)</li>
              <li><code>antialias</code> - Enable image smoothing (default: true)</li>
              <li><code>imageSmoothingQuality</code> - Quality of image scaling: 'low', 'medium', or 'high' (default: 'high')</li>
              <li><code>alpha</code> - Enable canvas transparency (default: false)</li>
              <li><code>desynchronized</code> - Performance hint for canvas (default: true)</li>
            </ul>

            <h3>Performance Options</h3>
            <p>Control frame rate and performance characteristics:</p>

            <div class="code-section">
              <pre><span class="comment">// Limit to 30 FPS (battery saving)</span>
<span class="keyword">const</span> game = <span class="keyword">new</span> <span class="function">Game</span>({
  targetFPS: <span class="number">30</span>
});

<span class="comment">// Prevent "spiral of death" in slow devices</span>
<span class="keyword">const</span> game = <span class="keyword">new</span> <span class="function">Game</span>({
  maxDeltaTime: <span class="number">0.05</span>  <span class="comment">// Clamp to 50ms max</span>
});</pre>
            </div>

            <ul>
              <li><code>targetFPS</code> - Target frame rate (default: null for unlimited). Set to 30 or 60 to limit FPS and save battery</li>
              <li><code>maxDeltaTime</code> - Maximum time step in seconds (default: 0.1). Prevents physics breaking when tab is inactive</li>
            </ul>

            <h3>Debug Options</h3>
            <p>Built-in debugging tools to help during development:</p>

            <div class="code-section">
              <pre><span class="keyword">const</span> game = <span class="keyword">new</span> <span class="function">Game</span>({
  showFPS: <span class="keyword">true</span>,   <span class="comment">// Show FPS counter</span>
  debug: <span class="keyword">true</span>      <span class="comment">// Enable debug mode</span>
});</pre>
            </div>

            <ul>
              <li><code>showFPS</code> - Display FPS counter in top-left corner (default: false)</li>
              <li><code>debug</code> - Enable debug mode for additional logging and tools (default: false)</li>
            </ul>

            <div class="info-box">
              <p><strong>üí° Pro Tip:</strong> Start with defaults and only configure what you need. The default 800x600 resolution works great for most games and playable ads!</p>
            </div>

            <h3>Canvas Context Options</h3>
            <p>Advanced options for the 2D rendering context:</p>
            <ul>
              <li><code>alpha</code> - Enable transparency (default: false). Set to true if you need a transparent background</li>
              <li><code>desynchronized</code> - Performance hint to reduce latency (default: true)</li>
            </ul>
          </div>
        `
      },

      scenes: {
        title: 'Scenes',
        description: 'Managing game states with scenes',
        isDoc: true,
        content: `
          <div class="doc-content">
            <h3>What is a Scene?</h3>
            <p>A <code>Scene</code> is a container for entities. Think of it like a level, menu screen, or game state:</p>

            <div class="code-section">
              <pre><span class="keyword">const</span> menuScene = <span class="keyword">new</span> <span class="function">Scene</span>();
<span class="keyword">const</span> gameScene = <span class="keyword">new</span> <span class="function">Scene</span>();
<span class="keyword">const</span> gameOverScene = <span class="keyword">new</span> <span class="function">Scene</span>();

<span class="comment">// Switch between scenes</span>
game.<span class="function">setScene</span>(menuScene);</pre>
            </div>

            <h3>Adding Entities</h3>
            <p>Add entities to your scene using the <code>add()</code> method:</p>

            <div class="code-section">
              <pre><span class="keyword">const</span> scene = <span class="keyword">new</span> <span class="function">Scene</span>();

<span class="keyword">const</span> background = <span class="keyword">new</span> <span class="function">Sprite</span>({ <span class="comment">/* ... */</span> });
<span class="keyword">const</span> player = <span class="keyword">new</span> <span class="function">Sprite</span>({ <span class="comment">/* ... */</span> });
<span class="keyword">const</span> score = <span class="keyword">new</span> <span class="function">Text</span>({ <span class="comment">/* ... */</span> });

scene.<span class="function">add</span>(background);
scene.<span class="function">add</span>(player);
scene.<span class="function">add</span>(score);</pre>
            </div>

            <h3>Scene Methods</h3>
            <ul>
              <li><code>scene.add(entity)</code> - Add an entity to the scene</li>
              <li><code>scene.remove(entity)</code> - Remove an entity from the scene</li>
              <li><code>scene.clear()</code> - Remove all entities</li>
              <li><code>scene.findByTag(tag)</code> - Find entities by tag</li>
            </ul>

            <h3>Scene Switching</h3>
            <p>Switch between scenes smoothly:</p>

            <div class="code-section">
              <pre><span class="comment">// Create multiple scenes</span>
<span class="keyword">const</span> menu = <span class="keyword">new</span> <span class="function">Scene</span>();
<span class="keyword">const</span> level1 = <span class="keyword">new</span> <span class="function">Scene</span>();

<span class="comment">// Switch to level 1 when start button is tapped</span>
startButton.<span class="function">on</span>(<span class="string">'tap'</span>, () => {
  game.<span class="function">setScene</span>(level1);
});</pre>
            </div>

            <div class="info-box">
              <p><strong>üí° Tip:</strong> When you switch scenes, the previous scene is automatically cleaned up, stopping all tweens and removing event listeners.</p>
            </div>
          </div>
        `
      },

      entities: {
        title: 'Entities',
        description: 'Visual objects in your game',
        isDoc: true,
        content: `
          <div class="doc-content">
            <h3>What is an Entity?</h3>
            <p>Entities are the building blocks of your game. Every visual element (sprites, text, particles) extends the <code>Entity</code> base class.</p>

            <h3>Common Properties</h3>
            <p>All entities share these properties:</p>

            <div class="code-section">
              <pre><span class="keyword">const</span> sprite = <span class="keyword">new</span> <span class="function">Sprite</span>({
  <span class="comment">// Position</span>
  x: <span class="number">100</span>,
  y: <span class="number">100</span>,

  <span class="comment">// Size</span>
  width: <span class="number">50</span>,
  height: <span class="number">50</span>,

  <span class="comment">// Transform</span>
  rotation: <span class="number">0</span>,
  scaleX: <span class="number">1</span>,
  scaleY: <span class="number">1</span>,

  <span class="comment">// Appearance</span>
  alpha: <span class="number">1</span>,
  visible: <span class="keyword">true</span>,

  <span class="comment">// Interaction</span>
  interactive: <span class="keyword">true</span>,

  <span class="comment">// Organization</span>
  tag: <span class="string">'player'</span>
});</pre>
            </div>

            <h3>Parent-Child Hierarchy</h3>
            <p>Entities can have children, creating a transform hierarchy:</p>

            <div class="code-section">
              <pre><span class="keyword">const</span> parent = <span class="keyword">new</span> <span class="function">Sprite</span>({ x: <span class="number">200</span>, y: <span class="number">150</span> });
<span class="keyword">const</span> child = <span class="keyword">new</span> <span class="function">Sprite</span>({ x: <span class="number">20</span>, y: <span class="number">0</span> });

parent.<span class="function">addChild</span>(child);

<span class="comment">// Child's world position is (220, 150)</span>
<span class="comment">// Rotating parent also rotates child</span>
parent.rotation = Math.PI / <span class="number">4</span>;</pre>
            </div>

            <h3>Entity Methods</h3>
            <ul>
              <li><code>entity.tween(props, options)</code> - Animate properties</li>
              <li><code>entity.on(event, handler)</code> - Listen to events</li>
              <li><code>entity.addChild(child)</code> - Add a child entity</li>
              <li><code>entity.removeChild(child)</code> - Remove a child entity</li>
              <li><code>entity.destroy()</code> - Clean up and remove</li>
            </ul>

            <h3>Common Entity Types</h3>
            <ul>
              <li><strong>Sprite:</strong> Rectangles, circles, rounded shapes, images</li>
              <li><strong>Text:</strong> Rendered text with custom fonts and alignment</li>
              <li><strong>ParticleEmitter:</strong> Visual effects and particles</li>
            </ul>

            <div class="info-box">
              <p><strong>üé® Design Tip:</strong> Use parent-child relationships to create complex objects. For example, a button can be a sprite with a text child.</p>
            </div>
          </div>
        `
      },

      basic: {
        title: 'Basic Setup',
        description: 'Create a game instance and render a simple sprite',
        code: `import { Game, Scene, Sprite } from '@mode7/zap';

// Create game instance
const game = new Game({
  width: 400,
  height: 300,
  backgroundColor: '#0f3460'
});

// Create scene
const scene = new Scene();

// Create a sprite
const box = new Sprite({
  x: 200, y: 150,
  width: 80, height: 80,
  color: '#e94560',
  radius: 10
});

scene.add(box);
game.setScene(scene);
game.start();`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();
          const box = new Sprite({
            x: 200, y: 150,
            width: 80, height: 80,
            color: '#e94560',
            radius: 10
          });

          scene.add(box);
          game.setScene(scene);
          game.start();

          return game;
        }
      },

      sprites: {
        title: 'Sprites & Shapes',
        description: 'Different sprite shapes with colors and rounded corners',
        code: `import { Sprite } from '@mode7/zap';

// Circle
const circle = new Sprite({
  x: 100, y: 150,
  width: 60, height: 60,
  color: '#e94560',
  radius: 30 // Half of width = circle
});

// Rectangle
const rect = new Sprite({
  x: 200, y: 150,
  width: 80, height: 60,
  color: '#16a085',
  radius: 0
});

// Rounded rectangle
const rounded = new Sprite({
  x: 320, y: 150,
  width: 80, height: 60,
  color: '#f39c12',
  radius: 15
});`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();

          scene.add(new Sprite({ x: 100, y: 150, width: 60, height: 60, color: '#e94560', radius: 30 }));
          scene.add(new Sprite({ x: 200, y: 150, width: 80, height: 60, color: '#16a085', radius: 0 }));
          scene.add(new Sprite({ x: 320, y: 150, width: 80, height: 60, color: '#f39c12', radius: 15 }));

          game.setScene(scene);
          game.start();
          return game;
        }
      },

      images: {
        title: 'Image Sprites',
        description: 'Load and display images from remote URLs',
        code: `import { Sprite } from '@mode7/zap';

const sprite = new Sprite({
  x: 200,
  y: 150,
  width: 100,
  height: 100,
  image: 'https://files.reimage.dev/playspark/aa03381654cb/original.webp',
  radius: 50 // Circular crop
});

sprite.on('imageload', () => {
  console.log('Image loaded!');
});`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();
          const sprite = new Sprite({
            x: 200, y: 150,
            width: 100, height: 100,
            image: 'https://files.reimage.dev/playspark/aa03381654cb/original.webp',
            radius: 50
          });

          scene.add(sprite);
          game.setScene(scene);
          game.start();
          return game;
        }
      },

      tap: {
        title: 'Tap Gesture',
        description: 'Tap the sprite to trigger animations',
        code: `const sprite = new Sprite({
  x: 200, y: 150,
  width: 80, height: 80,
  color: '#e94560',
  interactive: true // Enable gestures
});

sprite.on('tap', () => {
  sprite.tween(
    { rotation: sprite.rotation + Math.PI },
    { duration: 300, easing: 'easeOutBack' }
  );
});`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();
          const sprite = new Sprite({
            x: 200, y: 150,
            width: 80, height: 80,
            color: '#e94560',
            radius: 10,
            interactive: true
          });

          sprite.on('tap', () => {
            sprite.tween(
              { rotation: sprite.rotation + Math.PI },
              { duration: 300, easing: Easing.easeOutBack }
            );
          });

          const text = new Text({
            text: 'Tap me!',
            x: 200, y: 240,
            fontSize: 16,
            color: '#888',
            align: 'center'
          });

          scene.add(sprite);
          scene.add(text);
          game.setScene(scene);
          game.start();
          return game;
        }
      },

      text: {
        title: 'Text Rendering',
        description: 'Display text with different alignments and styles',
        code: `import { Text } from '@mode7/zap';

const title = new Text({
  text: 'Hello Zap!',
  x: 200, y: 80,
  fontSize: 32,
  color: '#4fc3f7',
  align: 'center'
});

const subtitle = new Text({
  text: 'Lightweight 2D game engine',
  x: 200, y: 120,
  fontSize: 16,
  color: '#888',
  align: 'center'
});`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();
          scene.add(new Text({ text: 'Hello Zap!', x: 200, y: 80, fontSize: 32, color: '#4fc3f7', align: 'center' }));
          scene.add(new Text({ text: 'Lightweight 2D game engine', x: 200, y: 120, fontSize: 16, color: '#888', align: 'center' }));
          scene.add(new Text({ text: 'Perfect for playable ads', x: 200, y: 220, fontSize: 14, color: '#ccc', align: 'center' }));

          game.setScene(scene);
          game.start();
          return game;
        }
      },

      fonts: {
        title: 'Google Fonts',
        description: 'Load and use Google Fonts dynamically',
        code: `import { loadGoogleFont, Text } from '@mode7/zap';

// Load Google Font
await loadGoogleFont('Poppins', [600]);

const text = new Text({
  text: 'Styled with Poppins',
  x: 200, y: 150,
  fontSize: 28,
  fontFamily: 'Poppins, sans-serif',
  color: '#f39c12',
  align: 'center'
});`,
        init: async (container) => {
          await loadGoogleFont('Poppins', [600]);

          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();
          scene.add(new Text({
            text: 'Styled with Poppins',
            x: 200, y: 150,
            fontSize: 28,
            fontFamily: 'Poppins, sans-serif',
            color: '#f39c12',
            align: 'center'
          }));

          game.setScene(scene);
          game.start();
          return game;
        }
      },

      swipe: {
        title: 'Swipe Gesture',
        description: 'Swipe the sprite to move it',
        code: `sprite.on('swipe', (event) => {
  console.log('Direction:', event.direction);

  if (event.direction === 'left') sprite.x -= 50;
  if (event.direction === 'right') sprite.x += 50;
  if (event.direction === 'up') sprite.y -= 50;
  if (event.direction === 'down') sprite.y += 50;
});`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();
          const sprite = new Sprite({
            x: 200, y: 150,
            width: 60, height: 60,
            color: '#16a085',
            radius: 10,
            interactive: true
          });

          sprite.on('swipe', (event) => {
            if (event.direction === 'left') sprite.x -= 50;
            if (event.direction === 'right') sprite.x += 50;
            if (event.direction === 'up') sprite.y -= 50;
            if (event.direction === 'down') sprite.y += 50;
          });

          const text = new Text({
            text: 'Swipe me!',
            x: 200, y: 30,
            fontSize: 16,
            color: '#888',
            align: 'center'
          });

          scene.add(sprite);
          scene.add(text);
          game.setScene(scene);
          game.start();
          return game;
        }
      },

      drag: {
        title: 'Drag Gesture',
        description: 'Drag sprites around the canvas',
        code: `sprite.on('drag', (event) => {
  sprite.x += event.delta.x;
  sprite.y += event.delta.y;
});`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();
          const sprite = new Sprite({
            x: 200, y: 150,
            width: 70, height: 70,
            color: '#9b59b6',
            radius: 10,
            interactive: true
          });

          sprite.on('drag', (event) => {
            sprite.x += event.delta.x;
            sprite.y += event.delta.y;
          });

          const text = new Text({
            text: 'Drag me around!',
            x: 200, y: 30,
            fontSize: 16,
            color: '#888',
            align: 'center'
          });

          scene.add(sprite);
          scene.add(text);
          game.setScene(scene);
          game.start();
          return game;
        }
      },

      animations: {
        title: 'Animations',
        description: 'Tween sprite properties smoothly',
        code: `sprite.tween(
  { x: 350, rotation: Math.PI * 2 },
  { duration: 1000, easing: 'easeInOutQuad' }
);`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();
          const sprite = new Sprite({
            x: 50, y: 150,
            width: 50, height: 50,
            color: '#e74c3c',
            radius: 8
          });

          function animate() {
            sprite.tween(
              { x: 350, rotation: Math.PI * 2 },
              {
                duration: 1500,
                easing: Easing.easeInOutQuad,
                onComplete: () => {
                  sprite.rotation = 0;
                  sprite.tween(
                    { x: 50 },
                    { duration: 1500, easing: Easing.easeInOutQuad, onComplete: animate }
                  );
                }
              }
            );
          }
          animate();

          scene.add(sprite);
          game.setScene(scene);
          game.start();
          return game;
        }
      },

      easing: {
        title: 'Easing Functions',
        description: 'Different easing effects for animations',
        code: `// Linear
sprite1.tween({ y: 250 }, { duration: 1000, easing: 'linear' });

// Bounce
sprite2.tween({ y: 250 }, { duration: 1000, easing: 'easeOutBounce' });

// Elastic
sprite3.tween({ y: 250 }, { duration: 1000, easing: 'easeOutElastic' });`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();

          const s1 = new Sprite({ x: 80, y: 50, width: 40, height: 40, color: '#e94560', radius: 20 });
          const s2 = new Sprite({ x: 200, y: 50, width: 40, height: 40, color: '#4fc3f7', radius: 20 });
          const s3 = new Sprite({ x: 320, y: 50, width: 40, height: 40, color: '#f39c12', radius: 20 });

          scene.add(new Text({ text: 'Linear', x: 80, y: 20, fontSize: 12, color: '#888', align: 'center' }));
          scene.add(new Text({ text: 'Bounce', x: 200, y: 20, fontSize: 12, color: '#888', align: 'center' }));
          scene.add(new Text({ text: 'Elastic', x: 320, y: 20, fontSize: 12, color: '#888', align: 'center' }));

          function animate() {
            s1.y = 50;
            s2.y = 50;
            s3.y = 50;

            s1.tween({ y: 230 }, { duration: 1500, easing: Easing.linear });
            s2.tween({ y: 230 }, { duration: 1500, easing: Easing.easeOutBounce });
            s3.tween({ y: 230 }, { duration: 1500, easing: Easing.easeOutElastic, onComplete: () => {
              setTimeout(animate, 500);
            }});
          }
          animate();

          scene.add(s1);
          scene.add(s2);
          scene.add(s3);
          game.setScene(scene);
          game.start();
          return game;
        }
      },

      particles: {
        title: 'Particle Effects',
        description: 'Create particle explosions and effects',
        code: `import { ParticleEmitter } from '@mode7/zap';

const emitter = new ParticleEmitter({
  x: 200, y: 150,
  rate: 0,
  colors: ['#e94560', '#4fc3f7', '#f39c12'],
  sizeRange: { min: 3, max: 8 },
  lifetimeRange: { min: 0.5, max: 1.2 }
});

canvas.addEventListener('click', () => {
  emitter.burst(30);
});`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();
          const emitter = new ParticleEmitter({
            x: 200, y: 150,
            rate: 0,
            colors: ['#e94560', '#4fc3f7', '#f39c12'],
            sizeRange: { min: 3, max: 8 },
            lifetimeRange: { min: 0.5, max: 1.2 },
            velocityRange: {
              min: { x: -150, y: -150 },
              max: { x: 150, y: 150 }
            }
          });

          const text = new Text({
            text: 'Click anywhere!',
            x: 200, y: 30,
            fontSize: 16,
            color: '#888',
            align: 'center'
          });

          game.canvas.addEventListener('click', () => {
            emitter.burst(30);
          });

          scene.add(emitter);
          scene.add(text);
          game.setScene(scene);
          game.start();
          return game;
        }
      },

      collision: {
        title: 'Collision Detection',
        description: 'Detect when sprites intersect',
        code: `if (sprite1.intersects(sprite2)) {
  console.log('Collision!');
}

// Also available:
sprite1.isAbove(sprite2);
sprite1.distanceTo(sprite2);`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();
          const s1 = new Sprite({
            x: 150, y: 150,
            width: 60, height: 60,
            color: '#e94560',
            radius: 10,
            interactive: true
          });

          const s2 = new Sprite({
            x: 250, y: 150,
            width: 60, height: 60,
            color: '#4fc3f7',
            radius: 10
          });

          const statusText = new Text({
            text: 'Drag the red box',
            x: 200, y: 30,
            fontSize: 16,
            color: '#888',
            align: 'center'
          });

          s1.on('drag', (event) => {
            s1.x += event.delta.x;
            s1.y += event.delta.y;

            if (s1.intersects(s2)) {
              s2.color = '#2ecc71';
              statusText.text = 'Collision detected!';
              statusText.color = '#2ecc71';
            } else {
              s2.color = '#4fc3f7';
              statusText.text = 'Drag the red box';
              statusText.color = '#888';
            }
          });

          scene.add(s1);
          scene.add(s2);
          scene.add(statusText);
          game.setScene(scene);
          game.start();
          return game;
        }
      },

      layout: {
        title: 'Layout Helpers',
        description: 'Position entities with layout utilities',
        code: `import { Layout } from '@mode7/zap';

// Grid layout
Layout.layoutGrid(sprites, {
  columns: 3,
  rows: 2,
  cellWidth: 60,
  cellHeight: 60,
  spacing: 20,
  startX: 50,
  startY: 80
});

// Circle layout
Layout.layoutCircle(sprites, {
  radius: 80,
  centerX: 200,
  centerY: 150,
  startAngle: 0
});`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();

          // Grid layout sprites
          const gridSprites = [];
          const colors = ['#e94560', '#4fc3f7', '#f39c12', '#2ecc71', '#9b59b6', '#e67e22'];

          for (let i = 0; i < 6; i++) {
            gridSprites.push(new Sprite({
              width: 40,
              height: 40,
              color: colors[i],
              radius: 8
            }));
          }

          Layout.layoutGrid(gridSprites, {
            columns: 3,
            rows: 2,
            cellWidth: 40,
            cellHeight: 40,
            spacing: 10,
            startX: 30,
            startY: 80
          });

          gridSprites.forEach(s => scene.add(s));
          scene.add(new Text({ text: 'Grid', x: 90, y: 40, fontSize: 14, color: '#888', align: 'center' }));

          // Circle layout sprites
          const circleSprites = [];
          for (let i = 0; i < 8; i++) {
            circleSprites.push(new Sprite({
              width: 30,
              height: 30,
              color: colors[i % colors.length],
              radius: 15
            }));
          }

          Layout.layoutCircle(circleSprites, {
            radius: 70,
            centerX: 290,
            centerY: 150,
            startAngle: 0
          });

          circleSprites.forEach(s => scene.add(s));
          scene.add(new Text({ text: 'Circle', x: 290, y: 40, fontSize: 14, color: '#888', align: 'center' }));

          game.setScene(scene);
          game.start();
          return game;
        }
      },

      animatedsprite: {
        title: 'Animated Sprites',
        description: 'Frame-based sprite sheet animations',
        code: `import { AnimatedSprite } from '@mode7/zap';

const character = new AnimatedSprite({
  x: 200, y: 150,
  width: 64, height: 64,
  image: 'spritesheet.png',
  frameWidth: 64,
  frameHeight: 64,
  animations: {
    walk: { frames: [0, 1, 2, 3], fps: 10, loop: true },
    jump: { frames: [4, 5, 6], fps: 15, loop: false }
  }
});

// Play animation
character.play('walk');

// Listen for completion
character.on('animationcomplete', (name) => {
  console.log(\`\${name} finished!\`);
});`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();

          // Create animated sprite with color blocks as frames
          const sprite = new Sprite({
            x: 200, y: 150,
            width: 60, height: 60,
            color: '#e94560',
            radius: 10
          });

          // Simulate frame animation with color changes
          let frame = 0;
          const colors = ['#e94560', '#4fc3f7', '#f39c12', '#2ecc71'];

          interval(200, () => {
            frame = (frame + 1) % colors.length;
            sprite.color = colors[frame];
          });

          const text = new Text({
            text: 'Simulated Animation',
            x: 200, y: 240,
            fontSize: 14,
            color: '#888',
            align: 'center'
          });

          scene.add(sprite);
          scene.add(text);
          game.setScene(scene);
          game.start();
          return game;
        }
      },

      ninepatch: {
        title: 'Nine-Patch',
        description: 'Scalable UI panels without distortion',
        code: `import { NinePatch } from '@mode7/zap';

const panel = new NinePatch({
  x: 200, y: 150,
  width: 200, height: 150,
  image: 'panel.png',
  corners: 16  // Corner size in pixels
});

// Corners stay sharp when resizing
panel.tween(
  { width: 300, height: 200 },
  { duration: 1000 }
);`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();

          // Demonstrate with colored rectangles
          const panel = new Sprite({
            x: 200, y: 150,
            width: 180, height: 120,
            color: '#16213e',
            radius: 12
          });

          const title = new Text({
            text: 'Nine-Patch Panel',
            x: 200, y: 100,
            fontSize: 18,
            color: '#4fc3f7',
            align: 'center'
          });

          const subtitle = new Text({
            text: 'Scalable without distortion',
            x: 200, y: 200,
            fontSize: 12,
            color: '#888',
            align: 'center'
          });

          // Animate size
          let growing = true;
          function animate() {
            panel.tween(
              { width: growing ? 240 : 180, height: growing ? 160 : 120 },
              {
                duration: 1500,
                easing: Easing.easeInOutQuad,
                onComplete: () => {
                  growing = !growing;
                  animate();
                }
              }
            );
          }
          animate();

          scene.add(panel);
          scene.add(title);
          scene.add(subtitle);
          game.setScene(scene);
          game.start();
          return game;
        }
      },

      button: {
        title: 'Button',
        description: 'Interactive UI button component',
        code: `import { Button } from '@mode7/zap';

const startButton = new Button({
  x: 200, y: 150,
  width: 150, height: 50,
  text: 'Start Game',
  backgroundColor: '#e94560',
  hoverColor: '#ff547c',
  pressColor: '#d13650',
  fontSize: 18,
  onClick: () => {
    console.log('Button clicked!');
  }
});

// Update button text
startButton.setText('Loading...');
startButton.disable();`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();

          const button = new Button({
            x: 200, y: 150,
            width: 150, height: 50,
            text: 'Click Me!',
            backgroundColor: '#e94560',
            hoverColor: '#ff547c',
            pressColor: '#d13650',
            fontSize: 18,
            onClick: () => {
              button.setText('Clicked!');
              delay(500, () => {
                button.setText('Click Me!');
              });
            }
          });

          const instruction = new Text({
            text: 'Click the button',
            x: 200, y: 240,
            fontSize: 14,
            color: '#888',
            align: 'center'
          });

          scene.add(button);
          scene.add(instruction);
          game.setScene(scene);
          game.start();
          return game;
        }
      },

      camera: {
        title: 'Camera Control',
        description: 'Follow targets, zoom, and screen shake',
        code: `import { Camera } from '@mode7/zap';

// Follow a target
game.camera.follow(player);

// Zoom in/out
game.camera.setZoom(1.5);

// Screen shake (intensity, duration)
game.camera.shake(3, 400);

// Pan to position
game.camera.panTo(500, 300, 1000);`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();

          const player = new Sprite({
            x: 200, y: 150,
            width: 40, height: 40,
            color: '#e94560',
            radius: 20,
            interactive: true
          });

          player.on('drag', (event) => {
            player.x += event.delta.x;
            player.y += event.delta.y;
          });

          const zoomButton = new Sprite({
            x: 150, y: 50,
            width: 100, height: 35,
            color: '#16213e',
            radius: 8,
            interactive: true
          });

          const zoomLabel = new Text({
            text: 'Zoom',
            fontSize: 13,
            color: '#fff',
            align: 'center',
            baseline: 'middle'
          });
          zoomButton.addChild(zoomLabel);

          const shakeButton = new Sprite({
            x: 270, y: 50,
            width: 100, height: 35,
            color: '#16213e',
            radius: 8,
            interactive: true
          });

          const shakeLabel = new Text({
            text: 'Shake',
            fontSize: 13,
            color: '#fff',
            align: 'center',
            baseline: 'middle'
          });
          shakeButton.addChild(shakeLabel);

          let zoomed = false;
          zoomButton.on('tap', () => {
            zoomed = !zoomed;
            game.camera.setZoom(zoomed ? 1.5 : 1);
          });

          shakeButton.on('tap', () => {
            game.camera.shake(3, 400);
          });

          const instruction = new Text({
            text: 'Drag player ‚Ä¢ Zoom ‚Ä¢ Shake',
            x: 200, y: 270,
            fontSize: 12,
            color: '#888',
            align: 'center'
          });

          scene.add(player);
          scene.add(zoomButton);
          scene.add(shakeButton);
          scene.add(instruction);
          game.setScene(scene);
          game.start();
          return game;
        }
      },

      audio: {
        title: 'Sound & Music',
        description: 'Complete audio system with SFX and music',
        code: `import { audioManager } from '@mode7/zap';

// === LOADING SOUNDS ===

// Load a single sound
audioManager.loadSound('jump', 'sounds/jump.mp3');
audioManager.loadSound('coin', 'sounds/coin.mp3');

// Load multiple sounds at once
audioManager.loadSounds({
  'explosion': 'sounds/explosion.mp3',
  'laser': 'sounds/laser.mp3',
  'hit': 'sounds/hit.mp3'
});

// === PLAYING SOUND EFFECTS ===

// Play a sound
audioManager.playSound('jump');

// Play with options
audioManager.playSound('laser', {
  volume: 0.5,    // 0-1 (default: 1)
  rate: 1.2,      // Playback speed (default: 1)
  loop: false     // Loop sound (default: false)
});

// Play random sound from array (for variety)
audioManager.playRandomSound(['hit1', 'hit2', 'hit3']);

// === BACKGROUND MUSIC ===

// Play looping music
audioManager.playMusic('music/theme.mp3', {
  loop: true,     // Loop (default: true for music)
  volume: 0.7,    // Volume 0-1 (default: 1)
  rate: 1.0       // Playback speed (default: 1)
});

// Control music playback
audioManager.pauseMusic();   // Pause (can resume)
audioManager.resumeMusic();  // Resume paused music
audioManager.stopMusic();    // Stop & reset to beginning

// === VOLUME CONTROLS ===

// Master volume (affects ALL audio: SFX + music)
audioManager.setMasterVolume(0.8);  // 0-1

// Music volume only
audioManager.setMusicVolume(0.5);   // 0-1

// Sound effects volume only
audioManager.setSFXVolume(1.0);     // 0-1

// === MUTE CONTROLS ===

audioManager.mute();         // Mute all audio
audioManager.unmute();       // Unmute all audio
audioManager.toggleMute();   // Toggle mute state

// Check if muted
const muted = audioManager.isMuted();  // Returns boolean`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();

          // Load audio files
          audioManager.loadSound('sfx', 'assets/sfx.mp3');

          // Web Audio API context for generated tones
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const masterGain = audioContext.createGain();
          masterGain.connect(audioContext.destination);
          masterGain.gain.value = 1.0;

          let volume = 1.0;
          let musicPlaying = false;
          let musicPaused = false;

          // Generate simple beep sounds
          const generateBeep = (frequency) => {
            // Check if muted
            if (audioManager.isMuted()) return;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(masterGain);

            oscillator.frequency.value = frequency;
            oscillator.type = 'sine';

            // Apply base volume
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
          };

          // Title
          const title = new Text({
            text: 'Audio System Demo',
            x: 200, y: 20,
            fontSize: 18,
            color: '#4fc3f7',
            align: 'center'
          });

          // Sound Effects Section
          const sfxTitle = new Text({
            text: 'Sound Effects',
            x: 200, y: 50,
            fontSize: 12,
            color: '#888',
            align: 'center'
          });

          // SFX button (real audio file)
          const sfxBtn = new Sprite({
            x: 80, y: 75,
            width: 70, height: 35,
            color: '#e94560',
            radius: 8,
            interactive: true
          });
          const sfxLabel = new Text({
            text: 'SFX',
            fontSize: 13,
            color: '#fff',
            align: 'center',
            baseline: 'middle'
          });
          sfxBtn.addChild(sfxLabel);

          // Beep button (generated tone)
          const beepBtn = new Sprite({
            x: 160, y: 75,
            width: 70, height: 35,
            color: '#2a9d8f',
            radius: 8,
            interactive: true
          });
          const beepLabel = new Text({
            text: 'Beep',
            fontSize: 13,
            color: '#fff',
            align: 'center',
            baseline: 'middle'
          });
          beepBtn.addChild(beepLabel);

          // Click button (generated tone)
          const clickBtn = new Sprite({
            x: 240, y: 75,
            width: 70, height: 35,
            color: '#4fc3f7',
            radius: 8,
            interactive: true
          });
          const clickLabel = new Text({
            text: 'Click',
            fontSize: 13,
            color: '#fff',
            align: 'center',
            baseline: 'middle'
          });
          clickBtn.addChild(clickLabel);

          // Ding button (generated tone)
          const dingBtn = new Sprite({
            x: 320, y: 75,
            width: 70, height: 35,
            color: '#f4a261',
            radius: 8,
            interactive: true
          });
          const dingLabel = new Text({
            text: 'Ding',
            fontSize: 13,
            color: '#fff',
            align: 'center',
            baseline: 'middle'
          });
          dingBtn.addChild(dingLabel);

          // Music Controls Section
          const musicTitle = new Text({
            text: 'Background Music',
            x: 200, y: 125,
            fontSize: 12,
            color: '#888',
            align: 'center'
          });

          // Play Music button
          const playMusicBtn = new Sprite({
            x: 120, y: 150,
            width: 70, height: 35,
            color: '#16213e',
            radius: 8,
            interactive: true
          });
          const playMusicLabel = new Text({
            text: 'Play',
            fontSize: 13,
            color: '#fff',
            align: 'center',
            baseline: 'middle'
          });
          playMusicBtn.addChild(playMusicLabel);

          // Pause Music button
          const pauseMusicBtn = new Sprite({
            x: 200, y: 150,
            width: 70, height: 35,
            color: '#16213e',
            radius: 8,
            interactive: true
          });
          const pauseMusicLabel = new Text({
            text: 'Pause',
            fontSize: 13,
            color: '#fff',
            align: 'center',
            baseline: 'middle'
          });
          pauseMusicBtn.addChild(pauseMusicLabel);

          // Stop Music button
          const stopMusicBtn = new Sprite({
            x: 280, y: 150,
            width: 70, height: 35,
            color: '#16213e',
            radius: 8,
            interactive: true
          });
          const stopMusicLabel = new Text({
            text: 'Stop',
            fontSize: 13,
            color: '#fff',
            align: 'center',
            baseline: 'middle'
          });
          stopMusicBtn.addChild(stopMusicLabel);

          // Mute button
          const muteBtn = new Sprite({
            x: 200, y: 200,
            width: 100, height: 35,
            color: '#16213e',
            radius: 8,
            interactive: true
          });
          const muteLabel = new Text({
            text: 'Mute: OFF',
            fontSize: 13,
            color: '#fff',
            align: 'center',
            baseline: 'middle'
          });
          muteBtn.addChild(muteLabel);

          // Volume label
          const volumeLabel = new Text({
            text: 'Master Volume: 100%',
            x: 200, y: 240,
            fontSize: 12,
            color: '#888',
            align: 'center'
          });

          // Volume slider (visual representation)
          const sliderBg = new Sprite({
            x: 200, y: 260,
            width: 200, height: 6,
            color: '#16213e',
            radius: 3
          });

          const sliderFill = new Sprite({
            x: 100, y: 260, // Left edge
            width: 200, height: 6,
            color: '#4fc3f7',
            radius: 3,
            anchorX: 0, // Anchor to left edge
            anchorY: 0.5
          });

          const sliderHandle = new Sprite({
            x: 300, y: 260,
            width: 16, height: 16,
            color: '#fff',
            radius: 8,
            interactive: true
          });

          // Play sound feedback
          const playVisualFeedback = (button) => {
            button.tween(
              { scaleX: 1.1, scaleY: 1.1 },
              {
                duration: 100,
                easing: Easing.easeOutQuad,
                onComplete: () => {
                  button.tween(
                    { scaleX: 1, scaleY: 1 },
                    { duration: 100 }
                  );
                }
              }
            );
          };

          // SFX button (real audio file)
          sfxBtn.on('tap', () => {
            audioManager.playSound('sfx');
            playVisualFeedback(sfxBtn);
          });

          // Tone buttons (generated)
          beepBtn.on('tap', () => {
            generateBeep(440); // A4 note
            playVisualFeedback(beepBtn);
          });

          clickBtn.on('tap', () => {
            generateBeep(880); // A5 note
            playVisualFeedback(clickBtn);
          });

          dingBtn.on('tap', () => {
            generateBeep(1320); // E6 note
            playVisualFeedback(dingBtn);
          });

          // Music controls
          playMusicBtn.on('tap', () => {
            if (!musicPlaying) {
              audioManager.playMusic('assets/music.mp3', { loop: true, volume: 0.7 });
              musicPlaying = true;
              playMusicBtn.color = '#2ecc71';
            }
            playVisualFeedback(playMusicBtn);
          });

          pauseMusicBtn.on('tap', () => {
            if (musicPlaying) {
              if (musicPaused) {
                // Resume
                audioManager.resumeMusic();
                musicPaused = false;
                pauseMusicLabel.text = 'Pause';
                pauseMusicBtn.color = '#16213e';
              } else {
                // Pause
                audioManager.pauseMusic();
                musicPaused = true;
                pauseMusicLabel.text = 'Resume';
                pauseMusicBtn.color = '#f4a261';
              }
            }
            playVisualFeedback(pauseMusicBtn);
          });

          stopMusicBtn.on('tap', () => {
            audioManager.stopMusic();
            musicPlaying = false;
            musicPaused = false;
            playMusicBtn.color = '#16213e';
            pauseMusicBtn.color = '#16213e';
            pauseMusicLabel.text = 'Pause';
            playVisualFeedback(stopMusicBtn);
          });

          muteBtn.on('tap', () => {
            audioManager.toggleMute();
            const muted = audioManager.isMuted();
            muteLabel.text = muted ? 'Mute: ON' : 'Mute: OFF';
            muteBtn.color = muted ? '#e94560' : '#16213e';
          });

          // Slider interaction
          sliderHandle.on('drag', (event) => {
            const minX = 100;
            const maxX = 300;
            sliderHandle.x = Math.max(minX, Math.min(maxX, sliderHandle.x + event.delta.x));

            volume = (sliderHandle.x - minX) / (maxX - minX);

            // Update both audioManager and Web Audio gain
            audioManager.setMasterVolume(volume);
            masterGain.gain.value = volume;

            // Update fill bar width (x stays at 100, width changes)
            sliderFill.width = (sliderHandle.x - minX);

            volumeLabel.text = `Master Volume: ${Math.round(volume * 100)}%`;
          });

          const info = new Text({
            text: 'Try SFX, tones, music, and volume controls',
            x: 200, y: 283,
            fontSize: 11,
            color: '#666',
            align: 'center'
          });

          scene.add(title);
          scene.add(sfxTitle);
          scene.add(sfxBtn);
          scene.add(beepBtn);
          scene.add(clickBtn);
          scene.add(dingBtn);
          scene.add(musicTitle);
          scene.add(playMusicBtn);
          scene.add(pauseMusicBtn);
          scene.add(stopMusicBtn);
          scene.add(muteBtn);
          scene.add(volumeLabel);
          scene.add(sliderBg);
          scene.add(sliderFill);
          scene.add(sliderHandle);
          scene.add(info);

          game.setScene(scene);
          game.start();
          return game;
        }
      },

      touchtrail: {
        title: 'Touch Trail',
        description: 'Visual feedback for touch and mouse movements',
        code: `import { Game } from '@mode7/zap';

// Enable built-in touch trail
const game = new Game({
  width: 400,
  height: 300,
  backgroundColor: '#0f3460',
  enableTouchTrail: true  // Enable touch trail
});

// The trail automatically appears when you
// click and drag or touch the canvas!`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460',
            enableTouchTrail: true
          });

          const scene = new Scene();

          const text = new Text({
            text: 'Click and drag to draw!',
            x: 200, y: 150,
            fontSize: 18,
            color: '#4fc3f7',
            align: 'center'
          });

          const instructions = new Text({
            text: 'The trail appears automatically when you drag',
            x: 200, y: 180,
            fontSize: 12,
            color: '#888',
            align: 'center'
          });

          scene.add(text);
          scene.add(instructions);
          game.setScene(scene);
          game.start();
          return game;
        }
      },

      assetloader: {
        title: 'Asset Loader',
        description: 'Preload images before starting the game',
        isDoc: true,
        content: `
          <div class="doc-content">
            <h3>Preloading Assets</h3>
            <p>The AssetLoader helps you preload images before your game starts, ensuring smooth gameplay without loading delays:</p>

            <div class="code-section">
              <h3>Code Example</h3>
              <pre><span class="keyword">import</span> { AssetLoader } <span class="keyword">from</span> <span class="string">'@mode7/zap'</span>;

<span class="keyword">const</span> loader = <span class="keyword">new</span> <span class="function">AssetLoader</span>();

<span class="comment">// Add images to load</span>
loader.<span class="function">add</span>(<span class="string">'player'</span>, <span class="string">'assets/player.png'</span>);
loader.<span class="function">add</span>(<span class="string">'enemy'</span>, <span class="string">'assets/enemy.png'</span>);
loader.<span class="function">add</span>(<span class="string">'bg'</span>, <span class="string">'assets/background.png'</span>);

<span class="comment">// Track progress</span>
loader.<span class="function">on</span>(<span class="string">'progress'</span>, (loaded, total) => {
  <span class="function">console.log</span>(\`\${loaded}/\${total} loaded\`);
});

<span class="comment">// Start loading</span>
<span class="keyword">await</span> loader.<span class="function">load</span>();

<span class="comment">// Use loaded images</span>
<span class="keyword">const</span> sprite = <span class="keyword">new</span> <span class="function">Sprite</span>({
  image: loader.<span class="function">get</span>(<span class="string">'player'</span>)
});</pre>
            </div>

            <h3>API Methods</h3>
            <ul>
              <li><code>add(key, url)</code> - Add an image to the load queue</li>
              <li><code>load()</code> - Start loading all assets (returns Promise)</li>
              <li><code>get(key)</code> - Get a loaded image by key</li>
              <li><code>on('progress', callback)</code> - Track loading progress</li>
            </ul>
          </div>
        `
      },

      storage: {
        title: 'Storage',
        description: 'Persist game data with localStorage wrapper',
        isDoc: true,
        content: `
          <div class="doc-content">
            <h3>Persistent Data Storage</h3>
            <p>The Storage utility provides a simple wrapper around localStorage for persisting game data across sessions:</p>

            <div class="code-section">
              <h3>Code Example</h3>
              <pre><span class="keyword">import</span> { Storage } <span class="keyword">from</span> <span class="string">'@mode7/zap'</span>;

<span class="comment">// Save data</span>
Storage.<span class="function">set</span>(<span class="string">'highScore'</span>, <span class="number">1000</span>);
Storage.<span class="function">set</span>(<span class="string">'playerData'</span>, { name: <span class="string">'Player1'</span>, level: <span class="number">5</span> });

<span class="comment">// Load data</span>
<span class="keyword">const</span> highScore = Storage.<span class="function">get</span>(<span class="string">'highScore'</span>);
<span class="keyword">const</span> playerData = Storage.<span class="function">get</span>(<span class="string">'playerData'</span>);

<span class="comment">// Check if exists</span>
<span class="keyword">if</span> (Storage.<span class="function">has</span>(<span class="string">'highScore'</span>)) {
  <span class="function">console.log</span>(<span class="string">'High score exists!'</span>);
}

<span class="comment">// Remove data</span>
Storage.<span class="function">remove</span>(<span class="string">'playerData'</span>);

<span class="comment">// Clear all</span>
Storage.<span class="function">clear</span>();</pre>
            </div>

            <h3>API Methods</h3>
            <ul>
              <li><code>set(key, value)</code> - Save data (automatically serializes objects)</li>
              <li><code>get(key, defaultValue?)</code> - Load data (automatically deserializes)</li>
              <li><code>has(key)</code> - Check if key exists</li>
              <li><code>remove(key)</code> - Delete specific key</li>
              <li><code>clear()</code> - Remove all stored data</li>
            </ul>

            <div class="info-box">
              <p><strong>üí° Note:</strong> Storage automatically handles JSON serialization, so you can save and load objects, arrays, and primitives seamlessly.</p>
            </div>
          </div>
        `
      },

      timer: {
        title: 'Timers',
        description: 'Delay and interval utilities',
        code: `import { delay, interval, wait } from '@mode7/zap';

// Delay execution
delay(1000, () => {
  console.log('Executed after 1 second');
});

// Repeat with interval
const intervalId = interval(500, () => {
  console.log('Every 500ms');
});

// Stop interval
clearInterval(intervalId);

// Async wait
async function example() {
  await wait(2000);
  console.log('After 2 seconds');
}`,
        init: (container) => {
          const game = new Game({
            parent: container,
            width: 400,
            height: 300,
            backgroundColor: '#0f3460'
          });

          const scene = new Scene();

          let counter = 0;

          const counterText = new Text({
            text: 'Counter: 0',
            x: 200, y: 100,
            fontSize: 24,
            color: '#4fc3f7',
            align: 'center'
          });

          const statusText = new Text({
            text: 'Incrementing every second...',
            x: 200, y: 140,
            fontSize: 14,
            color: '#888',
            align: 'center'
          });

          // Use interval to count
          interval(1000, () => {
            counter++;
            counterText.text = `Counter: ${counter}`;
          });

          const button = new Sprite({
            x: 200, y: 200,
            width: 140, height: 45,
            color: '#e94560',
            radius: 8,
            interactive: true
          });

          const buttonLabel = new Text({
            text: 'Delay Test',
            fontSize: 16,
            color: '#fff',
            align: 'center',
            baseline: 'middle'
          });
          button.addChild(buttonLabel);

          button.on('tap', () => {
            buttonLabel.text = 'Wait 2s...';
            button.color = '#666';
            button.interactive = false;

            delay(2000, () => {
              buttonLabel.text = 'Done!';
              button.color = '#2ecc71';

              delay(1000, () => {
                buttonLabel.text = 'Delay Test';
                button.color = '#e94560';
                button.interactive = true;
              });
            });
          });

          scene.add(counterText);
          scene.add(statusText);
          scene.add(button);
          game.setScene(scene);
          game.start();
          return game;
        }
      }
    };

    async function loadDemo(demoKey) {
      // Cleanup previous demo
      if (currentGame) {
        currentGame.stop();
        currentGame.destroy();
        currentGame = null;
      }

      const demo = demos[demoKey];
      if (!demo) return;

      // Update header
      document.getElementById('demo-title').textContent = demo.title;
      document.getElementById('demo-description').textContent = demo.description;

      // Update content
      const content = document.getElementById('demo-content');

      if (demo.isDoc) {
        // Documentation page (no canvas)
        content.innerHTML = `
          <div class="demo-section active">
            ${demo.content}
          </div>
        `;
      } else {
        // Interactive demo with canvas
        content.innerHTML = `
          <div class="demo-section active">
            <div class="demo-container">
              <div class="demo-canvas-wrapper" id="demo-canvas"></div>
            </div>
            <div class="code-section">
              <h3>Code Example</h3>
              <pre>${highlightCode(demo.code)}</pre>
            </div>
          </div>
        `;

        // Initialize demo (await in case it's async)
        const canvasContainer = document.getElementById('demo-canvas');
        currentGame = await demo.init(canvasContainer);
      }
    }

    function highlightCode(code) {
      return code
        .replace(/\b(import|from|const|let|var|function|return|new)\b/g, '<span class="keyword">$1</span>')
        .replace(/'([^']+)'/g, '<span class="string">\'$1\'</span>')
        .replace(/\b([A-Z][a-zA-Z]+)\b/g, '<span class="function">$1</span>')
        .replace(/\/\/(.*)/g, '<span class="comment">//$1</span>')
        .replace(/\b(\d+)\b/g, '<span class="number">$1</span>');
    }

    // Navigation
    document.querySelectorAll('.nav-item').forEach(item => {
      item.addEventListener('click', () => {
        document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
        item.classList.add('active');
        loadDemo(item.dataset.demo);
      });
    });

    // Load installation page by default
    loadDemo('installation');
  </script>
</body>
</html>
